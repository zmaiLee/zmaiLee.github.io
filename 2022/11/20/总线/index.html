<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zmailee.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="什么是总线？ 总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线，它是由导线组成的传输线束， 按照计算机所传输的信息种类，计算机的总线可以划分为数据总线、地址总线和控制总线，分别用来传输数据、数据地址和控制信号。总线是一种内部结构，它是CPU、内存、输入、输出设备传递信息的公用通道，主机的各个部件通过总线相连接，外部设备通过相应的接口电路再与总线相连接，从而形成了计算机硬件系统。在计">
<meta property="og:type" content="article">
<meta property="og:title" content="总线">
<meta property="og:url" content="https://zmailee.github.io/2022/11/20/%E6%80%BB%E7%BA%BF/index.html">
<meta property="og:site_name" content="Mai&#39;s blog">
<meta property="og:description" content="什么是总线？ 总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线，它是由导线组成的传输线束， 按照计算机所传输的信息种类，计算机的总线可以划分为数据总线、地址总线和控制总线，分别用来传输数据、数据地址和控制信号。总线是一种内部结构，它是CPU、内存、输入、输出设备传递信息的公用通道，主机的各个部件通过总线相连接，外部设备通过相应的接口电路再与总线相连接，从而形成了计算机硬件系统。在计">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zmailee.github.io/2022/11/20/%E6%80%BB%E7%BA%BF/%E6%80%BB%E7%BA%BF.assets/v2-7c95b31e753dfedfdfb1ad0d890af01e_1440w.webp">
<meta property="og:image" content="https://zmailee.github.io/2022/11/20/%E6%80%BB%E7%BA%BF/%E6%80%BB%E7%BA%BF.assets/v2-f28c75e6e50991c6640e5737af46bdf3_1440w.webp">
<meta property="og:image" content="https://zmailee.github.io/2022/11/20/%E6%80%BB%E7%BA%BF/%E6%80%BB%E7%BA%BF.assets/v2-7c260f2be1cb05ae5409f4b549ffd3b4_1440w.webp">
<meta property="og:image" content="https://zmailee.github.io/2022/11/20/%E6%80%BB%E7%BA%BF/%E6%80%BB%E7%BA%BF.assets/v2-53b57203fc06a4f4b18c2668cc8bc6fd_1440w.webp">
<meta property="og:image" content="https://zmailee.github.io/2022/11/20/%E6%80%BB%E7%BA%BF/%E6%80%BB%E7%BA%BF.assets/v2-907b3d1e2637ec20fc56acd6c7b8ed88_1440w.jpeg">
<meta property="og:image" content="https://zmailee.github.io/2022/11/20/%E6%80%BB%E7%BA%BF/%E6%80%BB%E7%BA%BF.assets/v2-f33f82462fb92881289d62c092b2c301_1440w.webp">
<meta property="og:image" content="https://zmailee.github.io/2022/11/20/%E6%80%BB%E7%BA%BF/%E6%80%BB%E7%BA%BF.assets/v2-57c3410645d9a3c2f41a0138be9ab826_1440w.webp">
<meta property="og:image" content="https://zmailee.github.io/2022/11/20/%E6%80%BB%E7%BA%BF/%E6%80%BB%E7%BA%BF.assets/v2-e8aa348f7fbc4a866e902d339175750f_1440w.webp">
<meta property="og:image" content="https://zmailee.github.io/2022/11/20/%E6%80%BB%E7%BA%BF/%E6%80%BB%E7%BA%BF.assets/v2-6317343fab92defb85d0cad2117074ff_1440w.webp">
<meta property="og:image" content="https://zmailee.github.io/2022/11/20/%E6%80%BB%E7%BA%BF/%E6%80%BB%E7%BA%BF.assets/v2-eb053295f403d5230c57f64f63f1e228_1440w.webp">
<meta property="article:published_time" content="2022-11-20T09:35:24.993Z">
<meta property="article:modified_time" content="2022-11-26T01:55:57.227Z">
<meta property="article:author" content="zmaiLee">
<meta property="article:tag" content="AXI">
<meta property="article:tag" content="PCle">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zmailee.github.io/2022/11/20/%E6%80%BB%E7%BA%BF/%E6%80%BB%E7%BA%BF.assets/v2-7c95b31e753dfedfdfb1ad0d890af01e_1440w.webp">

<link rel="canonical" href="https://zmailee.github.io/2022/11/20/%E6%80%BB%E7%BA%BF/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" type="text/css" href="/css/injector/main.css" /><link rel="preload" as="style" href="/css/injector/light.css" /><link rel="preload" as="style" href="/css/injector/dark.css" />
  <title>总线 | Mai's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Mai's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
     <a href="https://zmailee.github.io" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Mai's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">try my best</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/zmaiLee" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zmailee.github.io/2022/11/20/%E6%80%BB%E7%BA%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="zmaiLee">
      <meta itemprop="description" content="HUSTer19. ICdesign & Computer Architecture">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mai's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          总线
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-20 17:35:24" itemprop="dateCreated datePublished" datetime="2022-11-20T17:35:24+08:00">2022-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-26 09:55:57" itemprop="dateModified" datetime="2022-11-26T09:55:57+08:00">2022-11-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IC/" itemprop="url" rel="index"><span itemprop="name">IC</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="什么是总线">什么是总线？</h1>
<p>总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线，它是由导线组成的传输线束，
按照计算机所传输的信息种类，计算机的总线可以划分为数据总线、地址总线和控制总线，分别用来传输数据、数据地址和控制信号。总线是一种内部结构，它是CPU、内存、输入、输出设备传递信息的公用通道，主机的各个部件通过总线相连接，外部设备通过相应的接口电路再与总线相连接，从而形成了计算机硬件系统。在计算机系统中，各个部件之间传送信息的公共通路叫总线，微型计算机是以总线结构来连接各个功能部件的。</p>
<span id="more"></span>
<h1 id="axi总线">AXI总线</h1>
<ul>
<li><a
target="_blank" rel="noopener" href="https://developer.arm.com/Architectures/AMBA"><strong>AMBA手册</strong></a></li>
<li><a
target="_blank" rel="noopener" href="https://www.lzrnote.cn/2021/10/08/axi总线总结/"><strong>总线中文手册及总结</strong></a></li>
<li><a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/44766356"><strong>深入AXI4总线</strong></a></li>
</ul>
<h2 id="validready-握手机制">VALID/READY 握手机制</h2>
<p>VALID/READY
作为一种双向流控机制，可以使发送接收双方都有能力控制传输速率。</p>
<p><strong>发送方</strong>置高 <strong>VALID</strong>
信号表示发送方已经将数据，地址或者控制信息已经就绪，并保持于消息总线上。</p>
<p><strong>接收方</strong>置高 <strong>READY</strong>
信号表示接收方已经做好接收的准备。</p>
<p>当双方的 VALID/READY
信号同时为高，在时钟上升沿，完成一次数据传输。所有数据传输完毕后，双方同时置低自己的信号。</p>
<p>所谓的<strong>双向流控</strong>机制，指的是发送方通过置起 VALID
信号控制发送的时机与速度，接收方也可以通过 READY
信号的置起与否控制接收速度。发送方拥有传输的主动权，但接收方在不具备接收能力时，也能够置低信号停止传输，反压发送方。</p>
<p>VALID 信号一旦置起就不能置低，直到完成握手（handshake
occurs）。在设计接收方逻辑时，检测到 VALID
信号置起，如果系统正忙，完全可以让发送方等待，发送方在完成传输之前都不会置低
VALID
信号，不需要考虑发送方撤销传输的可能。协议另外规定：发送方不能通过等待接收方
READY 信号来确定置起 VALID 信号的时机。</p>
<p>换句话说，发送方准备发送，置起 VALID
信号是完全<strong>主动与独立</strong>的过程。接收方 READY
信号按照协议可以依赖发送方 VALID
信号，但如果此时发送方也依赖接收方信号，就会造成死锁的情况，所以协议在这里强调了
VALID 信号的主动性。</p>
<p>接收方可以置起 READY 之后发现：其实我好像还挺忙，然后置低 READY
信号。只要此时 VALID 信号没有置起，这种操作是完全可以。</p>
<p>READY 信号原则上由接收方自身的接收状况以及 VALID
信号控制。（或者仅由接收方自身的接收状况决定）协议中没有规定 READY
信号的默认状态，即未进行传输时的电平状态（default value）。</p>
<p>协议建议 AW/AR READY
信号的默认电平为高电平。若默认电平为低，则每次传输至少需要 2
个周期才能完成，第一个周期置高 VALID 信号，第二个周期从机才会置高 READY
信号。相当于每次传输增加 1
个周期时间开销，这在某些情况下会对传输效率有较大的影响。</p>
<h2 id="axi4-lite">AXI4-Lite</h2>
<h2 id="axi4">AXI4</h2>
<p>AXI4协议分为以下几个通道：</p>
<ul>
<li>AR：读地址通道</li>
<li>R ：读数据通道</li>
<li>AW：写地址通道</li>
<li>W ：写数据通道</li>
<li>B ：写反馈通道</li>
</ul>
<h3 id="araw通道">AR/AW通道：</h3>
<p>Master-&gt;Slave信号:</p>
<ul>
<li><code>A[RW]ADDR</code>：读写的字节地址</li>
<li><code>A[RW]LEN</code>：读写的传输次数，次数定义为<code>A[RW]LEN+1</code>。</li>
<li><code>A[RW]SIZE</code>：单次传输的数据大小，字节数定义为<code>2 ** A[RW]SIZE</code>，且不可超过数据总线宽度。</li>
<li><code>A[RW]BURST</code>：突发传输类型（INCR与WARP模式可以一次地址握手完成多次不同地址的数据传输，提高Cache替换效率，若只需要实现AXI4Lite可直接使用FIXED模式）</li>
<li><code>A[RW]VALID</code>：读写的有效性</li>
</ul>
<p>此外，这里依据Slave支持的特性不同可能还有<code>A[RW]CACHE</code>、<code>A[RW]PROT</code>、<code>A[RW]PROT</code>、<code>A[RW]QOS</code>信号，这些信号我们可暂时忽略，直接assign为0即可。</p>
<p>如果总线支持<code>A[RW]ID</code>，则需要对于不同的设备传输正确的ID信息。例如你的CPU的I-Cache与D-Cache独立，且都使用AXI访问总线，你就可以在CPU核里面写一个AXI
Crossbar，并使用不同的ID区分设备，在握手时仲裁，并在数据返回时发送给对应的设备。</p>
<p>Slave-&gt;Master:</p>
<ul>
<li><code>A[RW]READY</code>：地址握手完成</li>
</ul>
<p>地址握手流程：</p>
<ol type="1">
<li>初始状态，Master端<code>A[RW]VALID</code>
<strong>必须</strong>为0，Slave端<code>A[RW]READY</code>只要不是复位状态<strong>可以</strong>为1，以便Slave单周期握手。</li>
<li>Master填写正确填写<code>A[RW]ADDR</code>、<code>A[RW]SIZE</code>等信号，并将<code>A[RW]VALID</code>设置为1。</li>
<li>当某一时刻的<strong>时钟上升沿之前</strong>出现<code>A[RW]VALID</code>与<code>A[RW]READY</code>都为1时，地址握手结束。此时Master端<strong>必须在时钟上升沿之后</strong>将<code>A[RW]VALID</code>信号置0或发送新的请求。否则Slave端将认为同一个地址请求发送了2次，并做出2次响应。</li>
</ol>
<h3 id="r通道">R通道：</h3>
<p>Slave-&gt;Master信号：</p>
<ul>
<li><code>RDATA</code>：读取数据结果</li>
<li><code>RLAST</code>：标记最后一次读数据传输
可用于检验COUNT是否一致</li>
<li><code>RRESP</code>：读数据的反馈，用于传输总线错误。
简单核的实现可以在总线错误时不产生异常，只需要确保软件访问物理内存地址一定正确即可。</li>
<li><code>RVALID</code>：读数据有效</li>
</ul>
<p><code>RID</code>用于与<code>ARID</code>对应，用于标识对应的请求。</p>
<p>Master-&gt;Slave信号：</p>
<ul>
<li><code>RREADY</code>：本次读数据传输完成</li>
</ul>
<h3 id="w通道">W通道：</h3>
<p>Master-&gt;Slave信号：</p>
<ul>
<li><code>WDATA</code>：写数据</li>
<li><code>WSTRB</code>：写掩码</li>
<li><code>WLAST</code>：标记最后一次写数据传输（可用于检验COUNT是否一致）</li>
<li><code>WVALID</code>：写数据有效</li>
</ul>
<p>注：AXI3存在WID，AXI4省略了WID。因为AXI不允许Master先握手AW再握手W这样的操作，因此WID显得无意义。</p>
<p>Slave-&gt;Master信号：</p>
<ul>
<li><code>WREADY</code>：本次写数据传输完成</li>
</ul>
<h3 id="b通道">B通道：</h3>
<p>Slave-&gt;Master信号：</p>
<ul>
<li><code>BID</code>：与AWID对应，表示对应写请求的反馈。</li>
<li><code>BRESP</code>：写数据的反馈，与<code>RRESP</code>一样，用于传输总线错误。</li>
<li><code>BVALID</code>：写反馈有效</li>
</ul>
<p>Master-&gt;Slave信号：</p>
<ul>
<li><code>BREADY</code>：本次写反馈传输完成</li>
</ul>
<h3 id="burst类型">Burst类型</h3>
<p>AXI4支持突发传输，实现一次地址握手传输多个数据，避免将大量时间花在地址握手传输上。</p>
<p>尽管AR与R通道以及AW与W通道的分离看似地址与数据可以流水化传输，但是对于许多硬件Slave设备而言，往往地址握手后一段时间才能读写第一个数据（例如DDR内存），这便是突发传输能够加速的原因。</p>
<p>AXI4支持以下3种BURST类型：</p>
<ol type="1">
<li><p>FIXED</p>
<p>每次都操作[<code>A[RW]ADDR</code> +:
<code>A[RW]SIZE</code>]部分。</p></li>
<li><p>INCR</p>
<p>从<code>A[RW]ADDR</code>开始，
每次操作地址递增<code>A[RW]SIZE</code>。</p>
<p>如果某一时刻操作的地址越过了总线宽度范围，则本次只传输到结束位置，下次传输地址从对齐总线宽度的地方开始。</p>
<p>例如某一时刻操作地址=5，总线宽度8字节，每次传输字节数为4，则本次操作传输字节5-7部分，下次传输8-11部分。</p></li>
<li><p>WARP</p>
<p>类似INCR类型，用于传输一段2的整数幂字节的地址范围，但可以通过设置<code>A[RW]ADDR</code>决定起始地址。</p>
<p>但这一类型的Burst对于发送的地址存在一定限制，详情请大家自己看AMBA文档。</p>
<p>具体地址计算细节请自行阅读<a
target="_blank" rel="noopener" href="https://developer.arm.com/Architectures/AMBA">AMBA文档</a>的A3.Transcation
structure部分。</p></li>
</ol>
<h4 id="narrow-burst">Narrow Burst</h4>
<p>当<code>A[RW]SIZE</code>指定的单次传输数据大小<strong>小于</strong>总线数据宽度时，这种Burst称为Narrow
Burst。</p>
<p>对于Narrow
Burst，无论是读写请求，数据都出现在<code>[RW]DATA</code>对应访问地址%总线宽度的位置。</p>
<p>举个例子：使用INCR
Burst读取内存地址[6]、[7]、[8]，每次读取1字节。总线<code>RDATA</code>宽度为64位。</p>
<p>按照以下方式发送AR请求：</p>
<ul>
<li>ARADDR=6</li>
<li>ARSIZE=0（1 Bytes）</li>
<li>ARLEN=2（3 Bursts）</li>
<li>ARBURST=1（INCR）</li>
</ul>
<p>SLAVE会在R通道传回3个请求，分别是：</p>
<ul>
<li><p>第一次传输：</p>
<p>Slave读取[6]地址，有效数据在<code>RDATA</code>的<code>[55:48]</code>部分。</p></li>
<li><p>第二次传输</p>
<p>Slave读取[7]地址，有效数据在<code>RDATA</code>的<code>[63:56]</code>部分。</p></li>
<li><p>第三次传输：</p>
<p>Slave读取[8]地址，有效数据在<code>RDATA</code>的<code>[7:0]</code>部分。</p></li>
</ul>
<h3 id="axi4注意事项">AXI4注意事项</h3>
<ol type="1">
<li><p>所有通道的<code>VALID</code>与<code>READY</code>之间不能有组合逻辑。无论对于Master端还是Slave端。如果想要单周期握手，对于AR、AW、W通道，Slave可以选择默认状态下将<code>READY</code>置1。对于R、B通道，Master可以选择默认状态下将<code>READY</code>置1。</p></li>
<li><p>对于写请求，不可等待<code>AW</code>握手完成后再升高<code>WVALID</code>。因为AXI协议允许Slave设备等待<code>AWVALID</code>与<code>WVALID</code>都为1后，再升高<code>AWREADY</code>。如果这么做或许部分SoC上能运行，但会在使用部分Slave设备时出现死锁（例如Vivado
Block Memory Generator）。</p></li>
<li><p>AXI请求不可撤销。</p>
<p>一旦任何通道的VALID升高后，其数据必须保持不变直到握手结束，包括ID部分和VALID本身。所以只依靠AXI信号实现的纯组合逻辑AXI
Crossbar一定是不符合规范的。</p></li>
<li><p>对于外设的MMIO访问，需要根据所对应访存的指令的长度正确填写<code>A[RW]SIZE</code>。</p>
<p>例如<code>lb</code>与<code>sb</code>指令的<code>A[RW]SIZE</code>必须为0（表示1字节）。不应该在针对MMIO的写请求时使用<code>WSTRB</code>指定要更改的数据范围。对于读请求，也不应该读出整个数据宽度后再选择。因为这两种方式在MMIO设备看来访问的是不同的寄存器。</p></li>
<li><p>写操作直到BVALID拉高才算结束。</p>
<p>如果不等待B通道马上在AR通道发出读请求，有可能读到写完成之前的旧值。</p></li>
</ol>
<h3 id="写传输操作write-transcation">写传输操作：Write transcation</h3>
<p>如下图所示，主机首先在写地址通道（AW）上告知从机本次传输操作（transcaction，对应后文中的"传输操作"）的特性，包括地址和控制信息。然后，在写数据通道（W）向从机写入数据，一次传输操作中可能包括多个数据传输。</p>
<p>最后，从机在接收到写数据后，通过写回复通道（R）将本次传输操作的响应告知主机。主机以收到从机的响应信号，作为本次传输操作结束的标志。<strong>写回复是针对整个传输操作（transcaction）的，而不是针对每个写入数据（data
transfer），且所有传输操作中，写回复
与写数据的关系都如下图所示，写回复必然是在收到传输操作中最后一个写数据之后触发。</strong></p>
<p>但是，写地址与写数据的关系并不局限于一种情况。一般来说，写数据都发生在写地址操作之后，但也不是绝对的，在有些情况下，可以先写数据，或者在同一周期写入数据与地址，都是允许的。这也表现了
AXI 通道之间的独立性。</p>
<figure>
<img src="总线.assets/v2-7c95b31e753dfedfdfb1ad0d890af01e_1440w.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="读操作read-transcation">读操作：Read transcation</h3>
<p>读操作只涉及两个通道，首先主机在读地址通道上写入本次Transcation待读取数据的地址以及控制信息。从机在接收到地址后，将该地址上的数据通过读数据通道传输给主机。读操作通道间（ARC&amp;RC）完全独立，从机发出读数据一定发生在主机写入读地址后。</p>
<figure>
<img src="总线.assets/v2-f28c75e6e50991c6640e5737af46bdf3_1440w.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="突发传输burst-transaction">突发传输：Burst Transaction</h3>
<p>两个 AXI 组件为了传输一组数据而进行的所有交互称为 <strong>AXI
Transaction</strong>，AXI 传输事务，包括所有 5 个通道上的交互。</p>
<p>AXI 是一个 burst-based 协议，AXI 传输事务中的数据传输以 burst
形式组织，称为 <strong>AXI Burst</strong>。每个传输事务包括一至多个
Burst。每个 Burst 中传输一至多个数据，每个数据传输称为 <strong>AXI
Transfer</strong>。每个Transfer
因为使用一个周期，又被称为一拍数据（Beat）。主机可以写入起始地址以及突发传输的长度等信息，从机将起始地址开始，依次接收主机传输的写数据，或者读取连续地址上的数据，作为读数据传输给主机。所以上面两张图中，一次传输操作中（Transcation）
中包括了一次地址与控制信息（Address &amp; Control）、多个数据（data
transfer）。</p>
<p>注意：单次 burst 传输中的数据，其地址不能跨越 4KB
边界。之所以这样规定是为了避免一笔burst交易访问两个slave（每个slave的地址空间是4K/1K对齐的）。4K对齐最大原因是系统中定义一个page大小是4K，而所谓的4K边界是指低12bit为0的地址。</p>
<p>补充一下：对于一次burst传输，只给出首地址，burst内部的地址按照<span
class="math inline">\(2^{size}\)</span>累加，也就是按每个数据字节数累加，协议之所以这么做，原因是计算机底层存储是按字节存储的。假设传输的数据是32bit，也就是4个字节，那么实际上会分配4个地址给这个32bit数据，所以按照标准的axi协议，相邻的burst首地址按照（awlen+1）*<span
class="math inline">\(2^{size}\)</span>累加，master发送首地址时要遵循这种方式，slave收到地址后，按照标准协议，解析出的burst内部的地址就是按2^size累加的。这样一来，除非size为0，也就是数据为1个字节，地址才是连续的，否则，解析出的地址不连续，不过可以根据用户侧需求，对标准协议地址进行处理，使之连续。上面说的有点混乱，举个例子：假如awlen为3，也就是一次突发传输4个数据。awsize为2，也就是每个数据4字节，32bit，第一次突发传输首地址awaddr为0。那么，根据标准axi协议，slave解析出的第一个burst四个数对应的地址为0，4，8，12，即按字节数累加。master发送第二个burst时，awaddr必须为16，slave解析第二个burst四个点得到的地址为16，20，24，28。这样就相当于给每个32bit分了四个地址，在底层每个地址存一个字节。应用时，有时不涉及底层的存储，假如只完成一个memory的读写，希望使用连续地址，那么用户可以讲按照标准协议解析出的地址除以4之后使用，则0，4，8，12就变成了0，1，2，3。另外，同一个burst的地址不能跨4K边界，而不是4KB，4KB讲的是容量。这是因为底层page的存储容量为4KB。一个burst内部地址按字节数累加，地址跨4K，也就是操作一个burst的数据时跨了4KB，跨page了，这是不允许的，一个
burst的数据必须在同一个page里，否则容易出现错误。</p>
<h3 id="传输事务结构transaction-structure">传输事务结构：Transaction
structure</h3>
<h4 id="读写地址结构"><strong>读写地址结构</strong></h4>
<p>在整个transaction中，主机首先将接下来 burst
传输的<strong>控制信息</strong>以及<strong>数据首个字节的地址</strong>传输给从机，这个地址被称为起始地址。在本次
burst
后续传输期间，从机将根据控制信息计算后续数据的地址。地址通道中传输的控制信息中包括三项突发传输相关的信号(AR/AW
均一致，下图为以 AR 为例)：</p>
<figure>
<img src="总线.assets/v2-7c260f2be1cb05ae5409f4b549ffd3b4_1440w.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>（1）LEN</strong>，指一次突发传输中包含的数据传输(transfer)数量。</p>
<p>在 AXI4 中，INCR 类型最大支持长度为 256，其他类型最大长度为
16，突发长度至少为 1。Len 信号从零开始表示，实际的长度值为 Len +
1。突发传输长度在不同burst type下有一些限制，包括：</p>
<ul>
<li>对于 WRAP 模式，突发传输长度仅能为2,4,8,16</li>
<li>在一次突发传输中，地址不能跨越一个 4KB 分区</li>
<li>一次突发传输不能在完成所有数据传输前提前结束（early
termination）</li>
</ul>
<p>协议中多次<strong>强调</strong>，通信双方都不能在传输事务的所有
Transfer 完成前提前结束，哪怕发生错误，也得走完整个传输事务的流程。</p>
<p>但是主机也有办法减少传输的数据。在写传输事务中，发送方可以通过置低所有的写有效位，使写数据无效。在读传输事务中，主机可以直接丢弃读取到的数据。</p>
<p><strong>（2）SIZE</strong>，指传输中的数据位宽，具体地，是每周期传输数据的字节数量。</p>
<p>突发传输数据宽度不能超过数据总线本身的位宽。而当数据总线位宽大于突发传输宽度时，将根据协议的相关规定，将数据在部分数据线上传输。突发传输宽度信号
AXSIZE 位宽为 3bit，表示为：</p>
<figure>
<img src="总线.assets/v2-53b57203fc06a4f4b18c2668cc8bc6fd_1440w.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>（3）突发传输类型</strong>，类型共有 3 种，分别为 FIXED，INCR
以及 WRAP，使用 2 位表示。</p>
<figure>
<img src="总线.assets/v2-907b3d1e2637ec20fc56acd6c7b8ed88_1440w.jpeg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>FIXED</strong>：burst
中所有数据都使用<strong>起始地址</strong>。该模式适合对某个固定地址进行多次数据更新，比如读写一个
fifo 时，读写地址就是固定的。</p>
<p><strong>INCR</strong>：后续数据的地址在初始地址的基础上进行递增，<strong>递增幅度与传输宽度相同</strong>。适合对于
RAM 等通过地址映射（mapped memory）的存储介质进行读写操作。</p>
<p><strong>WRAP</strong>：首先根据起始地址得到绕回边界地址（wrap
boundary）与最高地址。当前地址小于最高地址时，WRAP 与 INCR
类型完全相同，地址递增。但到递增后的地址到达最高地址后，地址直接回到绕回边界地址，再进行递增，就这样循环往复。最高地址由绕回边界地址计算得到：wrap
boundary + （N_bytes x burst_len）。根据协议，WRAP 适合对 cache
的访问。</p>
<p><strong>地址计算参考</strong></p>
<p>手册在章节 A3
详细给出了不同的突发传输模式下的地址计算公式与伪代码，有相关需求的读者可以参看这一部分。</p>
<h4 id="读写数据结构"><strong>读写数据结构</strong></h4>
<p>在 AXI 数据传输过程中，主要涉及到窄位宽数据传输（Narrow
Transfer）、非对齐传输（Unaligned
Transfer）以及混合大小端传输（mix-endianness）等问题。</p>
<h5 id="narrow-transfer"><strong>（1）Narrow Transfer</strong></h5>
<p>当本次传输中数据位宽小于通道本身的数据位宽时，称为<strong>窄位宽数据传输</strong>。</p>
<p>在窄位宽写传输中，主机需要告知从机数据通道中哪些字节是有效的，需要使用到写数据通道中的
WSTRB 信号。WSTRB 信号中的单个 bit
置起，表示对应位置上的字节有效，对应关系为：当 WSTRB[n] 为 1
时，WDATA[8n+7:8n]有效。WSTRB 信号比特位宽等于数据通道位宽的字节数量</p>
<p>对应于下图的情况中，灰色的部分代表数据无效，第一次的传输中低地址第一字节有效，其他数据无效的
，WSTRB 信号为 0x01，WSTRB [0] 为 1，即 WDATA[7:0] 有效。</p>
<figure>
<img src="总线.assets/v2-f33f82462fb92881289d62c092b2c301_1440w.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>从图中我们发现，在每次数据传输中使用的数据总线字节位置（byte
line）不同，尽管数据以字节为单位，分为多个周期传输，但是数据的位置仍与其地址对应。D[7:0]将写入起始地址
0x0，故位于最低字节。D[15:8] 将写入地址 0x1，故位于次低字节。</p>
<p>个人理解该设计的意义在于，当主机是因为从机或者其他客观条件限制，需要进行窄传输时，可以一次性将数据放置于数据总线上，只需在每次传输期间改变
WSTRB 信号即可。以上图为例，主机将 D[31:0]
防置于总线，在接下来的四个周期中，仅需对 WSTRB 进行移位，即可依次完成 4
个字节的传输。</p>
<p>该结构<strong>有利于 memory
类型的从机进行写入处理</strong>，这里设想一种实现方式，结合下图讲解，在
64bit 位宽的总线上进行 32bit 位宽传输，起始地址为 0x4
。此时假设存储介质位宽与总线位宽一致，为 64 bit。</p>
<p>在 transfer 1st 中，从机获取整个总线上的 64bit
数据存储至存储介质中，比如 DDR，并利用 wstrb 作为 mask 信号屏蔽无效的低
32 bit（比如 DDR 的 DQM 信号）。这时候存储介质的写入地址为
0x0，但实际只从地址 0x4 开始写入了 32bit 数据。在后续的 transfer
继续按以上模式工作。窄传输中通过主机来调整有效数据的字节位置，以及给出字节有效信号
WSTRB，能够使从机无需进行数据重组等工作。</p>
<figure>
<img src="总线.assets/v2-57c3410645d9a3c2f41a0138be9ab826_1440w.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>注意</strong>：协议未规定窄传输中从机的具体实现，这里举了一个设想的例子</p>
<p>在读传输中，从机的操作逻辑与写传输中的主机相同，但是从机没有类似
WSTRB
的信号。所以<strong>需要主机根据突发传输宽度与总线位宽，计算当前总线中有效数据所在字节位置，读取数据</strong>。</p>
<p>协议规定在 INCR 和 WRAP 模式中每次使用的 byte line
必须不同，即<strong>数据位置与地址对应</strong>。而在 FIXED
模式中，整个传输过程使用相同的 byte line（地址不会变）。</p>
<h5 id="unaligned-transfer"><strong>（2）Unaligned
Transfer</strong></h5>
<p>AXI
协议支持地址非对齐的传输，允许突发传输的首字节地址，即起始地址与<strong>突发传输位宽</strong>不对齐。举个例子，总线位宽为
32bit 时，如果起始地址为 0x1002 ，则产生了非对齐现象。与 32bit
位宽总线对齐的地址需要能被 4 整除，即 ADDR[1:0] = 2'b0。</p>
<p><strong>注意</strong>：此处对齐与否应该取决于突发传输的宽度，而不是总线位宽。</p>
<p>对于非对齐传输，主机会进行两项操作：</p>
<ul>
<li>即使起始地址非对齐，也保证<strong>所有传输是对齐</strong>的</li>
<li>在首个 transfer
中增加填充数据，<strong>将首次传输填充至对齐</strong>，填充数据使用
WSTRB 信号标记为无效</li>
</ul>
<p>我们通过几个例子来说明主机具体的工作：</p>
<figure>
<img src="总线.assets/v2-e8aa348f7fbc4a866e902d339175750f_1440w.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>起始地址为 0x1，非对齐，但主机通过添加一字节的填充数据将 transfer 1st
的实际地址调整为对齐的 0x0，并用 WSTRB 信号为 4'b1110
标识出最低字节上无效的填充数据。</p>
<p>在读传输中，从机也按照同样的原则，在读数据中填充无效数据实现对齐，由主机自行分离。</p>
<figure>
<img src="总线.assets/v2-6317343fab92defb85d0cad2117074ff_1440w.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>这个例子是窄传输+非对齐传输，但问题不大，我们根据之前的经验来看下。首先起始地址为不对齐的
0x07 ，所以首先将首个传输填充至与突发传输位宽 32 bit 对齐：0x07 mod
4(byte) = 3 byte</p>
<p>至此非对齐的问题就已经解决了。接下问题就简化为窄传输。32bit 数据在
64bit 总线上传输，根据我们上一节的分析，在 transfer 1st 中 再填充 4
个字节。后续的 transfer 中则遵从窄传输的原则即可。</p>
<h5 id="byte-invarience"><strong>（3）Byte Invarience</strong></h5>
<p>我们来讨论数据传输结构三个问题中的最后一个：混合的大小端模式。</p>
<p><strong>大端</strong>认为：<strong>高字节</strong>（MSB）应该存在<strong>低地址</strong>，而<strong>小端</strong>认为<strong>低字节</strong>（LSB）才应该存在<strong>低地址</strong>。</p>
<p>那么为了能够使大小端模式在存储中共存，AXI
协议设计了一种字节顺序恒定（Byte-invariant）的大小端传输方案。对于存储中包括多个字节的数据结构（单字节自然不存在大小端问题）：</p>
<ul>
<li>无论大小端模式，每个数据结构存储空间的分配方式是相同的</li>
<li>该数据结构按照其大小端模式决定字节存储的地址顺序</li>
<li>在传输过程中不考虑数据结构的大小端，按照字节原先存储的顺序，原样传输并存放至对端</li>
</ul>
<p>该模式的意义在传输双方均不对数据结构的大小端进行解析转换，而严格按照字节的存储顺序进行传输并转存，防止大小端共存产生<strong>数据覆盖</strong>。</p>
<h4 id="读写回复结构"><strong>读写回复结构</strong></h4>
<p>读写传输事务（Transaction）都存在 2bit 位宽的回复信号
RRESP/BRESP，分别存在 4 种回复情况，分别为</p>
<ul>
<li><p>OKAY ，常规访问成功</p></li>
<li><p>EXOKAY，独占访问成功</p></li>
<li><p>SLVERR，从机错误，尽管从机接收到了访问请求，但因为种种原因向主机返回了一个错误状态，AXI
传输事务的回复由应用具体决定，可能包括以下错误场景：</p></li>
<li><ul>
<li>FIFO 或者缓冲区溢出</li>
<li>主机发起了不支持的传输位宽</li>
<li>尝试向读保护的地址写入数据</li>
<li>超时</li>
</ul></li>
<li><p>DECERR，解码错误，一般由 interconnect
组件产生，表示主机发送的传输事务地址无效，无法将传输事务发送给某个从机。</p></li>
</ul>
<p><strong>注意</strong>：在写传输事务中，单个写回复针对的是整个
burst，而不是 burst 中单个
transfer。但是在读传输事务中，从机可以为突发传输中每一个读传输数据产生不同的读回复信号。</p>
<h3 id="事务类型与属性">事务类型与属性</h3>
<p>AXI 协议中定义了一组信号表示读写传输事务的类型，分别为 ARCACHE 以及
AWCACHE，合称为 AXCACHE。两者控制了</p>
<ul>
<li>传输事务在整个系统中如何进行（How a transaction progresses through
the system）</li>
<li>系统缓存对传输事务的操作（How any system-level caches handle the
transaction）</li>
</ul>
<p>AXI 协议中存在两类从机：存储从机（Memory
Slave）与外设从机（Peripheral Slave）。</p>
<p>我们协议中传输事务属性主要是为存储从机准备，<strong>存储从机必须支持所有的事务属性信号</strong>。而对于外设从机，支持哪些属性信号，就看着办了，协议只有一个要求：外设从机必须完成整个传输事务，哪怕存在其不支持的某个事务属性信号。</p>
<p>外设从机对于属性信号的支持以及相应的访问方式由具体实现决定，一般设计者会将支持的方式列于该从机的规格书中，从机也只对所支持访问方式进行正确响应。极端情况下，从机接收到一个不支持的访问方式，这是可以的。但是一定要完成这次的传输事务，以防止整个系统死锁。协议也不要求从机支持复活机制。（continued
correct operation is <strong>not required</strong>）</p>
<h4 id="系统级缓存">系统级缓存</h4>
<p><strong>注意：AXI
协议缓存相关机制是针对处理器的系统级缓存的一种实现</strong></p>
<p>所谓系统级缓存（system level
cache）区别于处理器内部的缓存，系统级缓存提高整个系统访问外部存储的速度。当系统级缓存连接在处理器核与外部存储之间时，可以被看做处理器核外部的
L2 缓存，如下图所示</p>
<figure>
<img src="总线.assets/v2-eb053295f403d5230c57f64f63f1e228_1440w.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>处理器核、系统缓存以及外部存储控制器通过 AXI 总线接口互联。L1
缓存位于处理器核内部。当处理器访问外部存储中的数据，在 L1
缓存中缺失时，向外部缓存发起传输事务。传输事务在通过系统缓存时，如果该事务命中缓存表项，即可直接得到结果，避免访问外部存储带来的缺失代价。</p>
<h4 id="存储相关属性信号">存储相关属性信号</h4>
<h2 id="axi-vip">AXI VIP</h2>
<p>AXI Verification IP (AXI VIP) 是支持用户对 AXI4 和 AXI4-Lite
进行仿真的 IP。它还可作为 AXI Protocol Checker 来使用。</p>
<p>此IP只是仿真IP，将不进行综合（它将在Pass-through配置中被连线所替代）。</p>
<p>AXI VIP IP 核用途如下：</p>
<ul>
<li><p>生成 Master AXI 指令和写内容</p></li>
<li><p>生成 Slave AXI 读内容和写响应</p></li>
<li><p>检查 AXI 传输是否符合协议标准</p></li>
</ul>
<p>它支持 5 种不同配置：</p>
<ul>
<li><p>AXI Master VIP</p></li>
<li><p>AXI Pass-through VIP（无/有内存模型）</p></li>
<li><p>AXI Slave VIP（无/有内存模型）</p></li>
</ul>
<h1 id="soc-simulator">SoC Simulator</h1>
<p>一个简单易用的软件定义AXI Slave设备框架</p>

    </div>

    
    
    
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/AXI/" rel="tag"># AXI</a>
              <a href="/tags/PCle/" rel="tag"># PCle</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/19/Makefile/" rel="prev" title="Makefile学习笔记">
      <i class="fa fa-chevron-left"></i> Makefile学习笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/11/26/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7/" rel="next" title="高速缓存与一致性">
      高速缓存与一致性 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>
      
      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%80%BB%E7%BA%BF"><span class="nav-text">什么是总线？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#axi%E6%80%BB%E7%BA%BF"><span class="nav-text">AXI总线</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#validready-%E6%8F%A1%E6%89%8B%E6%9C%BA%E5%88%B6"><span class="nav-text">VALID&#x2F;READY 握手机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#axi4-lite"><span class="nav-text">AXI4-Lite</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#axi4"><span class="nav-text">AXI4</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#araw%E9%80%9A%E9%81%93"><span class="nav-text">AR&#x2F;AW通道：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#r%E9%80%9A%E9%81%93"><span class="nav-text">R通道：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#w%E9%80%9A%E9%81%93"><span class="nav-text">W通道：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b%E9%80%9A%E9%81%93"><span class="nav-text">B通道：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#burst%E7%B1%BB%E5%9E%8B"><span class="nav-text">Burst类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#narrow-burst"><span class="nav-text">Narrow Burst</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#axi4%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">AXI4注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E4%BC%A0%E8%BE%93%E6%93%8D%E4%BD%9Cwrite-transcation"><span class="nav-text">写传输操作：Write transcation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E6%93%8D%E4%BD%9Cread-transcation"><span class="nav-text">读操作：Read transcation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%81%E5%8F%91%E4%BC%A0%E8%BE%93burst-transaction"><span class="nav-text">突发传输：Burst Transaction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E4%BA%8B%E5%8A%A1%E7%BB%93%E6%9E%84transaction-structure"><span class="nav-text">传输事务结构：Transaction
structure</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="nav-text">读写地址结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">读写数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#narrow-transfer"><span class="nav-text">（1）Narrow Transfer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#unaligned-transfer"><span class="nav-text">（2）Unaligned
Transfer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#byte-invarience"><span class="nav-text">（3）Byte Invarience</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E5%9B%9E%E5%A4%8D%E7%BB%93%E6%9E%84"><span class="nav-text">读写回复结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%B1%9E%E6%80%A7"><span class="nav-text">事务类型与属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-text">系统级缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7%E4%BF%A1%E5%8F%B7"><span class="nav-text">存储相关属性信号</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#axi-vip"><span class="nav-text">AXI VIP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#soc-simulator"><span class="nav-text">SoC Simulator</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zmaiLee"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">zmaiLee</p>
  <div class="site-description" itemprop="description">HUSTer19. ICdesign & Computer Architecture</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zmaiLee" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zmaiLee" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_45631071" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_45631071" rel="noopener" target="_blank"><i class="crosshairs fa-fw"></i>CSDN</a>
      </span>
  </div>



        <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=386538&auto=1&height=66"></iframe>
      </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">劢</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  
<div class="moon-menu">
  <div class="moon-menu-items">
    
    <div id="moon-menu-item-back2bottom" class="moon-menu-item">
      <i class='fas fa-chevron-down'></i>    </div>
    
    <div id="moon-menu-item-back2top" class="moon-menu-item">
      <i class='fas fa-chevron-up'></i>    </div>
    
  </div>
  <div class="moon-menu-button">
    <svg class="moon-menu-bg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle>
    </svg>
    <div class="moon-menu-content">
      <div class="moon-menu-icon"><i class='fas fa-ellipsis-v'></i></div>
      <div class="moon-menu-text"></div>
    </div>
  </div>
</div><script src="/js/injector.js"></script>
</body>
</html>
