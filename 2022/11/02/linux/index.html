<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zmailee.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1.添加环境变量 https:&#x2F;&#x2F;www.cnblogs.com&#x2F;youyoui&#x2F;p&#x2F;10680329.html 1、Linux的环境变量是保存在变量PATH中  export命令显示当前系统定义的所有环境变量 echo $PATH命令输出当前的PATH环境变量的值  2、Linux环境变量值之间是通过冒号分隔的( : ) 临时添加环境变量PATH：可通过export命令，如将&#x2F;u">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux学习笔记">
<meta property="og:url" content="https://zmailee.github.io/2022/11/02/linux/index.html">
<meta property="og:site_name" content="Mai&#39;s blog">
<meta property="og:description" content="1.添加环境变量 https:&#x2F;&#x2F;www.cnblogs.com&#x2F;youyoui&#x2F;p&#x2F;10680329.html 1、Linux的环境变量是保存在变量PATH中  export命令显示当前系统定义的所有环境变量 echo $PATH命令输出当前的PATH环境变量的值  2、Linux环境变量值之间是通过冒号分隔的( : ) 临时添加环境变量PATH：可通过export命令，如将&#x2F;u">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-11-02T07:11:43.295Z">
<meta property="article:modified_time" content="2022-11-23T06:40:18.545Z">
<meta property="article:author" content="zmaiLee">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zmailee.github.io/2022/11/02/linux/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" type="text/css" href="/css/injector/main.css" /><link rel="preload" as="style" href="/css/injector/light.css" /><link rel="preload" as="style" href="/css/injector/dark.css" />
  <title>Linux学习笔记 | Mai's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Mai's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
     <a href="https://zmailee.github.io" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Mai's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">try my best</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/zmaiLee" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zmailee.github.io/2022/11/02/linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="zmaiLee">
      <meta itemprop="description" content="HUSTer19. ICdesign & Computer Architecture">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mai's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux学习笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-02 15:11:43" itemprop="dateCreated datePublished" datetime="2022-11-02T15:11:43+08:00">2022-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-23 14:40:18" itemprop="dateModified" datetime="2022-11-23T14:40:18+08:00">2022-11-23</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="添加环境变量"><strong>1.添加环境变量</strong></h2>
<p>https://www.cnblogs.com/youyoui/p/10680329.html</p>
<p>1、Linux的环境变量是保存在变量PATH中</p>
<ul>
<li><strong>export</strong>命令显示当前系统定义的所有环境变量</li>
<li><strong>echo $PATH</strong>命令输出当前的PATH环境变量的值</li>
</ul>
<p>2、Linux环境变量值之间是通过冒号分隔的( : )</p>
<p><strong>临时添加环境变量PATH：</strong>可通过export命令，如将/usr/local/nginx/sbin/目录临时添加到环境变量中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=/usr/local/nginx/sbin/:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="常用命令">2.常用命令</h2>
<h3 id="开启全部权限解锁文件">开启全部权限：解锁文件</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chmod</span> -R 777 xx/xx/xx<br></code></pre></td></tr></table></figure>
<h3 id="tar命令">tar命令</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">解压命令:tar -xzvf xxx.tar.gz <br>压缩命令:tar zcvf 文件名.tar.gz 待压缩的文件名<br>//-x 表示 extract， 提取，因为是解压所以使用。<br>//-c 表示压缩，compress<br>//-z 表示先使用 gzip支持压缩或解压缩。其他的压缩或解压缩方式，比如-j表示bzip2的方式<br>//-v 表示 verbose，在压缩或解压缩过程中显示正在处理的文件名<br>//-f 表示 file，指定要处理的 tar 包<br>//-C 可以指定输出目录,默认是解压到当前目录<br>*.tar用tar -xvf解压<br>*.gz 用gzip -d或者gunzip解压<br>*.tar.gz和*.tgz用tar -xzf解压<br>*.bz2 用bzip2 -d或者用bunzip2解压<br>*.tar.bz2用tar -xjf解压<br>*.Z 用uncompress解压<br>*.tar.Z用tar -xZf解压<br>*.rar 用unrar e解压<br>*.zip用unzip解压<br></code></pre></td></tr></table></figure>
<h2 id="git">3.git</h2>
<p>When you want to commit the change, type</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit --allow-empty -am <span class="hljs-string">&quot;提交备注&quot;</span><br></code></pre></td></tr></table></figure>
<p>The <code>--allow-empty</code> option is necessary, because usually
the change is already committed by development tracing system. Without
this option, <code>git</code> will reject no-change commits</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 删除本地分支<br>git branch -d localBranchName<br><br>// 删除远程分支<br>git push origin --delete remoteBranchName<br></code></pre></td></tr></table></figure>
<h2 id="make">4.make</h2>
<p>通过<code>lscpu</code>命令来查询有多少个CPU.
在<code>make</code>时候添加<code>-j?</code>的参数,
其中<code>?</code>为你查询到的CPU数量.</p>
<p>为了查看编译加速的效果, 在编译的命令前面添加<code>time</code>命令,
它将会对紧跟在其后的命令的执行时间进行统计。可以通过<code>make clean</code>清除所有的编译结果,
然后重新编译并统计时间,</p>
<h2 id="gdb">5.GDB</h2>
<h3 id="常用命令-1">常用命令</h3>
<blockquote>
<ul>
<li>start #开始调试,停在第一行代码处,(gdb)start</li>
<li>finish #执行到函数retun返回</li>
<li>bt（backtrace） #列出调用栈</li>
<li>info locals #列出当前函数的局部变量</li>
<li>l #list的缩写查看源代码,(gdb) l [number/function]</li>
<li>watch var_name #追踪变量</li>
<li>b <lines> #b: Breakpoint的简写，<strong>设置断点</strong>。(gdb) b
10</li>
<li>b <func> #b: Breakpoint的简写，设置断点。(gdb) b main</li>
<li>b filename:[line/function]
#b:在文件filename的某行或某个函数处设置断点</li>
<li>i breakpoints #i:info 的简写。(gdb)i breakpoints</li>
<li>d [bpNO] #d: Delete
breakpoint，删除指定编号的某个断点，或删除所有断点。(gdb)d 1</li>
<li>s #s:
step执行一行源程序代码，如果此行代码中有函数调用，<strong>则进入该函数</strong>；(gdb)
s</li>
<li>n #n:
next执行一行源程序代码，此行<strong>代码中的函数调用也一并执行</strong>。(gdb)
n</li>
<li>r
#run，运行被调试程序。如果没有下断点，则执行完；如果有断点，则程序暂停在第一个断点处。</li>
<li>c
#continue的简写，继续执行被调试程序，直至下一个断点或程序结束。</li>
<li>p [var]
#Print的简写，<strong>显示指定变量</strong>（临时变量或全局变量 例如 int
a）<strong>的值</strong>。(gdb) p a</li>
<li>display [var] #display，设置想要跟踪的变量(例如 int a)。(gdb)
display a</li>
<li>undisplay [varnum]
#undisplay取消对变量的跟踪，被跟踪变量用整型数标识。(gdb) undisplay
1</li>
<li>set args #可指定运行时参数。(gdb)set args 10 20</li>
<li>show args #查看运行时参数。</li>
<li>q #Quit的简写，退出GDB调试环境。(gdb) q</li>
<li>help [cmd]
#GDB帮助命令。如果指定“命令名称”参数，则显示该命令的详细说明；如果没有指定参数，则分类显示所有GDB命令(gdb)help</li>
<li>回车 #重复前面的命令，(gdb)回车</li>
</ul>
</blockquote>
<hr />
<h3 id="man命令">man命令</h3>
<table>
<colgroup>
<col style="width: 4%" />
<col style="width: 54%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="header">
<th>编号</th>
<th>说明</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Executable programs or shell commands</td>
<td><strong>标准Linux命令</strong></td>
</tr>
<tr class="even">
<td>2</td>
<td>System calls(functions provided by the kernel)</td>
<td><strong>系统调用（内核）</strong></td>
</tr>
<tr class="odd">
<td>3</td>
<td>Library functions(functions within program 1 ibraries)</td>
<td><strong>库函数</strong></td>
</tr>
<tr class="even">
<td>4</td>
<td>Special devices(usually found in /dev</td>
<td><strong>设备说明</strong>（通常在/dev下可以找到）</td>
</tr>
<tr class="odd">
<td>5</td>
<td>File formats and conventions eg /etc/ passwd</td>
<td><strong>文件格式</strong></td>
</tr>
<tr class="even">
<td>6</td>
<td>Games</td>
<td>游戏娱乐等</td>
</tr>
<tr class="odd">
<td>7</td>
<td>Miscellaneous</td>
<td>杂乱项</td>
</tr>
<tr class="even">
<td>8</td>
<td>System administration commands</td>
<td><strong>系统管理员命令</strong>（通常针对<strong>root</strong>用户）</td>
</tr>
<tr class="odd">
<td>9</td>
<td>Kernel routines</td>
<td>常规<strong>内核</strong>文件</td>
</tr>
</tbody>
</table>
<p>编号 说明 解释 1 Executable programs or shell commands 标准Linux命令
2 System calls 系统调用（内核） 3 Library functions 库函数 4 Special
devices 设备说明（通常在/dev下可以找到） 5 File formats 文件格式 6 Games
游戏娱乐等 7 Miscellaneous 杂乱项 8 System administration commands
系统管理员命令（通常针对root用户） 9 Kernel routines 常规内核文件</p>
<h3 id="list命令">list命令</h3>
<blockquote>
<p>list，显示当前行后面的源程序。</p>
<p>list - ，显示当前行前面的源程序</p>
<p>list <linenum> ，显示程序第linenum行周围的源程序</p>
<p>list <function> ，显示函数名为function的函数的源程序</p>
</blockquote>
<h3 id="break命令">break命令</h3>
<ul>
<li><p>break <function>在进入指定函数时停住</p></li>
<li><p>break <linenum>在指定行号停住</p></li>
<li><p>break +offset / break
-offset在当前行号的前面或后面的offset行停住</p></li>
<li><p>break filename:linenum在源文件filename的linenum行处停住</p></li>
<li><p>break
filename:function在源文件filename的function函数的入口处停住</p></li>
<li><p>break *address在程序运行的内存地址处停住</p></li>
<li><p>break表示在下一条指令处停住</p></li>
<li><p>break ... if <condition>“...”可以是上述的break <linenum>、break
+offset / break –offset中的参数，在循环体中，可以设置break if
i=100，表示当i为100时停住程序</p></li>
<li><p>查看断点时，可使用info命令，如info breakpoints n、info break
n（n表示断点号）</p></li>
</ul>
<h3 id="单步命令">单步命令</h3>
<p>next(n)的单步不会进入函数的内部，</p>
<p>step(s)命令则在单步执行一个函数时，会进入其内部</p>
<ul>
<li>step <count></li>
</ul>
<p>单步跟踪，如果有函数调用，则进入该函数（进入函数的前提是，此函数被编译有debug信息）。step后面不加count表示一条条地执行，加表示执行后面的count条指令，然后再停住。</p>
<ul>
<li>next <count></li>
</ul>
<p>单步跟踪，如果有函数调用，它不会进入该函数。同样地，next后面不加count表示一条条地执行，加表示执行后面的count条指令，然后再停住。</p>
<ul>
<li>set step-mode</li>
</ul>
<p>set step-mode
on用于打开step-mode模式，这样，在进行单步跟踪时，程序不会因为没有debug信息而不停住，这个参数的设置可便于查看机器码。set
step-mod off用于关闭step-mode模式。</p>
<ul>
<li>finish</li>
</ul>
<p>运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。</p>
<ul>
<li>until （缩写u）</li>
</ul>
<p>一直在循环体内执行单步，退不出来是一件令人烦恼的事情，until命令可以运行程序直到退出循环体。</p>
<ul>
<li>stepi（缩写si）和nexti（缩写ni）</li>
</ul>
<p>stepi和nexti用于单步跟踪一条机器指令，一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步执行机器指令。
另外，运行“display/i
$pc”命令后，单步跟踪会在打出程序代码的同时打出机器指令，即汇编代码。</p>
<h3 id="continue命令">continue命令</h3>
<p>当程序被停住后，可以使用continue命令（缩写c，fg命令同continue命令）恢复程序的运行直到程序结束，或到达下一个断点，命令格式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">continue</span> [ignore-count]<br>c [ignore-count]<br>fg [ignore-count]<br></code></pre></td></tr></table></figure>
<p>ignore-count表示忽略其后多少次断点。
假设我们设置了函数断点add()，并watch
i，则在continue过程中，每次遇到add()函数或i发生变化，程序就会停住，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) <span class="hljs-keyword">continue</span><br>Continuing.<br>Hardware watchpoint <span class="hljs-number">3</span>: i<br><br>Old value = <span class="hljs-number">2</span><br>New value = <span class="hljs-number">3</span><br><span class="hljs-number">0x0804838d</span> in <span class="hljs-built_in">main</span> () at gdb_example.c:<span class="hljs-number">23</span><br><span class="hljs-number">23</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>(gdb) <span class="hljs-keyword">continue</span><br>Continuing.<br><br>Breakpoint <span class="hljs-number">1</span>, <span class="hljs-built_in">main</span> () at gdb_example.c:<span class="hljs-number">25</span><br><span class="hljs-number">25</span>          sum[i] = <span class="hljs-built_in">add</span>(array1[i], array2[i]);<br>(gdb) <span class="hljs-keyword">continue</span><br>Continuing.<br>Hardware watchpoint <span class="hljs-number">3</span>: i<br><br>Old value = <span class="hljs-number">3</span><br>New value = <span class="hljs-number">4</span><br><span class="hljs-number">0x0804838d</span> in <span class="hljs-built_in">main</span> () at gdb_example.c:<span class="hljs-number">23</span><br><span class="hljs-number">23</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br></code></pre></td></tr></table></figure>
<h3 id="print命令">print命令</h3>
<p>在调试程序时，当程序被停住时，可以使用print命令（缩写为p），或是同义命令inspect来查看当前程序的运行数据。print命令的格式是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">print &lt;expr&gt;<br>print /&lt;f&gt; &lt;expr&gt;<br></code></pre></td></tr></table></figure>
<p><expr>是<a
target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=表达式&amp;spm=1001.2101.3001.7020">表达式</a>，是被调试的程序中的表达式，<f>是输出的格式，比如，如果要把表达式按16进制的格式输出，那么就是/x。在表达式中，有几种GDB所支持的操作符，它们可以用在任何一种语言中，“@”是一个和数组有关的操作符，“::”指定一个在文件或是函数中的变量，“{<type>}
<addr>”表示一个指向内存地址<addr>的类型为type的一个对象。</p>
<p>下面演示了查看sum[]数组的值的过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) print sum<br>$<span class="hljs-number">2</span> = &#123;<span class="hljs-number">133</span>, <span class="hljs-number">155</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;<br>(gdb) next<br><br>Breakpoint <span class="hljs-number">1</span>, <span class="hljs-built_in">main</span> () at gdb_example.c:<span class="hljs-number">25</span><br><span class="hljs-number">25</span>          sum[i] = <span class="hljs-built_in">add</span>(array1[i], array2[i]);<br>(gdb) next<br><span class="hljs-number">23</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>(gdb) print sum<br>$<span class="hljs-number">3</span> = &#123;<span class="hljs-number">133</span>, <span class="hljs-number">155</span>, <span class="hljs-number">143</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;<br></code></pre></td></tr></table></figure>
<p>当需要查看一段连续内存空间的值的时间，可以使用GDB的“@”操作符，“@”的左边是第一个内存地址，“@”的右边则是想查看内存的长度。例如如下动态申请的内存：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prettyprint">int *array = (int *) malloc (len * sizeof (int)); *array = (int *) malloc (len * sizeof (int));<br></code></pre></td></tr></table></figure>
<p>在GDB调试过程中这样显示出这个动态数组的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prettyprint">p *array@len*array@len<br></code></pre></td></tr></table></figure>
<p>print的输出格式包括：</p>
<ul>
<li>x 按十六进制格式显示变量。</li>
<li>d 按十进制格式显示变量。</li>
<li>u 按十六进制格式显示无符号整型。</li>
<li>o 按八进制格式显示变量。</li>
<li>t 按二进制格式显示变量。</li>
<li>a 按十六进制格式显示变量。</li>
<li>c 按字符格式显示变量。</li>
<li>f 按浮点数格式显示变量。</li>
</ul>
<p>我们可用display命令设置一些自动显示的变量，当程序停住时，或是单步跟踪时，这些变量会自动显示。
如果要修改变量，如x的值，可使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prettyprint">print x=4 x=4<br></code></pre></td></tr></table></figure>
<p>当用GDB的print查看程序运行时的数据时，每一个print都会被GDB记录下来。GDB会以$1，$2，$3
…这样的方式为每一个print命令编号。我们可以使用这个编号访问以前的表达式，如$1。</p>
<h3 id="watch命令">watch命令</h3>
<p>watch一般来观察某个表达式（变量也是一种表达式）的值是否有变化了，如果有变化，马上停住程序。我们有下面的几种方法来设置观察点：
watch
<expr>：为表达式（变量）expr设置一个观察点。一量表达式值有变化时，马上停住程序。rwatch
<expr>：当表达式（变量）expr被读时，停住程序。awatch
<expr>：当表达式（变量）的值被读或被写时，停住程序。info
watchpoints：列出当前所设置了的所有观察点。
下面演示了观察i并在连续运行next时一旦发现i变化，i值就会显示出来的过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) watch i<br>Hardware watchpoint <span class="hljs-number">3</span>: <span class="hljs-built_in">i</span><br>(gdb) next<br><span class="hljs-number">23</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>(gdb) next<br>Hardware watchpoint <span class="hljs-number">3</span>: i<br><br>Old value = <span class="hljs-number">0</span><br>New value = <span class="hljs-number">1</span><br><span class="hljs-number">0x0804838d</span> in <span class="hljs-built_in">main</span> () at gdb_example.c:<span class="hljs-number">23</span><br><span class="hljs-number">23</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>(gdb) next<br><br>Breakpoint <span class="hljs-number">1</span>, <span class="hljs-built_in">main</span> () at gdb_example.c:<span class="hljs-number">25</span><br><span class="hljs-number">25</span>          sum[i] = <span class="hljs-built_in">add</span>(array1[i], array2[i]);<br>(gdb) next<br><span class="hljs-number">23</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>(gdb) next<br>Hardware watchpoint <span class="hljs-number">3</span>: i<br><br>Old value = <span class="hljs-number">1</span><br>New value = <span class="hljs-number">2</span><br><span class="hljs-number">0x0804838d</span> in <span class="hljs-built_in">main</span> () at gdb_example.c:<span class="hljs-number">23</span><br><span class="hljs-number">23</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br></code></pre></td></tr></table></figure>
<h3 id="examine命令">examine命令</h3>
<p>我们可以使用examine命令（缩写为x）来查看内存地址中的值。examine命令的语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prettyprint">x/&lt;n/f/u&gt; &lt;addr&gt; /&lt;n/f/u&gt; &lt;addr&gt; <br></code></pre></td></tr></table></figure>
<p><addr>表示一个内存地址。“x/”后的n、f、u都是可选的参数，n
是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容；f
表示显示的格式，如果地址所指的是字符串，那么格式可以是s，如果地址是指令地址，那么格式可以是i；u
表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4字节。u参数可以被一些字符代替：b表示单字节，h表示双字节，w表示四字节，g表示八字节。当我们指定了字节长度后，GDB会从指定的内存地址开始，读写指定字节，并把其当作一个值取出来。n、f、u这3个参数可以一起使用，例如命令“x/3uh
0x54320”表示从内存地址0x54320开始以双字节为1个单位（h）、16进制方式（u）显示3个单位（3）的内存。
==</p>
<p>譬如下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">main</span>()<br>&#123;<br>        <span class="hljs-type">char</span> *c = <span class="hljs-string">&quot;hello world&quot;</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, c);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们在</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> *c = <span class="hljs-string">&quot;hello world&quot;</span>;<br></code></pre></td></tr></table></figure>
<p>下一行设置断点后：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) l<br><span class="hljs-number">1</span>    <span class="hljs-built_in">main</span>()<br><span class="hljs-number">2</span>    &#123;<br><span class="hljs-number">3</span>        <span class="hljs-type">char</span> *c = <span class="hljs-string">&quot;hello world&quot;</span>;<br><span class="hljs-number">4</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, c);<br><span class="hljs-number">5</span>    &#125;<br>(gdb) b <span class="hljs-number">4</span><br>Breakpoint <span class="hljs-number">1</span> at <span class="hljs-number">0x100000f17</span>: file main.c, line <span class="hljs-number">4.</span><br>(gdb) r<br>Starting program: /Users/songbarry/main<br>Reading symbols <span class="hljs-keyword">for</span> shared libraries +. done<br><br>Breakpoint <span class="hljs-number">1</span>, <span class="hljs-built_in">main</span> () at main.c:<span class="hljs-number">4</span><br><span class="hljs-number">4</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, c);<br></code></pre></td></tr></table></figure>
<p>可以通过多种方式看C指向的字符串：</p>
<p>方法1：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) p c<br>$<span class="hljs-number">1</span> = <span class="hljs-number">0x100000f2e</span> <span class="hljs-string">&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure>
<p>方法2：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) x/s <span class="hljs-number">0x100000f2e</span><br><span class="hljs-number">0x100000f2e</span>:	 <span class="hljs-string">&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure>
<p>方法3：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) <span class="hljs-built_in">p</span> (<span class="hljs-type">char</span> *)<span class="hljs-number">0x100000f2e</span><br>$<span class="hljs-number">3</span> = <span class="hljs-number">0x100000f2e</span> <span class="hljs-string">&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure>
<p>将第一个字符改为大写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) p *(<span class="hljs-type">char</span> *)<span class="hljs-number">0x100000f2e</span>=<span class="hljs-string">&#x27;H&#x27;</span><br>$<span class="hljs-number">4</span> = <span class="hljs-number">72</span> <span class="hljs-string">&#x27;H&#x27;</span><br></code></pre></td></tr></table></figure>
<p>再看看C：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) p c<br>$<span class="hljs-number">5</span> = <span class="hljs-number">0x100000f2e</span> <span class="hljs-string">&quot;Hello world&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="set命令">set命令</h3>
<p>修改寄存器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) set $v0 = <span class="hljs-number">0x004000000</span><br>(gdb) set $epc = <span class="hljs-number">0xbfc00000</span> <br></code></pre></td></tr></table></figure>
<p>修改内存：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) set &#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&#125;<span class="hljs-number">0x8048a51</span>=<span class="hljs-number">0x0</span><br></code></pre></td></tr></table></figure>
<p>譬如对于第8节的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) set &#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&#125;<span class="hljs-number">0x100000f2e</span>=<span class="hljs-number">0x0</span>       <br>(gdb) x/<span class="hljs-number">10</span>cb <span class="hljs-number">0x100000f2e</span><br><span class="hljs-number">0x100000f2e</span>:	<span class="hljs-number">0</span> <span class="hljs-string">&#x27;\0&#x27;</span>	<span class="hljs-number">0</span> <span class="hljs-string">&#x27;\0&#x27;</span>	<span class="hljs-number">0</span> <span class="hljs-string">&#x27;\0&#x27;</span>	<span class="hljs-number">0</span> <span class="hljs-string">&#x27;\0&#x27;</span>	<span class="hljs-number">111</span> <span class="hljs-string">&#x27;o&#x27;</span>	<span class="hljs-number">32</span> <span class="hljs-string">&#x27; &#x27;</span>	<span class="hljs-number">119</span> <span class="hljs-string">&#x27;w&#x27;</span>	<span class="hljs-number">111</span> <span class="hljs-string">&#x27;o&#x27;</span><br><span class="hljs-number">0x100000f36</span>:	<span class="hljs-number">114</span> <span class="hljs-string">&#x27;r&#x27;</span>	<span class="hljs-number">108</span> <span class="hljs-string">&#x27;l&#x27;</span><br>(gdb) p c<br>$<span class="hljs-number">10</span> = <span class="hljs-number">0x100000f2e</span> <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="jump命令">jump命令</h3>
一般来说，被调试程序会按照程序代码的运行顺序依次执行，但是GDB也提供了乱序执行的功能，也就是说，GDB可以修改程序的执行顺序，从而让程序随意跳跃。这个功能可以由GDB的jump命令：jump
<linespec>
来指定下一条语句的运行点。<linespec>可以是文件的行号，可以是file:line格式，也可以是+num这种偏移量格式，表示下一条运行语句从哪里开始。jump
<address>
这里的
<address>
<p>是代码行的内存地址。
注意，jump命令不会改变当前的程序栈中的内容，所以，如果使用jump从一个函数跳转到另一个函数，当跳转到的函数运行完返回，进行出栈操作时必然会发生错误，这可能导致意想不到的结果，所以最好只用jump在同一个函数中进行跳转。</p>
<h3 id="signal命令">signal命令</h3>
<p>使用singal命令，可以产生一个信号量给被调试的程序，如中断信号“Ctrl+C”。这非常方便于程序的调试，可以在程序运行的任意位置设置断点，并在该断点用GDB产生一个信号量，这种精确地在某处产生信号的方法非常有利于程序的调试。
signal命令的语法是：signal <signal>，<a
target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=UNIX&amp;spm=1001.2101.3001.7020">UNIX</a>的系统信号量通常从1到15，所以<signal>取值也在这个范围。</p>
<h3 id="return命令">return命令</h3>
<p>如果在函数中设置了调试断点，在断点后还有语句没有执行完，这时候我们可以使用return命令强制函数忽略还没有执行的语句并返回。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">return</span><br><span class="hljs-keyword">return</span> &lt;expression&gt;<br></code></pre></td></tr></table></figure>
<p>上述return命令用于取消当前函数的执行，并立即返回，如果指定了<expression>，那么该表达式的值会被作为函数的返回值。</p>
<h3 id="call命令">call命令</h3>
<p>call命令用于强制调用某函数： call <expr>
表达式中可以一是函数，以此达到强制调用函数的目的，它会显示函数的返回值（如果函数返回值不是void）。
其实，前面介绍的print命令也可以完成强制调用函数的功能。</p>
<h3 id="info命令">info命令</h3>
<p>info命令可以在调试时用来查看寄存器、断点、观察点和信号等信息。要查看寄存器的值，可以使用如下命令：
info registers （查看除了浮点寄存器以外的寄存器）info all-registers
（查看所有寄存器，包括浮点寄存器）info registers &lt;regname ...&gt;
（查看所指定的寄存器） 要查看断点信息，可以使用如下命令：info break
列出当前所设置的所有观察点，使用如下命令：info watchpoints
查看有哪些信号正在被GDB检测，使用如下命令：info signals info handle
也可以使用info line命令来查看源代码在内存中的地址。info
threads可以看多线程。info
line后面可以跟行号、函数名、文件名:行号、文件名:函数名等多种形式，例如下面的命令会打印出所指定的源码在运行时的内存地址：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">info line tst.c:func<br></code></pre></td></tr></table></figure>
<h3 id="set-scheduler-locking-offonstep">set scheduler-locking
off|on|step</h3>
<p>off 不锁定任何线程，也就是所有线程都执行，这是默认值。 on
只有当前被调试程序会执行。 step
在单步的时候，除了next过一个函数的情况以外，只有当前线程会执行。</p>
<p>与多线程调试相关的命令还包括：</p>
<p>thread ID 切换当前调试的线程为指定ID的线程。</p>
<p>break thread_test.c:123 thread all 在所有线程中相应的行上设置断点</p>
<p>thread apply ID1 ID2 command
让一个或者多个线程执行GDB命令command。</p>
<p>thread apply all command 让所有被调试线程执行GDB命令command。</p>
<h3 id="disassemble">disassemble</h3>
<p>disassemble命令用于反汇编，它可被用来查看当前执行时的源代码的机器码，其实际上只是把目前内存中的指令dump出来。下面的示例用于查看函数func的汇编代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) disassemble func<br>Dump of assembler code <span class="hljs-keyword">for</span> function func:<br><span class="hljs-number">0x8048450</span> &lt;func&gt;:       push   %ebp<br><span class="hljs-number">0x8048451</span> &lt;func+<span class="hljs-number">1</span>&gt;:     mov    %esp,%ebp<br><span class="hljs-number">0x8048453</span> &lt;func+<span class="hljs-number">3</span>&gt;:     sub    $<span class="hljs-number">0x18</span>,%esp<br><span class="hljs-number">0x8048456</span> &lt;func+<span class="hljs-number">6</span>&gt;:     movl   $<span class="hljs-number">0x0</span>,<span class="hljs-number">0xfffffffc</span>(%ebp)<br>...<br>End of assembler dump.<br></code></pre></td></tr></table></figure>
<h2 id="gcc">6.gcc</h2>
<h3 id="优化等级">优化等级</h3>
<p>gcc中指定优化级别的参数有：-O0、-O1、-O2、-O3、-Og、-Os、-Ofast。在编译时，如果没有指定优化参数，则默认为
-O0</p>
<p>-O1、-O2、-O3
中，随着数字变大，代码的优化程度也越高，不过这在某种意义上来说，也是以牺牲程序的可调试性为代价的。</p>
<p>-Og 是在 -O1
的基础上，去掉了那些影响调试的优化，所以如果最终是为了调试程序，可以使用这个参数。不过光有这个参数也是不行的，这个参数只是告诉编译器，编译后的代码不要影响调试，但调试信息的生成还是靠
-g 参数的。</p>
<p>参数 -Os 是在 -O2
的基础上，去掉了那些会导致最终可执行程序增大的优化，如果想要更小的可执行程序，可选择这个参数。</p>
<p>参数 -Ofast 是在 -O3
的基础上，添加了一些非常规优化，这些优化是通过打破一些国际标准（比如一些数学函数的实现标准）来实现的，所以一般不推荐使用该参数。</p>
<h3 id="编译链接命令">编译链接命令</h3>
<p>在使用 GCC 编译程序时，编译过程可以被细分为四个阶段：</p>
<p>1）<strong>预处理</strong>（ Pre-Processing
）阶段：主要对包含的头文件（＃include ）和宏定义（＃define,#ifdef …
）进行处理。可以使用“gcc -E” 让gcc 在预处理之后停止编译过程，生成 *.i
文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -E hello.c -o hello.i<br></code></pre></td></tr></table></figure>
<p>2）<strong>编译</strong>（ Compiling ）阶段：gcc
首先要检查代码的规范性，是否有语法错误等。以确定代码实际要做的工作，在检查无误后，gcc
把代码翻译成汇编语言。用户可以使用-S
选项进行查看，该选项只进行编译而不进行汇编，生成汇编代码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -S hello.i -o hello.s<br></code></pre></td></tr></table></figure>
<p>3） <strong>汇编</strong>（ Asse mbling ）阶段：生成目标代码 <em>.o
；有两种方式：使用 gcc 直接从源代码生成目标代码 gcc -c </em>.s -o <em>.o
以及使用汇编器从汇编代码生成目标代码 as </em>.s -o *.o</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -c hello.s -o hello.o<br>as hello.s -o hello.o<br></code></pre></td></tr></table></figure>
<p>也可以直接使用as <em>.s,
将<strong>执行汇编、链接过程生成可执行文件a.out</strong>,
可以像上面使用<strong>-o 选项</strong>指定输出文件的格式。
4）<strong>链接</strong>（ Linking
）阶段：生成可执行文件；可以生成的可执行文件格式有：
a.out/</em>/,当然可能还有其它格式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc hello.o     生成可执行文件 a.out<br>gcc hello.o -o hello        生成可执行文件 hello<br></code></pre></td></tr></table></figure>
<p><strong>gcc 常用编译选项：</strong></p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-c</td>
<td>只编译不链接，生成目标文件<code>.o</code></td>
</tr>
<tr class="even">
<td>-S</td>
<td>只编译不汇编，生成汇编代码</td>
</tr>
<tr class="odd">
<td>-E</td>
<td>只进行预编译</td>
</tr>
<tr class="even">
<td>-g</td>
<td>在可执行程序中包含标准调试信息</td>
</tr>
<tr class="odd">
<td>-o file</td>
<td>指定file文件作为输出文件</td>
</tr>
<tr class="even">
<td>-v</td>
<td>打印出编译器内部编译各过程的命令行信息和编译器的版本</td>
</tr>
<tr class="odd">
<td>-Idir</td>
<td>在头文件的搜索路径列表中添加dir目录</td>
</tr>
<tr class="even">
<td>-static</td>
<td>进行静态编译，只链接静态库，禁止使用动态库</td>
</tr>
<tr class="odd">
<td>-shared</td>
<td>进行动态编译，尽可能地链接动态库，没有动态库时才会链接同名静态库</td>
</tr>
<tr class="even">
<td>-L dir</td>
<td>在库文件的搜索路径列表中添加dir目录</td>
</tr>
<tr class="odd">
<td>-lname</td>
<td>链接libname.a或libname.so的库文件</td>
</tr>
<tr class="even">
<td>-fPIC</td>
<td>生成使用相对地址的位置无关目标代码（Position Independent Code）</td>
</tr>
</tbody>
</table>
<p>gcc
在链接时优先使用动态链接库，只有当动态链接库不存在时才考虑使用静态链接库，如果需要的话可以在编译时加上<strong>-static</strong>
选项，强制使用静态链接库。</p>
<h2 id="重定向">7.重定向</h2>
<h3 id="linux-21">Linux 2&gt;&amp;1</h3>
<p>2&gt;&amp;1的意思是将标准错误(2)也定向到标准输出(1)的输出文件中。</p>
<p>Linux
中三种标准输入输出，分别是STDIN，STDOUT，STDERR，对应的数字是0，1，2。</p>
<p>STDIN就是标准输入，默认从键盘读取信息；</p>
<p>STDOUT是标准输出，默认将输出结果输出至终端，也就是显示器之类的东西；</p>
<p>STDERR是标准的错误信息，默认也会显示在终端上。</p>
<p>由于STDOUT与STDERR都会默认显示在终端上，为了区分二者的信息，就有了编号的0，1，2的定义，用1表示STDOUT，2表示STDERR。</p>
<h3 id="从commanddevnull说起">从command&gt;/dev/null说起</h3>
<p>其实这条命令是一个缩写版，对于一个重定向命令，肯定是<code>a &gt; b</code>这种形式，那么<code>command &gt; /dev/null</code>难道是command充当a的角色，/dev/null充当b的角色。这样看起来比较合理，其实一条命令肯定是充当不了a，肯定是command执行产生的输出来充当a，其实就是标准输出stdout。所以<code>command &gt; /dev/null</code>相当于执行了<code>command 1 &gt; /dev/null</code>。执行command产生了标准输出stdout(用1表示)，重定向到/dev/null的设备文件中。</p>
<h3 id="说说21">说说2&gt;&amp;1</h3>
<p>通过上面<code>command &gt; /dev/null</code>等价于<code>command 1 &gt; /dev/null</code>,那么对于<code>2&gt;&amp;1</code>也就好理解了，2就是标准错误，1是标准输出，那么这条命令不就是相当于把标准错误重定向到标准输出么。等等是&amp;1而不是1，这里&amp;是什么？这里<code>&amp;</code>相当于<strong>等效于标准输出</strong>。这里有点不好理解，先看下面。</p>
<h3 id="commanda-2a-与-commanda-21的区别">command&gt;a 2&gt;a 与
command&gt;a 2&gt;&amp;1的区别</h3>
<p>通过上面的分析，对于<code>command&gt;a 2&gt;&amp;1</code>这条命令，等价于<code>command 1&gt;a 2&gt;&amp;1</code>可以理解为执行command产生的标准输入重定向到文件a中，标准错误也重定向到文件a中。那么是否就说<code>command 1&gt;a 2&gt;&amp;1</code>等价于<code>command 1&gt;a 2&gt;a</code>呢。其实不是，<code>command 1&gt;a 2&gt;&amp;1</code>与<code>command 1&gt;a 2&gt;a</code>还是有区别的，区别就在于前者只打开一次文件a，后者会打开文件两次，并导致stdout被stderr覆盖。<code>&amp;1</code>的含义就可以理解为用标准输出的引用，引用的就是重定向标准输出产生打开的a。从IO效率上来讲，<code>command 1&gt;a 2&gt;&amp;1</code>比<code>command 1&gt;a 2&gt;a</code>的效率更高</p>
<h3 id="再思考一下">再思考一下</h3>
<p>为什么2&gt;&amp;1 要放在后边呢？
我的理解是因为2（也就是错误输出）要重定向到&amp;1，也就是标准输出的引用中，也就是标准输出打开的文件中，所以需要现在前面打开1的输出文件。</p>
<h3 id="nohup及nohup.out">nohup及nohup.out</h3>
<p>如果使用nohup执行命令，配合&amp;的使用，则可以不挂断的将命令执行到后台，如果没有指定重定向文件，则输出将附加到当前目录的
nohup.out 文件中。如果当前目录的 nohup.out 文件不可写，输出重定向到
$HOME/nohup.out 文件中，实例如下：</p>
<p>nohup test.pl 2&gt;&amp;1 &amp;</p>
<p>在shell脚本中，默认情况下，总是有三个文件处于打开状态，标准输入(键盘输入)、标准输出（输出到屏幕）、标准错误（也是输出到屏幕），它们分别对应的<strong>文件描述符</strong>是0，1，2
。</p>
<p><strong>&gt; 默认为标准输出重定向，与 1&gt; 相同 2&gt;&amp;1</strong>
意思是把 标准错误输出 重定向到 标准输出.</p>
<p><strong>&amp;&gt;file</strong> 意思是把<strong>标准输出</strong> 和
<strong>标准错误输出</strong> 都重定向到文件file中</p>
<p><strong>/dev/null是一个文件，这个文件比较特殊，所有传给它的东西它都丢弃掉</strong></p>
<p><strong>举例说明:</strong></p>
<p>当前目录只有一个文件 a.txt. [root@redhat box]# ls a.txt [root@redhat
box]# ls a.txt b.txt ls: b.txt: No such file or directory
由于没有b.txt这个文件, 于是返回错误值, 这就是所谓的2输出 a.txt
而这个就是所谓的1输出</p>
<p><strong>再接着看:</strong></p>
<p>[root@redhat box]# ls a.txt b.txt 1&gt;<strong>file.out</strong>
2&gt;<strong>file.err</strong> 执行后,没有任何返回值. 原因是, 返回值都<a
target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=重定向&amp;spm=1001.2101.3001.7020">重定向</a>到相应的文件中了,而不再前端显示
[root@redhat box]# cat file.out a.txt [root@redhat box]# cat file.err
ls: b.txt: No such file or directory 一般来说, "1&gt;" 通常可以省略成
"&gt;". 即可以把如上命令写成: ls a.txt b.txt &gt;file.out 2&gt;file.err
有了这些认识才能理解 "1&gt;&amp;2" 和 "2&gt;&amp;1". <strong>1&gt;&amp;2
正确返回值传递给2输出通道 &amp;2表示2输出通道</strong> 如果此处错写成
1&gt;2, 就表示把1输出重定向到文件2中. <strong>2&gt;&amp;1
错误返回值传递给1输出通道, 同样&amp;1表示1输出通道.</strong> 举个例子.
[root@redhat box]# <strong>ls a.txt b.txt 1&gt;file.out
2&gt;&amp;1</strong> [root@redhat box]# cat file.out ls: b.txt: No such
file or directory a.txt 现在,
正确的输出和错误的输出都定向到了file.out这个文件中, 而不显示在前端.
补充下, 输出不只1和2, 还有其他的类型, 这两种只是最常用和最基本的.</p>
<p>例如： rm -f $(find / -name core) &amp;&gt;
/dev/null，<strong>/dev/null是一个文件，这个文件比较特殊，所有传给它的东西它都丢弃掉。</strong></p>
<p>例如： 注意，为了方便理解，必须设置一个环境使得执行grep da
<em>命令会有正常输出和错误输出，然后分别使用下面的命令生成三个文件：
grep da </em> &gt; greplog1 grep da * &gt; greplog2 1&gt;&amp;2<br />
grep da * &gt; greplog3 2&gt;&amp;1 //grep da * 2&gt; greplog4
1&gt;&amp;2 结果一样 #查看greplog1会发现里面只有正常输出内容
#查看greplog2会发现里面什么都没有#查看greplog3会发现里面既有正常输出内容又有错误输出内容</p>
<h2 id="grep命令">8. grep命令</h2>
<p><code>grep</code>命令是打印匹配文本行，其全称为 Global Search Regular
Expression and Print out the line；基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;code class=<span class="hljs-string">&quot;hljs css has-numbering&quot;</span>&gt;&lt;span class=<span class="hljs-string">&quot;hljs-tag&quot;</span>&gt;grep&lt;/span&gt; &lt;span class=<span class="hljs-string">&quot;hljs-attr_selector&quot;</span>&gt;[OPTIONS]&lt;/span&gt; &lt;span class=<span class="hljs-string">&quot;hljs-tag&quot;</span>&gt;PATTERN&lt;/span&gt; &lt;span class=<span class="hljs-string">&quot;hljs-attr_selector&quot;</span>&gt;[FILE...]&lt;/span&gt;<br>&lt;span class=<span class="hljs-string">&quot;hljs-tag&quot;</span>&gt;grep&lt;/span&gt; &lt;span class=<span class="hljs-string">&quot;hljs-attr_selector&quot;</span>&gt;[OPTIONS]&lt;/span&gt; &lt;span class=<span class="hljs-string">&quot;hljs-attr_selector&quot;</span>&gt;[-e PATTERN | -f FILE]&lt;/span&gt; &lt;span class=<span class="hljs-string">&quot;hljs-attr_selector&quot;</span>&gt;[FILE...]&lt;/span&gt;<br>&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<p>其中，<code>OPTIONS</code>表示选项；<code>PATTERN</code>表示匹配模式，匹配模式可以是字符串、变量、正则表达式，若匹配模式中含义空格，则需要使用双引号将匹配模式引起来；<code>FILE</code>表示一系列文件；<code>grep</code>命令从文件中搜索满足指定匹配模式的文本行，并打印出来。</p>
<p>正则表达式的分类为：</p>
<ul>
<li>基本正则表达式（Basic Regular Expression）：Basic RegEx，简称
<strong>BRE</strong></li>
<li>扩展正则表达式（Extended Regular Expression）：Extended RegEx，简称
<strong>ERE</strong></li>
<li>Perl 正则表达式（Perl Regular Expression）：Perl RegEx，简称
<strong>PCRE</strong>；</li>
</ul>
<p><code>grep</code>命令根据不同的参数支持不同的正则表达式：</p>
<ul>
<li><code>grep</code>命令后不跟任何参数（默认），则表示要使用“BRE”；</li>
<li><code>grep</code>命令后跟<code>-E</code>参数，则表示要使用“ERE”；</li>
<li><code>grep</code>命令后跟<code>-P</code>参数，则表示要使用“PCRE”；</li>
</ul>
<p>常用<code>OPTIONS</code>选项如下表所示：</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-E</td>
<td>指定 PATTERN 匹配模式为扩展正则表达式</td>
</tr>
<tr class="even">
<td>-F</td>
<td>指定 PATTERN 匹配模式为固定的字符串</td>
</tr>
<tr class="odd">
<td>-G</td>
<td>指定 PATTERN 匹配模式为基本正则表达式</td>
</tr>
<tr class="even">
<td>-P</td>
<td>指定 PATTERN 匹配模式为 Perl 正则表达式</td>
</tr>
<tr class="odd">
<td>-R</td>
<td>查找所有文件包含子目录</td>
</tr>
<tr class="even">
<td>-e PATTERN</td>
<td>指定 PATTERN 为一个或多个搜索模式</td>
</tr>
<tr class="odd">
<td>-f FILE</td>
<td>指定包含搜索模式的 FILE</td>
</tr>
<tr class="even">
<td><strong>-i</strong></td>
<td>匹配是忽略字母大小写</td>
</tr>
<tr class="odd">
<td><strong>-v</strong></td>
<td>显示所有与匹配模式不匹配的文本行（如grep -v "grep"或grep -v grep
意思是不显示包含grep符串的那一行）</td>
</tr>
<tr class="even">
<td>-w</td>
<td>执行单词搜索</td>
</tr>
<tr class="odd">
<td>-x</td>
<td>显示与指定模式精确匹配而不含其他字符的文本行</td>
</tr>
<tr class="even">
<td>-y</td>
<td>与选项 -i 相同功能</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
<tr class="even">
<td>-c</td>
<td>只打印匹配的文本行的行数，不显示匹配内容</td>
</tr>
<tr class="odd">
<td>-l</td>
<td>只显示匹配文本行的文件名，不显示匹配内容</td>
</tr>
<tr class="even">
<td><strong>-n</strong></td>
<td>列出所有匹配的文本行，并显示行号</td>
</tr>
<tr class="odd">
<td><strong>-r</strong></td>
<td>递归搜索目录(当前目录及其各级子目录)</td>
</tr>
<tr class="even">
<td>-s</td>
<td>不显示错误信息</td>
</tr>
</tbody>
</table>
<p>在当前目录下
查找"hello,world!"字符串<code>grep -rn "hello,world!" *</code> * :
表示当前目录所有文件，也可以是某个文件名</p>
<p>命令行参数：</p>
<p>grep -i pattern files ：不区分大小写地搜索。默认情况区分大小写，</p>
<p>grep -l pattern files ：只列出匹配的文件名，</p>
<p>grep -L pattern files ：列出不匹配的文件名，</p>
<p>grep -w pattern files
：只匹配整个单词，而不是字符串的一部分（如匹配‘magic’，而不是‘magical’），</p>
<p>grep -C number pattern files ：匹配的上下文分别显示[number]行，</p>
<p>grep pattern1 | pattern2 files ：显示匹配 pattern1 或 pattern2
的行，</p>
<p>grep pattern1 files | grep pattern2 ：显示既匹配 pattern1 又匹配
pattern2 的行。</p>
<p>&lt; 和 &gt; 分别标注单词的开始与结尾。</p>
<p>grep man * 会匹配 ‘Batman’、‘manic’、‘man’等，</p>
<p>grep '&lt;man' * 匹配‘manic’和‘man’，但不是‘Batman’，</p>
<p>grep '&lt;man&gt;'
只匹配‘man’，而不是‘Batman’或‘manic’等其他的字符串。</p>
<p>'^'：指匹配的字符串在行首，</p>
<p>'$'：指匹配的字符串在行尾，</p>
<h2 id="流编辑器-sed">9. 流编辑器 sed</h2>
<h3 id="sed命令">sed命令</h3>
<p>元字符集：<br />
<code>^</code>锚定行的开始 如：/^sed/匹配所有以sed开头的行。</p>
<p><code>$</code>锚定行的结束 如：/sed$/匹配所有以sed结尾的行。</p>
<p><code>.</code>匹配一个非换行符的字符
如：/s.d/匹配s后接一个任意字符，然后是d。</p>
<p><code>*</code>匹配零或多个字符
如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。</p>
<p><code>[]</code>匹配一个指定范围内的字符，如/[Ss]ed/匹配sed和Sed。</p>
<p><code>[^]</code>匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。</p>
<p>保存匹配的字符，如s/able/\1rs，loveable被替换成lovers。</p>
<p><code>&amp;</code>保存搜索字符用来替换其他字符，如s/love/<strong>&amp;</strong>/，love这成<strong>love</strong>。</p>
<p><code>\&lt;</code>锚定单词的开始，如:/&lt;love/匹配包含以love开头的单词的行。</p>
<p><code>\&gt;</code>锚定单词的结束，如/love&gt;/匹配包含以love结尾的单词的行。</p>
<p><code>x\&#123;m\&#125;</code>重复字符x，m次，如：/0{5}/匹配包含5个o的行。</p>
<p><code>x\&#123;m,\&#125;</code>重复字符x,至少m次，如：/o{5,}/匹配至少有5个o的行。</p>
<p><code>x\&#123;m,n\&#125;</code>重复字符x，至少m次，不多于n次，如：/o{5,10}/匹配5--10个o的行。</p>
<p>​ 先看几个实例：</p>
<p>删除：d命令</p>
<ul>
<li>$ sed '2d' example-----删除example文件的第二行。</li>
<li>$ sed '2,$d' example-----删除example文件的第二行到末尾所有行。</li>
<li>$ sed '$d' example-----删除example文件的最后一行。</li>
<li>$ sed '/test/'d example-----删除example文件所有包含test的行。</li>
</ul>
<p>替换：s命令</p>
<ul>
<li><p>$ sed 's/test/mytest/g'
example-----在整行范围内把test替换为mytest。如果没有g标记，则只有每行第一个匹配的test被替换成mytest。</p></li>
<li><p>$ sed -n 's/^test/mytest/p'
example-----(-n)选项和p标志一起使用表示只打印那些发生替换的行。也就是说，如果某一行开头的test被替换成mytest，就打印它。</p></li>
<li><p>$ sed 's/^192.168.0.1/&amp;localhost/'
example-----&amp;符号表示替换换字符串中被找到的部份。所有以192.168.0.1开头的行都会被替换成它自已加localhost，变成192.168.0.1localhost。</p></li>
<li><p>$ sed -n 's/able/\1rs/p'
example-----love被标记为1，所有loveable会被替换成lovers，而且替换的行会被打印出来。</p></li>
<li><p>$ sed 's#10#100#g'
example-----不论什么字符，紧跟着s命令的都被认为是新的分隔符，所以，“#”在这里是分隔符，代替了默认的“/”分隔符。表示把所有10替换成100。</p>
<p>选定行的范围：逗号</p></li>
<li><p>$ sed -n '/test/,/check/p'
example-----所有在模板test和check所确定的范围内的行都被打印。</p></li>
<li><p>$ sed -n '5,/^test/p'
example-----打印从第五行开始到第一个包含以test开始的行之间的所有行。</p></li>
<li><p>$ sed '/test/,/check/s/$/sed test/'
example-----对于模板test和west之间的行，每行的末尾用字符串sed
test替换。</p></li>
</ul>
<p>多点编辑：e命令</p>
<ul>
<li>$ sed -e '1,5d' -e 's/test/check/'
example-----(-e)选项允许在同一行里执行多条命令。如例子所示，第一条命令删除1至5行，第二条命令用check替换test。命令的执行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。</li>
<li>$ sed --expression='s/test/check/' --expression='/love/d'
example-----一个比-e更好的命令是--expression。它能给sed表达式赋值。</li>
</ul>
<p>从文件读入：r命令</p>
<ul>
<li>$ sed '/test/r file'
example-----file里的内容被读进来，显示在与test匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面。</li>
</ul>
<p>写入文件：w命令</p>
<ul>
<li>$ sed -n '/test/w file'
example-----在example中所有包含test的行都被写入file里。</li>
</ul>
<p>追加命令：a命令</p>
<ul>
<li>$ sed '/^test/a\---&gt;this is a example' example&lt;-----'this is a
example'被追加到以test开头的行后面，sed要求命令a后面有一个反斜杠。</li>
</ul>
<p>插入：i命令</p>
<p>$ sed '/test/i\</p>
<p>new line</p>
<p>-------------------------' example</p>
<p>如果test被匹配，则把反斜杠后面的文本插入到匹配行的前面。</p>
<p>下一个：n命令</p>
<ul>
<li>$ sed '/test/{ n; s/aa/bb/; }'
example-----如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb，并打印该行，然后继续。</li>
</ul>
<p>变形：y命令</p>
<ul>
<li>$ sed '1,10y/abcde/ABCDE/'
example-----把1--10行内所有abcde转变为大写，注意，正则表达式元字符不能使用这个命令。</li>
</ul>
<p>退出：q命令</p>
<ul>
<li>$ sed '10q' example-----打印完第10行后，退出sed。</li>
</ul>
<p>保持和获取：h命令和G命令</p>
<ul>
<li>$ sed -e '/test/h' -e '$G
example-----在sed处理文件的时候，每一行都被保存在一个叫模式空间的临时缓冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。在这个例子里，匹配test的行被找到后，将存入模式空间，h命令将其复制并存入一个称为保持缓存区的特殊缓冲区内。第二条语句的意思是，当到达最后一行后，G命令取出保持缓冲区的行，然后把它放回模式空间中，且追加到现在已经存在于模式空间中的行的末尾。在这个例子中就是追加到最后一行。简单来说，任何包含test的行都被复制并追加到该文件的末尾。</li>
</ul>
<p>保持和互换：h命令和x命令</p>
<ul>
<li>$ sed -e '/test/h' -e '/check/x' example
-----互换模式空间和保持缓冲区的内容。也就是把包含test与check的行互换。</li>
</ul>
<p><code>sed</code>命令从文件或者标准输入中一次读取一行数据，将该行数据复制到缓冲区，然后读取命令行或脚本的编辑子命令，对缓冲区中的文本行进行编辑。重复此工作，直到所有文本行都处理完毕。</p>
<p><code>sed</code>命令编辑的是文件是原始文件在缓冲区中的副本，并不影响原始文件，但是可以把编辑结果通过输出重定向保存起来。</p>
<p><code>sed</code>命令的基本语法如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;code class=<span class="hljs-string">&quot;hljs r has-numbering&quot;</span>&gt;sed [OPTION]&lt;span class=<span class="hljs-string">&quot;hljs-keyword&quot;</span>&gt;...&lt;/span&gt; &#123;script&#125; [input-file]&lt;span class=<span class="hljs-string">&quot;hljs-keyword&quot;</span>&gt;...&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<p>常用选项<code>OPTION</code>如下表所示：</p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>-n</strong></td>
<td>取消默认输出</td>
</tr>
<tr class="even">
<td>-e script</td>
<td>允许执行多个脚本</td>
</tr>
<tr class="odd">
<td><strong>-f script-file</strong></td>
<td><strong>从脚本文件中读取命令</strong></td>
</tr>
<tr class="even">
<td><strong>-i</strong></td>
<td><strong>直接修改原始文件</strong></td>
</tr>
<tr class="odd">
<td>-l N</td>
<td>指定行长度为 N</td>
</tr>
<tr class="even">
<td>-r</td>
<td>在脚本中使用扩展正则表达式</td>
</tr>
<tr class="odd">
<td>-s</td>
<td>把文件作为单独文件</td>
</tr>
<tr class="even">
<td>-u</td>
<td>最低限度的缓存输入与输出</td>
</tr>
</tbody>
</table>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">test2.sh<br><span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;code&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;python&quot;</span>&gt;</span>  asdafsadfasdfsa<br>  badfasdfas<br>  bdsdfsdfsdf<br>  csdfasdfasf<br></code></pre></td></tr></table></figure>
<p>test.sh #!/bin/bash</p>
<p>sed -ie '/^b/ s/b/bbbbbb/g' test2.sh</p>
<p>执行后test2.sh的结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">asdafsadfasdfsa<br>bbbbadfasdfas<br>bbbbdsdfsdfsdf<br>csdfasdfasf<br></code></pre></td></tr></table></figure>
<p><strong>如果不带-i，那么test2.sh中的内容不会发生变化，
发生变化的只是缓冲区中的内容。</strong></p>
<h3 id="文本行定位">文本行定位</h3>
<p><code>sed</code>命令提供了两种方式来实现文本行的定位：<strong>行号定位</strong>、<strong>正则表达式定位</strong></p>
<h3 id="行号定位"><strong>行号定位</strong></h3>
<ul>
<li>定位某个特定的行<strong><code>n</code></strong>：<code>n</code>是一个整数，表示定位到文本的第<code>n</code>行；</li>
<li>定位某段连续的行<strong><code>n,m</code></strong>：<code>n</code>和<code>m</code>都是整数，表示定位到起始行为<code>n</code>，终止行为<code>m</code>的文本行；</li>
<li>指定起始行和步长<strong><code>start~step</code></strong>：起始行为<code>start</code>，步长为<code>step</code>；</li>
<li>第一行<strong><code>1</code></strong>和最后一行<strong><code>$</code></strong>：<code>1</code>表示第一行，<code>$</code>表示最后一行；</li>
<li>指定某行后面的几行<strong><code>n,+x</code></strong>：表示从第<code>n</code>行开始到后面的<code>x</code>行；</li>
</ul>
<h3 id="正则表达式定位"><strong>正则表达式定位</strong></h3>
<p><code>sed</code>命令使用正则表达式定位文本行的语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs vala has-numbering&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;#regexp 表示正则表达式&lt;/span&gt;<br>/regexp/<br><br>如：/^b/ 表示行首为b<br>   /1,3/ 表示第1～3行<br>&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<h3 id="sed命令的常用操作">sed命令的常用操作</h3>
<p><code>sed</code>命令的常用编辑命令有：打印、删除、增加、替换；其基本语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs css has-numbering&quot;&gt;&lt;span class=&quot;hljs-attr_selector&quot;&gt;[address1[,address2]&lt;/span&gt;] &lt;span class=&quot;hljs-tag&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;hljs-attr_selector&quot;&gt;[argument]&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<p>其中<code>address</code>称为位置参数，即上面的行定位；<code>command</code>是<code>sed</code>所提供的子命令，用来实现编辑操作；<code>argument</code>表示子命令的选项参数；</p>
<h4 id="打印文本">1) 打印文本</h4>
<p><code>sed</code>命令中可通过位置参数和<strong><code>p</code></strong>命令打印所需要的文本行，其语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs css has-numbering&quot;&gt;&lt;span class=&quot;hljs-attr_selector&quot;&gt;[address1[,address2]&lt;/span&gt;] &lt;span class=&quot;hljs-tag&quot;&gt;p&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;&lt;span class=&quot;hljs-shebang&quot;&gt;#! /bin/bash<br>&lt;/span&gt;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#输出第1~4行文本，注意1,3p之间是单引号&lt;/span&gt;<br>sed -n &lt;span class=&quot;hljs-string&quot;&gt;&#x27;1,3p&#x27;&lt;/span&gt; test.txt<br><br>&lt;span class=&quot;hljs-comment&quot;&gt;#输出以Lin开头的文本行&lt;/span&gt;<br>result=`sed -n &lt;span class=&quot;hljs-string&quot;&gt;&#x27;/^Lin/ p&#x27;&lt;/span&gt; test.txt`<br>&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$result&lt;/span&gt;&quot;&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<h4 id="替换文本">2) 替换文本</h4>
<p><code>sed</code>命令中可通过位置参数和<code>s</code>子命令替换文本行，其语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs coffeescript has-numbering&quot;&gt;[address1[,address2]] s&lt;span class=&quot;hljs-regexp&quot;&gt;/pattern/replacemen/&lt;/span&gt;[flag]&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<p><code>flag</code>为替换标志，不同值会影响<code>s</code>子命令的行为；<code>flag</code>常用取值如下表所示：</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="header">
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>g</strong></td>
<td>全局匹配，会替换文本行所有符合规则的字符串</td>
</tr>
<tr class="even">
<td>p</td>
<td>替换第一个符合规则的字符串，并将缓冲区输出到标准输出</td>
</tr>
<tr class="odd">
<td>w</td>
<td>替换第一个符合规则的字符串，并将受影响的行输出到磁盘文件中</td>
</tr>
<tr class="even">
<td>十进制数n</td>
<td>替换文本行中第n个符合规则的字符串</td>
</tr>
<tr class="odd">
<td>空</td>
<td>若不指定flag值，替换文本行中第一个符合规则的字符串</td>
</tr>
</tbody>
</table>
<h4 id="删除文本">3) 删除文本</h4>
<p><code>sed</code>命令中可通过位置参数和<code>d</code>子命令删除文本行，其语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs css has-numbering&quot;&gt;&lt;span class=&quot;hljs-attr_selector&quot;&gt;[address1[,address2]&lt;/span&gt;] &lt;span class=&quot;hljs-tag&quot;&gt;d&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<h4 id="增加文本">4) 增加文本</h4>
<p><strong>追加文本</strong>
<code>sed</code>命令中可通过位置参数和<code>a</code>子命令追加文本行，其语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs vala has-numbering&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;#将string插入到address1位置后面&lt;/span&gt;<br>[address1] a &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt; &lt;/code&gt;<br></code></pre></td></tr></table></figure>
<h4 id="插入文本"><strong>5) 插入文本</strong></h4>
<p><code>sed</code>命令中可通过位置参数和<code>i</code>子命令插入文本行，其语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs vala has-numbering&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;#将string插入到address1位置前面&lt;/span&gt;<br>[address1] i &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<h4 id="组合命令">6) 组合命令</h4>
<p><code>sed</code>命令支持将多个子命令组合在一起使用；具体方式如下所示：</p>
<ul>
<li>使用<code>-e</code>选项：<code>-e</code>选项可以将多个子命令组合在一起使用；例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;&lt;span class=&quot;hljs-shebang&quot;&gt;#! /bin/bash<br>&lt;/span&gt;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#将全部小写字母 e 替换成大写字母 E，并打印第 1 行到第 3 行文本行&lt;/span&gt;<br>result=`sed -n &lt;span class=&quot;hljs-operator&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#x27;s/e/E/g&#x27;&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#x27;1,3 p&#x27;&lt;/span&gt; test.txt`<br>&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$result&lt;/span&gt;&quot;&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<ul>
<li>使用分号<code>;</code>执行多个子命令： 其语法格式：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;sed &lt;span class=&quot;hljs-operator&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#x27;command1; command2...&#x27;&lt;/span&gt; filename&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;&lt;span class=&quot;hljs-shebang&quot;&gt;#! /bin/bash<br>&lt;/span&gt;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#将全部小写字母 e 替换成大写字母 E，并打印第 1 行到第 3 行文本行&lt;/span&gt;<br>result=`sed -n &lt;span class=&quot;hljs-operator&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#x27;s/e/E/g; 1,3 p&#x27;&lt;/span&gt; test.txt`<br>&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$result&lt;/span&gt;&quot;&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<ul>
<li>对同一个地址使用多个子命令： 其语法格式：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs r has-numbering&quot;&gt;address&#123;<br>    command1<br>    command2<br>    command3<br>    &lt;span class=&quot;hljs-keyword&quot;&gt;...&lt;/span&gt;<br>&#125;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#或&lt;/span&gt;<br>[address] &#123; command1;command2;command3;&lt;span class=&quot;hljs-keyword&quot;&gt;...&lt;/span&gt;&#125;&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<h4 id="sed脚本文件">7)sed脚本文件</h4>
<p>可以将多个子命令写成后缀名为<code>.sed</code>的<code>sed</code>脚本文件，<code>sed</code>脚本文件内容只需将各个子命令依次列出来，不必使用引号，若将多个子命令写在同一行，则不同子命令之间需使用分号隔开。调用<code>sed</code>脚本文件的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;sed &lt;span class=&quot;hljs-operator&quot;&gt;-f&lt;/span&gt; script&lt;/code&gt;<br>&lt;pre&gt;<br><br></code></pre></td></tr></table></figure>
<h2 id="awk命令">10. awk命令</h2>
<h3 id="awk命令的基本语法">awk命令的基本语法</h3>
<p><code>awk</code>命令是一个文本处理工具，其基本语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs mathematica has-numbering&quot;&gt;awk pattern &lt;span class=&quot;hljs-list&quot;&gt;&#123; actions &#125;&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<p>其中，<code>pattern</code>表示匹配模式，<code>actions</code>表示要执行的操作；即对符合<code>pattern</code>匹配模式的文本行执行<code>actions</code>操作；若省略<code>pattern</code>匹配模式，则表示对所有文本行执行<code>actions</code>操作；若省略<code>pattern</code>
匹配模式，则把匹配成功的文本行打印输出；但是不能同时省略<code>pattern</code>和<code>actions</code>。</p>
<p><code>pattern</code>匹配模式可以是以下其中一种：</p>
<ul>
<li>正则表达式；</li>
<li>关系表达式；</li>
<li>模式<code>1</code>，模式<code>2</code>：指定一行的范围；</li>
<li><code>BEGIN</code>：指定在第一行文本被处理之前所发生的操作；</li>
<li><code>END</code>：指定在最后一行文本被读取之后发送的操作；</li>
</ul>
<p><code>actions</code>命令由一个或多个命令、函数或者表达式组成，他们之间由换行符或分号隔开，并位于大括号内，一般有以下四种情况：</p>
<ul>
<li>变量或数组赋值；</li>
<li>输出命令，例如<code>printf</code>或<code>print</code>；</li>
<li>内置函数；</li>
<li>流控制语句，例如<code>if</code>、<code>while</code>或<code>for</code>语句；</li>
</ul>
<p><code>awk</code>命令的执行方式：</p>
<ul>
<li>通过命令行执行：其语法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;awk &lt;span class=&quot;hljs-string&quot;&gt;&#x27;awk程序语句&#x27;&lt;/span&gt; 数据文件&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<ul>
<li>执行 <code>awk</code>脚本：其语法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;#注意：awk脚本文件是后缀名为.awk的文件&lt;/span&gt;<br>awk &lt;span class=&quot;hljs-operator&quot;&gt;-f&lt;/span&gt; awk脚本文件 数据文件&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<ul>
<li>可执行脚本文件：即在
<code>shell</code>文件中指定解析器为<code>#! /bin/awk -f</code></li>
</ul>
<h3 id="awk命令的匹配模式">awk命令的匹配模式</h3>
<p>在<code>awk</code>命令的匹配模式主要包括：关系表达式、正则表达式、混合模式、区间模式、<code>BEGIN</code>模式、<code>END</code>模式等。</p>
<h4 id="关系表达式"><strong>1) 关系表达式</strong></h4>
<p><code>awk</code>命令中的关系运算符如下表所示：</p>
<table>
<thead>
<tr class="header">
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&gt;</td>
<td>大于</td>
</tr>
<tr class="even">
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr class="odd">
<td>&lt;</td>
<td>小于</td>
</tr>
<tr class="even">
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr class="odd">
<td>==</td>
<td>等于</td>
</tr>
<tr class="even">
<td>!=</td>
<td>不等于</td>
</tr>
<tr class="odd">
<td>~</td>
<td>匹配运算：例如<code>$1~/^A</code>表示匹配第一个字段以字符<code>A</code>开头的记录</td>
</tr>
<tr class="even">
<td>!~</td>
<td>不匹配运算</td>
</tr>
</tbody>
</table>
<h4 id="正则表达式"><strong>2) 正则表达式</strong></h4>
<p><code>awk</code>支持以正则表达式为匹配模式，其基本语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs vala has-numbering&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;#regexp 表示正则表达式&lt;/span&gt;<br>/regexp/&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<p>例如：输出以字符u开头的文本行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;&lt;span class=&quot;hljs-shebang&quot;&gt;#! /bin/bash&lt;/span&gt;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#filename:test.sh&lt;/span&gt;<br><br>result=`awk &lt;span class=&quot;hljs-string&quot;&gt;&#x27;/^u/ &#123;print&#125;&#x27;&lt;/span&gt; shell.md`<br><br>&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$result&lt;/span&gt;&quot;&lt;/span&gt;<br><br>&lt;span class=&quot;hljs-comment&quot;&gt;#输出结果：&lt;/span&gt;<br>$ sh test.sh <br>&lt;span class=&quot;hljs-built_in&quot;&gt;unset&lt;/span&gt; variable_name<br>&lt;span class=&quot;hljs-built_in&quot;&gt;unset&lt;/span&gt; var<br>until<br>until<br>&lt;span class=&quot;hljs-built_in&quot;&gt;unset&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;-f&lt;/span&gt; 函数名&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<h4 id="混合模式"><strong>3) 混合模式</strong></h4>
<p>在<code>awk</code>命令的匹配模式中，可以通过逻辑运算符使用多个表达式组成命令；基本逻辑运算符如下表所示：</p>
<table>
<thead>
<tr class="header">
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&amp;&amp;</td>
<td>逻辑与</td>
</tr>
<tr class="even">
<td>||</td>
<td>逻辑或</td>
</tr>
<tr class="odd">
<td>!</td>
<td>逻辑非</td>
</tr>
</tbody>
</table>
<h4 id="区间模式"><strong>4) 区间模式</strong></h4>
<p><code>awk</code>命令支持区间模式，其语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs  has-numbering&quot;&gt;pattern1, pattern2&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<p>例如：第一个匹配模式是：以字符串<code>one</code>开头的文本行；第二个匹配模式是：第<code>3</code>字段等于<code>14</code>的文本行；所有符合这两个匹配模式之间的文本行都会被输出；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;&lt;span class=&quot;hljs-shebang&quot;&gt;#!/bin/bash&lt;/span&gt;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#filename:test.sh&lt;/span&gt;<br><br>result=`awk &lt;span class=&quot;hljs-string&quot;&gt;&#x27;/^one/ , $3==14 &#123;print&#125;&#x27;&lt;/span&gt; test.txt`<br><br>&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$result&lt;/span&gt;&quot;&lt;/span&gt;<br><br>&lt;span class=&quot;hljs-comment&quot;&gt;#执行结果：&lt;/span&gt;<br>$ sh test.sh <br>one     &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;<br>two     &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;25&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;<br>three   &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;31&lt;/span&gt;<br>four    &lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;26&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;35&lt;/span&gt;<br>five    &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;40&lt;/span&gt;<br>&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<h4 id="begin模式"><strong>5) BEGIN模式</strong></h4>
<p><code>BEGIN</code>模式是<code>awk</code>命令一种特殊的内置模式，在<code>awk</code>读取数据之前对执行的操作；</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs livecodeserver has-numbering&quot;&gt;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#! /usr/bin/awk -f&lt;/span&gt;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#filename:test.sh&lt;/span&gt;<br><br>BEGIN &#123; print &lt;span class=&quot;hljs-string&quot;&gt;&quot;Beging operator.&quot;&lt;/span&gt; &#125;<br>/^&lt;span class=&quot;hljs-constant&quot;&gt;one&lt;/span&gt;/ , $&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;==&lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt; &#123;print&#125;<br><br>&lt;span class=&quot;hljs-comment&quot;&gt;#执行结果：&lt;/span&gt;<br>$ ./test.sh test.txt<br>Beging operator.<br>&lt;span class=&quot;hljs-constant&quot;&gt;one&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;<br>&lt;span class=&quot;hljs-constant&quot;&gt;two&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;25&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;<br>&lt;span class=&quot;hljs-constant&quot;&gt;three&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;31&lt;/span&gt;<br>&lt;span class=&quot;hljs-constant&quot;&gt;four&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;26&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;35&lt;/span&gt;<br>&lt;span class=&quot;hljs-constant&quot;&gt;five&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;40&lt;/span&gt;<br>&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<h4 id="end模式"><strong>6) END模式</strong></h4>
<p><code>END</code>模式是在处理完数据之后执行的操作；例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs asciidoc has-numbering&quot;&gt;#! /usr/bin/awk -f<br># /usr/bin/env awk -f<br>#filename:test.sh<br><br>BEGIN &#123;<br>&lt;span class=&quot;hljs-code&quot;&gt;    print &quot;Beging operator.&quot;&lt;/span&gt;<br>&lt;span class=&quot;hljs-code&quot;&gt;    print &quot;====================&quot;&lt;/span&gt;<br>&#125;<br>/^one/ , $3==14 &#123;print&#125;<br><br>END &#123;<br>&lt;span class=&quot;hljs-code&quot;&gt;    print &quot;====================&quot;&lt;/span&gt;<br>&lt;span class=&quot;hljs-code&quot;&gt;    print &quot;Ending operator.&quot;&lt;/span&gt;<br>&#125;<br><br><br>#执行结果：<br>$ ./test.sh test.txt<br>&lt;span class=&quot;hljs-header&quot;&gt;Beging operator.<br>====================&lt;/span&gt;<br>one     10  20  30<br>two     15  25  20<br>three   20  15  31<br>four    16  26  35<br>&lt;span class=&quot;hljs-header&quot;&gt;five    11  14  40<br>====================&lt;/span&gt;<br>Ending operator.<br>&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<h3 id="awk-变量">awk 变量</h3>
<p><code>awk</code>中的用户自定义的变量一般在<code>BEGIN</code>模式中定义；</p>
<h4 id="系统内置变量">系统内置变量</h4>
<p><code>awk</code>的常用系统内置变量如下表所示：</p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="header">
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>$0</td>
<td>当前记录（存放着整个行的内容）</td>
</tr>
<tr class="even">
<td><span class="math inline">\(1~\)</span>n</td>
<td>当前记录的第n个字段，字段间由FS分隔</td>
</tr>
<tr class="odd">
<td>FS</td>
<td>输入字段分隔符 默认是空格或Tab</td>
</tr>
<tr class="even">
<td>NF</td>
<td>当前记录中的字段个数，就是有多少列</td>
</tr>
<tr class="odd">
<td>NR</td>
<td>已经读出的记录数，就是行号，从1开始，如果有多个文件话，这个值也是不断累加中</td>
</tr>
<tr class="even">
<td>FNR</td>
<td>当前记录数，与NR不同的是，这个值会是各个文件自己的行号</td>
</tr>
<tr class="odd">
<td>RS</td>
<td>输入的记录分隔符， 默认为换行符</td>
</tr>
<tr class="even">
<td>OFS</td>
<td>输出字段分隔符， 默认也是空格</td>
</tr>
<tr class="odd">
<td>ORS</td>
<td>输出的记录分隔符，默认为换行符</td>
</tr>
<tr class="even">
<td>FILENAME</td>
<td>当前输入文件的名字</td>
</tr>
</tbody>
</table>
<h4 id="运算符">运算符</h4>
<p><code>awk</code>命令支持常用的运算符：算术运算符、赋值运算符、条件运算符、逻辑运算法、关系运算符等操作；</p>
<p><strong>算术运算符</strong></p>
<p><code>awk</code>命令直接支持的算术运算符有：加+、减-、乘*、除/、模运算%、指数运算^；</p>
<p><strong>赋值运算符</strong></p>
<p><code>awk</code>命令常用的赋值运算符有：=、+=、-=、*=、/=、%=、^=；</p>
<p><strong>条件运算符</strong></p>
<p><code>awk</code>命令的条件运算符语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs  has-numbering&quot;&gt;表达式?值1:值2&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<p><strong>逻辑运算法</strong></p>
<p><code>awk</code>命令支持的逻辑运算符：&amp;&amp;、||、！；</p>
<p><strong>关系运算符</strong></p>
<p><code>awk</code>命令支持的关系运算符：&gt;、&gt;=、&lt;、&lt;=、==、！=、<sub>、!</sub>；</p>
<h4 id="awk-函数"><strong>awk 函数</strong></h4>
<p><code>awk</code>提供了许多系统函数，用户也可以自定义函数；</p>
<p><strong>字符串函数</strong></p>
<p>常用的字符串函数有：</p>
<table>
<colgroup>
<col style="width: 34%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>index(string1, string2)</td>
<td>返回 string2 在string1中第一次出现的位置</td>
</tr>
<tr class="even">
<td>length(string)</td>
<td>返回string的长度</td>
</tr>
<tr class="odd">
<td>match(string,regexp)</td>
<td>返回string中符合regexp的子字符串</td>
</tr>
<tr class="even">
<td>split(string,array,seperator)</td>
<td>根据分隔符seperator，将字符串string分隔成多个字段，并存储到数组array中</td>
</tr>
<tr class="odd">
<td>sub(regexp,replacement,string)</td>
<td>将字符串string第一个符合regexp的子字符串替换成replacement</td>
</tr>
<tr class="even">
<td>gsub(regexp,replacement,string)</td>
<td>将字符串string中符合regexp的全部子字符串都替换成replacement</td>
</tr>
<tr class="odd">
<td>substr(string,start,[length])</td>
<td>从字符串string的start位置开始截取长度为length(若指定了length，否则一直截取到字符串string结束)字串</td>
</tr>
</tbody>
</table>
<p><strong>算术函数</strong></p>
<p>常用的算术函数有：int(x)、sqrt(x)、exp(x)、log(x)、sin(x)、cos(x)、rand(x)、srand(x)；2)</p>
<p>实例：</p>
<ul>
<li>$ awk '/^(no|so)/' test-----打印所有以模式no或so开头的行。</li>
<li>$ awk '/<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>/{print $1}'
test-----如果记录以n或s开头，就打印这个记录。</li>
<li>$ awk '<span class="math inline">\(1 ~/[0-9][0-9]\)</span>/(print
$1}' test-----如果第一个域以两个数字结束就打印这个记录。</li>
<li>$ awk '$1 == 100 || $2 &lt; 50'
test-----如果第一个或等于100或者第二个域小于50，则打印该行。</li>
<li>$ awk '$1 != 10' test-----如果第一个域不等于10就打印该行。</li>
<li>$ awk '/test/{print $1 + 10}'
test-----如果记录包含正则表达式test，则第一个域加10并打印出来。</li>
<li>$ awk '{print ($1 &gt; 5 ? "ok "$1: "error"$1)}'
test-----如果第一个域大于5则打印问号后面的表达式值，否则打印冒号后面的表达式值。</li>
<li>$ awk '/<sup>root/,/</sup>mysql/'
test----打印以正则表达式root开头的记录到以正则表达式mysql开头的记录范围内的所有记录。如果找到一个新的正则表达式root开头的记录，则继续打印直到下一个以正则表达式mysql开头的记录为止，或到文件末尾。</li>
</ul>
<h2 id="可执行文件elf">11. 可执行文件ELF</h2>
<h3 id="elf简介">ELF简介</h3>
<p>ELF文件除了包含程序本身的<strong>代码</strong>和<strong>静态数据</strong>之外，还包括一些用来<strong>描述它们的信息</strong>，否则我们连代码和数据之间的分界线在哪里都不知道。这些信息描述了可执行文件的组织形式,
不同组织形式形成了不同格式的可执行文件,</p>
<p>Windows主流的可执行文件是PE(Portable Executable)格式</p>
<p>GNU/Linux主要使用ELF(Executable and Linkable
Format)格式。ELF是GNU/Linux可执行文件的标准格式,
这是因为GNU/Linux遵循System V ABI(Application Binary Interface).</p>
<p><strong>为什么堆和栈的内容没有放入可执行文件里面?
程序运行时刻用到的堆和栈又是怎么来的?</strong></p>
<p>ELF文件提供了两个视角来组织一个可执行文件。</p>
<p>一是面向链接过程的section视角，这个视角提供了用于链接与重定位的信息(例如符号表)。</p>
<p>二是面向执行的segment视角，这个视角提供了用于加载可执行文件的信息。</p>
<p>通过readelf命令,
我们还可以看到section和segment之间的映射关系：一个segment可能由0个或多个section组成,
但一个section可能不被包含于任何segment中。</p>
<p>ELF中采用<strong>program header table</strong>来管理segment, program
header
table的一个表项描述了一个segment的所有属性，包括<strong>类型</strong>,
<strong>虚拟地址</strong>，<strong>标志</strong>，<strong>对齐方式</strong>，以及<strong>文件内偏移量</strong>和<strong>segment大小</strong>。根据这些信息,
我们就可以知道需要加载可执行文件的哪些字节了，同时我们也可以看到，加载一个可执行文件并不是加载它所包含的所有内容，只要加载那些与运行时刻相关的内容就可以了,
例如调试信息和符号表就不必加载。我们可以通过判断segment的Type属性是否为<strong>PT_LOAD</strong>来判断一个segment是否需要加载。更多与ELF文件相关的信息,
请参考</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">man 5 elf<br></code></pre></td></tr></table></figure>
<h3 id="readelf命令">readelf命令</h3>
<p>readelf命令，一般用于查看ELF格式的文件信息，常见的文件如在Linux上的可执行文件，动态库(<em>.so)或者静态库(</em>.a)
等包含ELF格式的文件。</p>
<p><strong>选项 -h</strong>(elf
header)，显示elf文件开始的文件头信息，如下所示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">ELF Header:<br>  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 <br>  Class:                             ELF64<br>  Data:                              2<span class="hljs-string">&#x27;s complement, little endian</span><br><span class="hljs-string">  Version:                           1 (current)</span><br><span class="hljs-string">  OS/ABI:                            UNIX - System V</span><br><span class="hljs-string">  ABI Version:                       0</span><br><span class="hljs-string">  Type:                              EXEC (Executable file)</span><br><span class="hljs-string">  Machine:                           RISC-V</span><br><span class="hljs-string">  Version:                           0x1</span><br><span class="hljs-string">  Entry point address:               0x80000000</span><br><span class="hljs-string">  Start of program headers:          64 (bytes into file)</span><br><span class="hljs-string">  Start of section headers:          50496 (bytes into file)</span><br><span class="hljs-string">  Flags:                             0x4, double-float ABI</span><br><span class="hljs-string">  Size of this header:               64 (bytes)</span><br><span class="hljs-string">  Size of program headers:           56 (bytes)</span><br><span class="hljs-string">  Number of program headers:         2</span><br><span class="hljs-string">  Size of section headers:           64 (bytes)</span><br><span class="hljs-string">  Number of section headers:         13</span><br><span class="hljs-string">  Section header string table index: 12</span><br></code></pre></td></tr></table></figure>
<p><strong>选项 -l</strong>(program headers),segments
显示程序头（段头）信息(如果有数据的话)。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">Elf file <span class="hljs-built_in">type</span> is EXEC (Executable file)<br>Entry point 0x80000000<br>There are 2 program headers, starting at offset 64<br><br>Program Headers:<br>  Type           Offset             VirtAddr           PhysAddr<br>                 FileSiz            MemSiz              Flags  Align<br>  LOAD           0x0000000000001000 0x0000000080000000 0x0000000080000000<br>                 0x000000000000a6c8 0x0000000000014028  RWE    0x1000<br>  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000<br>                 0x0000000000000000 0x0000000000000000  RW     0x10<br><br> Section to Segment mapping:<br>  Segment Sections...<br>   00     .text .rodata .sdata2.__func__.1497 .sdata2.mainargs .data .data.heap .data.lut .bss <br>   01     <br></code></pre></td></tr></table></figure>
<p>找出每一个需要加载的segment的<strong>Offset</strong>，<strong>VirtAddr</strong>，<strong>FileSiz</strong>和<strong>MemSiz</strong>这些参数。<strong>相对文件偏移Offset指出相应segment的内容从ELF文件的第Offset字节开始,
在文件中的大小为FileSiz, 它需要被分配到以VirtAddr为首地址的虚拟内存位置,
在内存中它占用大小为MemSiz。</strong>
也就是说，这个segment使用的内存就是[VirtAddr, VirtAddr +
MemSiz)这一连续区间，然后将segment的内容从ELF文件中读入到这一内存区间，<strong>并将[VirtAddr
+ FileSiz, VirtAddr + MemSiz)对应的物理区间清零。</strong></p>
<p>关于程序从何而来, 可以参考一篇文章: <a
target="_blank" rel="noopener" href="https://www.tenouk.com/ModuleW.html">COMPILER, ASSEMBLER, LINKER
AND LOADER: A BRIEF STORY</a></p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>ns<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

    </div>

    
    
    
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"># Linux</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/10/30/DPI/" rel="prev" title="DPI学习笔记">
      <i class="fa fa-chevron-left"></i> DPI学习笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/11/09/IC%E5%90%8E%E7%AB%AF/" rel="next" title="IC后端">
      IC后端 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>
      
      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-text">1.添加环境变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-text">2.常用命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%90%AF%E5%85%A8%E9%83%A8%E6%9D%83%E9%99%90%E8%A7%A3%E9%94%81%E6%96%87%E4%BB%B6"><span class="nav-text">开启全部权限：解锁文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tar%E5%91%BD%E4%BB%A4"><span class="nav-text">tar命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#git"><span class="nav-text">3.git</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#make"><span class="nav-text">4.make</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gdb"><span class="nav-text">5.GDB</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-1"><span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#man%E5%91%BD%E4%BB%A4"><span class="nav-text">man命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list%E5%91%BD%E4%BB%A4"><span class="nav-text">list命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#break%E5%91%BD%E4%BB%A4"><span class="nav-text">break命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E6%AD%A5%E5%91%BD%E4%BB%A4"><span class="nav-text">单步命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#continue%E5%91%BD%E4%BB%A4"><span class="nav-text">continue命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#print%E5%91%BD%E4%BB%A4"><span class="nav-text">print命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#watch%E5%91%BD%E4%BB%A4"><span class="nav-text">watch命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#examine%E5%91%BD%E4%BB%A4"><span class="nav-text">examine命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set%E5%91%BD%E4%BB%A4"><span class="nav-text">set命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jump%E5%91%BD%E4%BB%A4"><span class="nav-text">jump命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#signal%E5%91%BD%E4%BB%A4"><span class="nav-text">signal命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#return%E5%91%BD%E4%BB%A4"><span class="nav-text">return命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#call%E5%91%BD%E4%BB%A4"><span class="nav-text">call命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#info%E5%91%BD%E4%BB%A4"><span class="nav-text">info命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set-scheduler-locking-offonstep"><span class="nav-text">set scheduler-locking
off|on|step</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#disassemble"><span class="nav-text">disassemble</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gcc"><span class="nav-text">6.gcc</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E7%AD%89%E7%BA%A7"><span class="nav-text">优化等级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E5%91%BD%E4%BB%A4"><span class="nav-text">编译链接命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-text">7.重定向</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#linux-21"><span class="nav-text">Linux 2&gt;&amp;1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8Ecommanddevnull%E8%AF%B4%E8%B5%B7"><span class="nav-text">从command&gt;&#x2F;dev&#x2F;null说起</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B421"><span class="nav-text">说说2&gt;&amp;1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#commanda-2a-%E4%B8%8E-commanda-21%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">command&gt;a 2&gt;a 与
command&gt;a 2&gt;&amp;1的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%8D%E6%80%9D%E8%80%83%E4%B8%80%E4%B8%8B"><span class="nav-text">再思考一下</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nohup%E5%8F%8Anohup.out"><span class="nav-text">nohup及nohup.out</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#grep%E5%91%BD%E4%BB%A4"><span class="nav-text">8. grep命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E7%BC%96%E8%BE%91%E5%99%A8-sed"><span class="nav-text">9. 流编辑器 sed</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sed%E5%91%BD%E4%BB%A4"><span class="nav-text">sed命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E8%A1%8C%E5%AE%9A%E4%BD%8D"><span class="nav-text">文本行定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%8C%E5%8F%B7%E5%AE%9A%E4%BD%8D"><span class="nav-text">行号定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9A%E4%BD%8D"><span class="nav-text">正则表达式定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sed%E5%91%BD%E4%BB%A4%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="nav-text">sed命令的常用操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%8D%B0%E6%96%87%E6%9C%AC"><span class="nav-text">1) 打印文本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E6%96%87%E6%9C%AC"><span class="nav-text">2) 替换文本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E6%9C%AC"><span class="nav-text">3) 删除文本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A2%9E%E5%8A%A0%E6%96%87%E6%9C%AC"><span class="nav-text">4) 增加文本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%96%87%E6%9C%AC"><span class="nav-text">5) 插入文本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E5%91%BD%E4%BB%A4"><span class="nav-text">6) 组合命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sed%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="nav-text">7)sed脚本文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#awk%E5%91%BD%E4%BB%A4"><span class="nav-text">10. awk命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#awk%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-text">awk命令的基本语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#awk%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F"><span class="nav-text">awk命令的匹配模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">1) 关系表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">2) 正则表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="nav-text">3) 混合模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4%E6%A8%A1%E5%BC%8F"><span class="nav-text">4) 区间模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#begin%E6%A8%A1%E5%BC%8F"><span class="nav-text">5) BEGIN模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#end%E6%A8%A1%E5%BC%8F"><span class="nav-text">6) END模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#awk-%E5%8F%98%E9%87%8F"><span class="nav-text">awk 变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F"><span class="nav-text">系统内置变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#awk-%E5%87%BD%E6%95%B0"><span class="nav-text">awk 函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6elf"><span class="nav-text">11. 可执行文件ELF</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#elf%E7%AE%80%E4%BB%8B"><span class="nav-text">ELF简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#readelf%E5%91%BD%E4%BB%A4"><span class="nav-text">readelf命令</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zmaiLee"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">zmaiLee</p>
  <div class="site-description" itemprop="description">HUSTer19. ICdesign & Computer Architecture</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zmaiLee" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zmaiLee" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_45631071" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_45631071" rel="noopener" target="_blank"><i class="crosshairs fa-fw"></i>CSDN</a>
      </span>
  </div>



        <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=386538&auto=1&height=66"></iframe>
      </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">劢</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  
<div class="moon-menu">
  <div class="moon-menu-items">
    
    <div id="moon-menu-item-back2bottom" class="moon-menu-item">
      <i class='fas fa-chevron-down'></i>    </div>
    
    <div id="moon-menu-item-back2top" class="moon-menu-item">
      <i class='fas fa-chevron-up'></i>    </div>
    
  </div>
  <div class="moon-menu-button">
    <svg class="moon-menu-bg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle>
    </svg>
    <div class="moon-menu-content">
      <div class="moon-menu-icon"><i class='fas fa-ellipsis-v'></i></div>
      <div class="moon-menu-text"></div>
    </div>
  </div>
</div><script src="/js/injector.js"></script>
</body>
</html>
