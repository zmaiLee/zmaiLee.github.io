<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zmailee.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Makefile学习笔记 1234567891011121314151617181920212223242526272829# Check for sanity to avoid later confusionifneq ($(words $(CURDIR)),1) $(error Unsupported: GNU Make cannot build in directories contain">
<meta property="og:type" content="article">
<meta property="og:title" content="Makefile学习笔记">
<meta property="og:url" content="https://zmailee.github.io/2022/11/19/Makefile/index.html">
<meta property="og:site_name" content="Mai&#39;s blog">
<meta property="og:description" content="Makefile学习笔记 1234567891011121314151617181920212223242526272829# Check for sanity to avoid later confusionifneq ($(words $(CURDIR)),1) $(error Unsupported: GNU Make cannot build in directories contain">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-11-19T08:26:36.585Z">
<meta property="article:modified_time" content="2022-11-19T09:12:10.976Z">
<meta property="article:author" content="zmaiLee">
<meta property="article:tag" content="Makefile">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zmailee.github.io/2022/11/19/Makefile/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" type="text/css" href="/css/injector/main.css" /><link rel="preload" as="style" href="/css/injector/light.css" /><link rel="preload" as="style" href="/css/injector/dark.css" />
  <title>Makefile学习笔记 | Mai's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Mai's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
     <a href="https://zmailee.github.io" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Mai's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">try my best</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/zmaiLee" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zmailee.github.io/2022/11/19/Makefile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="zmaiLee">
      <meta itemprop="description" content="HUSTer19. ICdesign & Computer Architecture">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mai's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Makefile学习笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-19 16:26:36 / 修改时间：17:12:10" itemprop="dateCreated datePublished" datetime="2022-11-19T16:26:36+08:00">2022-11-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="makefile学习笔记">Makefile学习笔记</h1>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># Check for sanity to avoid later confusion</span><br><span class="hljs-keyword">ifneq</span> (<span class="hljs-variable">$(words <span class="hljs-variable">$(CURDIR)</span>)</span>,1)<br> <span class="hljs-variable">$(<span class="hljs-built_in">error</span> Unsupported: GNU Make cannot build in directories containing spaces, build elsewhere: &#x27;<span class="hljs-variable">$(CURDIR)</span>&#x27;)</span><br><span class="hljs-keyword">endif</span><br><br><span class="hljs-comment"># This is intended to be a minimal example.  Before copying this to start a</span><br><span class="hljs-comment"># real project, it is better to start with a more complete example,</span><br><span class="hljs-comment"># e.g. examples/make_tracing_c.</span><br><br><span class="hljs-comment"># If $VERILATOR_ROOT isn&#x27;t in the environment, we assume it is part of a</span><br><span class="hljs-comment"># package install, and verilator is in your path. Otherwise find the</span><br><span class="hljs-comment"># binary relative to $VERILATOR_ROOT (such as when inside the git sources).</span><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(VERILATOR_ROOT)</span>,)<br>VERILATOR = verilator<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">export</span> VERILATOR_ROOT<br>VERILATOR = <span class="hljs-variable">$(VERILATOR_ROOT)</span>/bin/verilator<br><span class="hljs-keyword">endif</span><br><br><span class="hljs-section">default:</span><br>	@echo <span class="hljs-string">&quot;-- Verilator hello-world simple example&quot;</span><br>	@echo <span class="hljs-string">&quot;-- VERILATE &amp; BUILD --------&quot;</span><br>	<span class="hljs-variable">$(VERILATOR)</span> -cc --exe --build -j top.v sim_main.cpp<br>	@echo <span class="hljs-string">&quot;-- RUN ---------------------&quot;</span><br>	obj_dir/Vtop<br>	@echo <span class="hljs-string">&quot;-- DONE --------------------&quot;</span><br>	@echo <span class="hljs-string">&quot;Note: Once this example is understood, see examples/make_tracing_c.&quot;</span><br>	@echo <span class="hljs-string">&quot;Note: Also see the EXAMPLE section in the verilator manpage/document.&quot;</span><br><br></code></pre></td></tr></table></figure>
<span id="more"></span>
<p><code>$@</code>目标文件，<code>$^</code>所有的依赖文件，<code>$&lt;</code>第一个依赖文件</p>
<p>这个规则表示所有的 .o文件都是依赖与相应的.c文件的</p>
<h1 id="basename-names">$(basename NAMES…)</h1>
<p>函数名称：取前缀函数—basename。
函数功能：从文件名序列“NAMES…”中取出各个文件名的前缀部分。前缀部分指的是文件名中最后一个点号之前的部分。
返回值：空格分割的文件名序列“NAMES…”中各个文件的前缀序列。如果文件没有前缀，则返回空字串。</p>
<h1 id="notdir-names">$(notdir NAMES…)</h1>
<p>剥离文件的绝对路径，只保留文件名</p>
<h1 id="addprefix-前缀-待加前缀的">$(addprefix 前缀 待加前缀的)。</h1>
<p>函数功能：为“NAMES…”中的每一个文件名添加前缀“PREFIX”。参数“NAMES…”是空格分割的文件名序列，将“SUFFIX”添加到此序列的每一个文件名之前。</p>
<p>返回值：以单空格分割的添加了前缀“PREFIX”的文件名序列。</p>
<p>示例：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> src/,foo bar)</span><br></code></pre></td></tr></table></figure>
<p>返回值为“src/foo src/bar”</p>
<h1
id="makefile使用-d选项更改宏定义记得要clean">Makefile使用-D选项更改宏定义，记得要clean</h1>
<p>1、Makefile文件，如下</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CC_OPTS += -DMakefle_D=2<br><br><span class="hljs-section">all:testD</span><br>    echo <span class="hljs-string">&quot;done&quot;</span><br><span class="hljs-section">testD:testD.c</span><br>    gcc testD.c -o testD <span class="hljs-variable">$(CC_OPTS)</span><br></code></pre></td></tr></table></figure>
<p>2、testD.c文件，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Makefle_D = %d\n&quot;</span>, Makefle_D);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>改动-DMakefle_D=2为-DMakefle_D=3或者-DMakefle_D=4，编译测试.发现改动后，testD.c并不会重新编译。所以在Makefile里面改宏定义，记得要clean</p>
<h1 id="makefile调用函数">Makefile调用函数</h1>
<p>调用GNU make的内置函数：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(function arguments)</span><br></code></pre></td></tr></table></figure>
<p>想调用用户自定义的函数，则只能使用call函数来间接调用：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">PHONY: all</span><br><span class="hljs-keyword">define</span> func    <br>	@echo <span class="hljs-string">&quot;pram1 = $(0)&quot;</span>    <br>	@echo <span class="hljs-string">&quot;pram2 = $(1)&quot;</span><br><span class="hljs-keyword">endef</span><br><span class="hljs-section">all:    </span><br>	<span class="hljs-variable">$(<span class="hljs-built_in">call</span> func, hello zhaixue.cc)</span><br></code></pre></td></tr></table></figure>
<p>给函数传递的参数，在函数内部可以使用<span
class="math inline">\((0)、\)</span>(1)…直接使用。call函数是唯一一个可以用来创建新的参数化的函数。call函数不仅可以用来调用一个用户自定义函数并传参，还可以向一个表达式传参：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">call</span> &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;...)</span><br></code></pre></td></tr></table></figure>
<p>当 make 执行这个函数时，expression表达式中的参数变量，如<span
class="math inline">\((1)，\)</span>(2)，$(3)等，会被参数parm1，parm2，parm3依次取代。而expression的返回值就是
call 函数的返回值。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: all</span><br>param = $(1) $(2)<br>reverse_param = $(2) $(1)<br>str1 = <span class="hljs-variable">$(<span class="hljs-built_in">call</span> param, hello, zhaixue.cc)</span><br>str2 = <span class="hljs-variable">$(<span class="hljs-built_in">call</span> reverse_param, hello, zhaixue.cc)</span><br><span class="hljs-section">all:    </span><br>	@echo <span class="hljs-string">&quot;str1 = <span class="hljs-variable">$(str1)</span>&quot;</span>    <br>	@echo <span class="hljs-string">&quot;str2 = <span class="hljs-variable">$(str2)</span>&quot;</span><br></code></pre></td></tr></table></figure>
<p>执行make命令，运行结果为：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># make</span><br>str1 =  hello  zhaixue.cc<br>str2 =  zhaixue.cc  hello<br></code></pre></td></tr></table></figure>
<h1 id="跟我一起写-makefile"><strong>跟我一起写 Makefile</strong></h1>
<p>https://blog.csdn.net/haoel/article/details/2886</p>
<h2 id="一.基础使用">一.基础使用</h2>
<h3
id="关于程序的编译和链接"><strong>1.关于程序的编译和链接</strong></h3>
<p><strong>编译(compile):</strong>把源文件编译成中间代码文件，在Windows
.obj 文件，UNIX .o 文件，即 Object
File。一般来说，每个源文件都应该对应于一个中间目标文件</p>
<p><strong>编译:</strong>把源文件编译成中间代码文件,Windows是 .obj
文件，UNIX是 .o 文件，即 Object File，每个源文件都对应o文件</p>
<p><strong>链接(link):</strong>把大量的Object File合成执行文件</p>
<p>链接时，主要是链接函数和全局变量，可以使用o文件来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的Object
File，在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，要给o文件打个包，在Windows下这种包叫“库文件”.lib（Library
File) ，在UNIX下，是Archive File， .a 文件</p>
<p>源文件首先生成.o，再由.o生成执行文件</p>
<p>在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object
File。而在链接程序时，链接器会在所有的Object
File中找寻函数的实现，如果找不到，会报链Linker
Error，链接器未能找到函数的实现。你需要指定函数的Object File.</p>
<h3 id="基本目标">2.基本目标</h3>
<p>1）如果这个工程没有编译过，那么所有C文件都要编译并被链接
2）如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序
3）如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">target ... : prerequisites ...<br>    command<br>    ...<br>    ...<br></code></pre></td></tr></table></figure>
<p>target:目标文件，可以是Object
File，也可以是执行文件。还可以是一个标签Label</p>
<p>prerequisites:要生成target所需要的文件或是目标。</p>
<p>command:make需要执行的命令。（任意的Shell命令）</p>
<p>prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行</p>
<h3 id="一个示例">3.一个示例</h3>
<p>执行文件edit</p>
<p>依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。</p>
<p>clean不是一个文件，代表makefile中定义的一个操作，有点像C语言中的lable一样，其冒号后什么也没有，make不会自动去找文件的依赖性，不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字如“make
clean”。我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs makefile">edit : main.o kbd.o command.o display.o /<br>    insert.o search.o files.o utils.o<br>    cc -o edit main.o kbd.o command.o display.o /<br>          insert.o search.o files.o utils.o<br>main.o : main.c defs.h<br>    cc -c main.c<br>kbd.o : kbd.c defs.h command.h<br>    cc -c kbd.c<br>command.o : command.c defs.h command.h<br>    cc -c command.c<br>display.o : display.c defs.h buffer.h<br>    cc -c display.c<br>insert.o : insert.c defs.h buffer.h<br>    cc -c insert.c<br>search.o : search.c defs.h buffer.h<br>    cc -c search.c<br>files.o : files.c defs.h buffer.h command.h<br>    cc -c files.c<br>utils.o : utils.c defs.h<br>    cc -c utils.c<br>clean :<br>    rm edit main.o kbd.o command.o display.o /<br>      insert.o search.o files.o utils.o<br></code></pre></td></tr></table></figure>
<h3 id="make是如何工作的">4.make是如何工作的</h3>
<p>1、make会在当前目录下找名字叫“Makefile”或“makefile”的文件。
2、如果找到，它会找文件中的第一个目标文件（target），如“edit”，并把这个文件作为最终的目标文件。
3、如果edit文件不存在，或是edit所依赖的后面的 .o
文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。
4、如果edit所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。</p>
<p>make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。make只管文件的依赖性，如果找了依赖关系之后，冒号后面的文件还是不在，那么对不起，make就不工作啦。</p>
<p>像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——“make
clean”，以此来清除所有的目标文件，以便重编译。</p>
<p>于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如file.c，那么根据我们的依赖性，我们的目标file.o会被重编译（也就是在这个依性关系后面所定义的命令），于是file.o的文件也是最新的啦，于是file.o的文件修改时间要比edit要新，所以edit也会被重新链接了</p>
<p>规则的顺序是很重要的，Makefile中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的，所以一定要让make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。</p>
<p>一般来说，make会以UNIX的标准Shell，也就是/bin/sh来执行命令</p>
<h3 id="makefile中使用变量">5.makefile中使用变量</h3>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">edit : main.o kbd.o command.o display.o insert.o search.o files.o utils.o<br>   cc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o<br></code></pre></td></tr></table></figure>
<p>为了makefile的易维护，在makefile中可以使用变量。makefile的变量也就是一个字符串，理解成C语言中的宏</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o<br>edit : <span class="hljs-variable">$(objects)</span><br>     cc -o edit <span class="hljs-variable">$(objects)</span><br></code></pre></td></tr></table></figure>
<h3 id="让make自动推导">6.让make自动推导</h3>
<p>GNU的make可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。</p>
<p>只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且
cc -c whatever.c 也会被推导出来</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile">main.o : defs.h<br>kbd.o : defs.h command.h<br>command.o : defs.h command.h<br>display.o : defs.h buffer.h<br>insert.o : defs.h buffer.h<br>search.o : defs.h buffer.h<br>files.o : defs.h buffer.h command.h<br>utils.o : defs.h<br><br>.PHONY : clean<br>clean :<br>    -rm edit <span class="hljs-variable">$(objects)</span><br></code></pre></td></tr></table></figure>
<p><strong>“.PHONY”表示，clean是个伪目标文件</strong>，在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。</p>
<p>我们并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。</p>
<p>当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。</p>
<p>伪目标一般没有依赖的文件，<strong>但也可以为伪目标指定所依赖的文件</strong>。伪目标同样可以作为“默认目标”，只要将其放在第一个。如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile">all : prog1 prog2 prog3<br>.PHONY : all<br><br>prog1 : prog1.o utils.o<br>    cc -o prog1 prog1.o utils.o<br><br>prog2 : prog2.o<br>    cc -o prog2 prog2.o<br><br>prog3 : prog3.o sort.o utils.o<br>    cc -o prog3 prog3.o sort.o utils.o<br></code></pre></td></tr></table></figure>
<p>我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于伪目标的特性是，总是被执行的，所以其依赖的那三个目标就总是不如“all”这个目标新。所以，其它三个目标的规则总是会被决议。</p>
<p>目标也可以成为依赖。所以，<strong>伪目标同样也可成为依赖</strong>。看下面的例子：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: cleanall cleanobj cleandiff</span><br><br>cleanall : cleanobj cleandiff<br>    rm program<br><br>cleanobj :<br>    rm *.o<br><br>cleandiff :<br>    rm *.diff<br></code></pre></td></tr></table></figure>
<h3 id="另类风格的makefile">7.另类风格的makefile</h3>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o<br>edit : <span class="hljs-variable">$(objects)</span><br>    cc -o edit <span class="hljs-variable">$(objects)</span><br><br><span class="hljs-variable">$(objects)</span> : defs.h<br>kbd.o command.o files.o : command.h<br>display.o insert.o search.o files.o : buffer.h<br><br>.PHONY : clean<br>clean :<br>    rm edit <span class="hljs-variable">$(objects)</span><br></code></pre></td></tr></table></figure>
<p>这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得凌乱了。</p>
<h3 id="makefile里有什么">8.Makefile里有什么？</h3>
<p>Makefile里主要包含了五个东西：<strong>显式规则、隐晦规则、变量定义、文件指示和注释</strong>。</p>
<p>1、显式规则：如何生成一个或多的的目标文件。要生成的文件，文件的依赖文件，生成的命令。</p>
<p>2、隐晦规则：由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书Makefile</p>
<p>3、变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。</p>
<p>4、文件指示：</p>
<ul>
<li><p>在一个Makefile中引用另一个Makefile，<code>include &lt;filename&gt;</code>,被包含的文件会原模原样的放在当前文件的包含位置</p></li>
<li><p>指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if；</p></li>
<li><p>定义一个多行的命令。</p></li>
</ul>
<p>5、注释。Makefile中只有行注释。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“/#”。</p>
<p><strong>在Makefile中的命令，必须要以[Tab]键开始</strong></p>
<p>如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，make还会在下面的几个目录下找：</p>
<p>1、如果make执行时，有<code>-I</code>或<code>--include-dir</code>参数，那么make就会在这个参数所指定的目录下去寻找。
2、如果目录<prefix>/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。</p>
<p>如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：</p>
<p><code>-include &lt;filename&gt;</code></p>
<h3 id="通配符">9.通配符</h3>
<p>定义一系列比较类似的文件，make支持三各通配符：<code>*</code>，<code>?</code>和<code>[...]</code>。这是和Unix的B-Shell是相同的。</p>
<p>通配符代替了一系列的文件，如“*.c”表示所以后缀为c的文件。如果我们的文件名中有通配符，如：<code>*</code>，那么可以用<code>/*</code>来表示真实的<code>*</code>字符，而不是任意长度的字符串。</p>
<p><code>objects = *.o</code>通符同样可以用在变量中。并不是说[*.o]会展开，不！objects的值就是“*.o”。Makefile中的变量其实就是C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有[.o]的文件名的集合，可以这样：<code>objects := $(wildcard *.o)</code></p>
<h2 id="二.文件搜寻">二.文件搜寻</h2>
<p>把源文件分类，并存放在不同的目录中。当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让mak在自动去找。</p>
<p>Makefile文件中的特殊变量<code>VPATH</code>就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当前目录找不到的情况下，到所指定的目录中去找。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">VPATH = src : ../headers<br></code></pre></td></tr></table></figure>
<p><code>src</code>和<code>../headers</code>，make会按照这个顺序进行搜索。目录由“冒号”分隔。</p>
<p>另一个设置文件搜索路径的方法是使用<code>make</code>的<code>vpath</code>关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，它可以指定不同的文件在不同的搜索目录中。</p>
<p>1、<code>vpath &lt;pattern&gt; &lt;directories&gt;</code>
<code>vpath %.h ../headers</code></p>
<p>为符合模式<pattern>的文件指定搜索目录<directories>。</p>
<p>2、<code>vpath &lt;pattern&gt;</code></p>
<p>清除符合模式<pattern>的文件的搜索目录。</p>
<p>3、<code>vpath</code></p>
<p>清除所有已被设置好了的文件搜索目录。</p>
<p>vapth使用方法中的<pattern>需要包含<code>%</code>字符。<code>%</code>的意思是匹配零或若干字符，例如，<code>%.h</code>表示所有以<code>.h</code>结尾的文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">vpath %.c foo:bar<br>vpath %  blish<br></code></pre></td></tr></table></figure>
<p>而上面的语句则表示“.c”结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。</p>
<h2 id="三.多目标"><strong>三.多目标</strong></h2>
<p>Makefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令是同一个，可以使用一个自动化变量<code>$@</code>，表示目前规则中所有的目标的集合</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile">bigoutput littleoutput : text.g<br>    generate text.g -<span class="hljs-variable">$(<span class="hljs-built_in">subst</span> output,,<span class="hljs-variable">$@</span>)</span> &gt; <span class="hljs-variable">$@</span><br><span class="hljs-comment">#上述规则等价于：</span><br>bigoutput : text.g<br>    generate text.g -big &gt; bigoutput<br>littleoutput : text.g<br>    generate text.g -little &gt; littleoutput<br></code></pre></td></tr></table></figure>
<p>其中，<code>-$(subst  output,,$@)</code>中的<code>$</code>表示执行一个Makefile的函数，函数名为subst，后面的为参数。这里的这个函数是截取字符串的意思，<code>$@</code>表示目标的集合，就像一个数组，<code>$@</code>依次取出目标，并执于命令。</p>
<p><strong>静态模式</strong>可以更加容易地定义多目标的规则</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">&lt;targets ...&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt;<br>    &lt;commands&gt;<br></code></pre></td></tr></table></figure>
<p>targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。</p>
<p>target-parrtern是指明了targets的模式，也就是的目标集模式。</p>
<p>prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。</p>
<p>如果我们的<target-parrtern>定义成<code>%.o</code>，意思是我们的<target>集合中都是以<code>.o</code>结尾的，而如果我们的<prereq-parrterns>定义成<code>%.c</code>，意思是对<target-parrtern>所形成的目标集进行二次定义，其计算方法是，取<target-parrtern>模式中的“%”（也就是去掉了[.o]这个结尾），并为其加上[.c]这个结尾，形成的新集合。</p>
<p>所以，我们的“目标模式”或是“依赖模式”中都应该有“%”这个字符</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile">  objects = foo.o bar.o<br>  all: <span class="hljs-variable">$(objects)</span><br>  <span class="hljs-variable">$(objects)</span>: %.o : %.c<br>      <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br><span class="hljs-comment"># 等价于:</span><br>  foo.o : foo.c<br>      <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> foo.c -o foo.o<br>  bar.o : bar.c<br>      <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> bar.c -o bar.o<br></code></pre></td></tr></table></figure>
<p>上面的例子中，指明了我们的目标从<code>$object</code>中获取，<code>%.o</code>表明要所有以“.o”结尾的目标，也就是<code>foo.o bar.o</code>，也就是变量<code>$object</code>集合的模式，而依赖模式<code>%.c</code>则取模式<code>%.o</code>的<code>%</code>，也就是<code>foo  bar</code>，并为其加下<code>.c</code>的后缀，于是，我们的依赖目标就是<code>foo.c  bar.c</code>。而命令中的<code>$&lt;</code>和<code>$@</code>则是<strong>自动化变量</strong>，<code>$&lt;</code>表示所有的依赖目标集（也就是“foo.c
bar.c”），<code>$@</code>表示目标集（也就是“foo.o bar.o”）</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">files = foo.elc bar.o lose.o<br><br><span class="hljs-variable">$(<span class="hljs-built_in">filter</span> %.o,<span class="hljs-variable">$(files)</span>)</span>: %.o: %.c<br>    <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br><span class="hljs-variable">$(<span class="hljs-built_in">filter</span> %.elc,<span class="hljs-variable">$(files)</span>)</span>: %.elc: %.el<br>    emacs -f batch-byte-compile <span class="hljs-variable">$&lt;</span><br></code></pre></td></tr></table></figure>
<p><code>$(filter %.o,$(files))</code>表示调用Makefile的filter函数，过滤<code>$files</code>集，只要其中模式为<code>%.o</code>的内容。</p>
<h2 id="四.自动生成依赖性"><strong>四.自动生成依赖性</strong></h2>
<p>在Makefile中，我们的依赖关系可能会需要包含一系列的头文件</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">main.o : main.c  defs.h<br></code></pre></td></tr></table></figure>
<p>你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个<code>-M</code>的选项，即<strong>自动找寻源文件中包含的头文件</strong>，并生成一个依赖关系。</p>
<p>如果使用GNU的C/C++编译器，用<code>-MM</code>参数，<code>-M”</code>参数会把一些标准库的头文件也包含进来。</p>
<p>gcc -M main.c的输出是：</p>
<p>main.o: main.c defs.h /usr/include/stdio.h /usr/include/features.h /
/usr/include/sys/cdefs.h /usr/include/gnu/stubs.h /
/usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stddef.h /
/usr/include/bits/types.h /usr/include/bits/pthreadtypes.h /
/usr/include/bits/sched.h /usr/include/libio.h /
/usr/include/_G_config.h /usr/include/wchar.h /
/usr/include/bits/wchar.h /usr/include/gconv.h /
/usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stdarg.h /
/usr/include/bits/stdio_lim.h</p>
<p>gcc -MM main.c的输出则是：</p>
<p>main.o: main.c defs.h</p>
<p>GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个<code>name.c</code>的文件都生成一个<code>name.d</code>的Makefile文件，[.d]文件中就存放对应[.c]文件的依赖关系。</p>
<p>我们可以写出[.c]文件和[.d]文件的依赖关系，并让make自动更新或自成[.d]文件，并把其包含在我们的主Makefile中，我们给出了一个模式规则来产生[.d]文件：</p>
<p>%.d: %.c <span class="citation" data-cites="set">@set</span> -e; rm
-f $@; / $(CC) -M $(CPPFLAGS) <span class="math inline">\(&lt; &gt;
[\)</span>@.](mailto:<span class="math inline">\(@.\)</span><span
class="math display">\[$); /
       sed &#39;s,/($*/)/.o[ :]*,/1.o $@ : ,g&#39; &lt;
[$@.](mailto:$@.\]</span><span class="math display">\[) &gt; $@; /
       rm -f [$@.](mailto:$@.\]</span>$$)</p>
<p>这个规则的意思是，所有的[.d]文件依赖于[.c]文件，<code>rm -f  $@</code>的意思是删除所有的目标，也就是[.d]文件，第二行的意思是，为每个依赖文件<code>$&lt;</code>，也就是[.c]文件生成依赖文件，<code>$@</code>表示模式<code>%.d</code>文件，如果有一个C文件是name.c，那么<code>%</code>就是<code>name</code>，意为一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。</p>
<p>总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入[.d]文件的依赖，即把依赖关系：</p>
<p>main.o : main.c defs.h</p>
<p>转成：</p>
<p>main.o main.d : main.c defs.h</p>
<p>于是，我们的[.d]文件也会自动更新了，并会自动生成了，当然，你还可以在这个[.d]文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个[.d]文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。</p>
<p>sources = foo.c bar.c</p>
<p>include $(sources: .c = .d)</p>
<p>上述语句中的<code>$(sources:.c=.d)</code>中的<code>.c=.d</code>的意思是做一个替换，把变量<code>$(sources)</code>所有[.c]的字串都替换成[.d]，关于这个“替换”的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为include是按次来载入文件，最先载入的[.d]文件中的目标会成为默认目标。</p>
<h2 id="五.书写命令">五.书写命令</h2>
<h3 id="显示命令"><strong>显示命令</strong></h3>
<p>通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用<code>@</code>字符在命令行前，<strong>这个命令将不被make显示出来</strong>，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如：</p>
<p><span class="citation" data-cites="echo">@echo</span>
"正在编译XXX模块......"</p>
<p>当make执行时，会输出“正在编译XXX模块......”字串，但不会输出命令</p>
<p>如果make执行时，带入make参数<code>-n</code>或<code>--just-print</code>，那么其<strong>只是显示命令，但不会执行命令</strong>，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。</p>
<p>而make参数<code>-s</code>或<code>--slient</code>则是全面禁止命令的显示。</p>
<h3 id="命令执行"><strong>命令执行</strong></h3>
<p>当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：</p>
<p>示例一： exec: cd /home/hchen pwd</p>
<p>示例二： exec: cd /home/hchen; pwd</p>
<p>当我们执行“make
exec”时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出“/home/hchen”。</p>
<h3 id="命令出错"><strong>命令出错</strong></h3>
<p>每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。</p>
<p>有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。为了做到忽略命令的出错，我们可以在Makefile的命令行前加一个减号<code>-</code>（在Tab键之后），标记为不管命令出不出错都认为是成功的。如：</p>
<p>clean: -rm -f *.o</p>
<p>还有一个全局的办法是，给make加上<code>-i</code>或是<code>--ignore-errors</code>参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以<code>.IGNORE</code>作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。</p>
<p>make的参数<code>-k</code>或是<code>--keep-going</code>，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。</p>
<h3 id="嵌套执行make"><strong>嵌套执行make</strong></h3>
<p>在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。</p>
<p>例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么总控的Makefile可以这样书写：</p>
<p>subsystem: cd subdir &amp;&amp; $(MAKE)</p>
<p>其等价于：</p>
<p>subsystem: $(MAKE) -C subdir</p>
<p>定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行make命令。</p>
<p>总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了<code>-e</code>参数。</p>
<p>传递变量到下级Makefile中</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">export</span> &lt;variable ...&gt;<br><br><span class="hljs-keyword">export</span> variable = value<br><br><span class="hljs-comment"># 其等价于：</span><br><br><span class="hljs-keyword">export</span> variable := value<br><br><span class="hljs-comment"># 不让某些变量传递到下级Makefile中</span><br><br><span class="hljs-keyword">unexport</span> &lt;variable ...&gt;<br></code></pre></td></tr></table></figure>
<p>如果要传递所有的变量，只要一个export就行了。</p>
<p>SHELL和MAKEFLAGS，这两个变量不管你是否export，其总是要传递到下层Makefile中，特别是MAKEFILES变量，其中包含了make的参数信息，如果我们执行“总控Makefile”时有make参数或是在上层Makefile中定义了这个变量</p>
<p>但是make命令中的有几个参数并不往下传递，它们是<code>-C</code>,<code>-f</code>,<code>-h</code>,
<code>-o</code>和<code>-W</code>，如果你不想往下层传递参数，那么，你可以：</p>
<p>subsystem: cd subdir &amp;&amp; $(MAKE) MAKEFLAGS=</p>
<p>如果你定义了环境变量MAKEFLAGS，那么你得确信其中的选项是大家都会用到的，如果其中有“-t”,“-n”,和“-q”参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。</p>
<p>还有一个在“嵌套执行”中比较有用的参数，<code>-w</code>或是<code>--print-directory</code>会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是<code>/home/hchen/gnu/make</code>，如果我们使用<code>make -w</code>来执行，那么当进入该目录时，我们会看到：</p>
<p>make: Entering directory `/home/hchen/gnu/make'.</p>
<p>而在完成下层make后离开目录时，我们会看到：</p>
<p>make: Leaving directory `/home/hchen/gnu/make'</p>
<p>当你使用“-C”参数来指定make下层Makefile时，“-w”会被自动打开的。如果参数中有“-s”（“--slient”）或是“--no-print-directory”，那么，“-w”总是失效的。</p>
<h3 id="定义命令包"><strong>定义命令包</strong></h3>
<p>如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束，如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">define</span> run-yacc<br>yacc <span class="hljs-variable">$(<span class="hljs-built_in">firstword</span> <span class="hljs-variable">$^</span>)</span><br>mv y.tab.c <span class="hljs-variable">$@</span><br><span class="hljs-keyword">endef</span><br></code></pre></td></tr></table></figure>
<p>这里，<code>run-yacc</code>是这个命令包的名字，其不要和Makefile中的变量重名。在“define”和“endef”中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">foo.c : foo.y<br>    $(run-yacc)<br></code></pre></td></tr></table></figure>
<p>我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包<code>run-yacc</code>中的<code>$^</code>就是<code>foo.y</code>，<code>$@</code>就是<code>foo.c</code>,
make在执行命令包时，命令包中的每个命令会被依次独立执行。</p>
<h2 id="六.使用变量">六.使用变量</h2>
<p>可以在Makefile中改变变量值。在Makefile中，变量可以使用在“目标”，“依赖目标”，“命令”或是Makefile的其它部分中。</p>
<p>变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有<code>:</code>、<code>#</code>、<code>=</code>或是空字符（空格、回车等）。变量是大小写敏感的，<code>foo</code>、<code>Foo</code>和<code>FOO</code>是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。</p>
<h3 id="变量的基础"><strong>变量的基础</strong></h3>
<p>变量在声明时需要给予初值，在使用时，需要给在变量名前加上<code>$</code>符号，但最好用<code>()</code>或是<code>&#123;&#125;</code>把变量给包括起来。要使用真实的<code>$</code>字符，那么你需要用<code>$$</code>来表示。</p>
<p>变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。</p>
<h3 id="变量中的变量"><strong>变量中的变量</strong></h3>
<p>在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。</p>
<p>先看第一种方式左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">foo = <span class="hljs-variable">$(bar)</span><br>bar = <span class="hljs-variable">$(ugh)</span><br>ugh = Huh?<br><br><span class="hljs-section">all:</span><br>    echo <span class="hljs-variable">$(foo)</span><br></code></pre></td></tr></table></figure>
<p>这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，不好的地方是递归定义</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CFLAGS = <span class="hljs-variable">$(include_dirs)</span> -O<br>include_dirs = -Ifoo -Ibar<br></code></pre></td></tr></table></figure>
<p>当“CFLAGS”在命令中被展开时，会是“-Ifoo -Ibar -O”</p>
<p>如果在变量中使用函数，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数“wildcard”和“shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。</p>
<p>为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是“:=”操作符，</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">x := foo<br>y := <span class="hljs-variable">$(x)</span> bar<br>x := later<br><span class="hljs-comment"># 其等价于：</span><br>y := foo bar<br>x := later<br></code></pre></td></tr></table></figure>
<p>这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifeq</span> (0,$&#123;MAKELEVEL&#125;)<br>cur-dir  := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span><br>whoami  := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> whoami)</span><br>host-type := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> arch)</span><br>MAKE := $&#123;MAKE&#125; host-type=$&#123;host-type&#125; whoami=$&#123;whoami&#125;<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure>
<p>系统变量“MAKELEVEL”，其意思是，如果我们的make有一个嵌套执行的动作，那么这个变量会记录了我们的当前Makefile的调用层数。</p>
<p>如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：</p>
<p>nullstring := space := $(nullstring) # end of the line</p>
<p>nullstring是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个Empty变量来标明变量的值开始了，而后面<strong>采用“#”注释符来表示变量定义的终止</strong>，这样，我们可以定义出其值是一个空格的变量。请注意这里关于“#”的使用，注释符“#”的这种特性值得我们注意，如果我们这样定义一个变量：</p>
<p><code>dir := /foo/bar  # directory to put the frobs in</code></p>
<p>dir这个变量的值是<code>/foo/bar</code>，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录就完蛋了。还有一个比较有用的操作符是<code>?=</code>，先看示例：</p>
<p><code>FOO ?= bar</code></p>
<p>其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(<span class="hljs-built_in">origin</span> FOO)</span>, undefined)<br> FOO = bar<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure>
<h3 id="变量高级用法"><strong>变量高级用法</strong></h3>
<p>第一种是变量值的替换。</p>
<p>我们可以替换变量中的共有的部分，其格式是<code>$(var:a=b)</code>或是<code>$&#123;var:a=b&#125;</code></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">foo := a.o b.o c.o<br>bar := $(foo: .o=.c)<br></code></pre></td></tr></table></figure>
<p>另外一种变量替换的技术是以“静态模式”定义的，如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">foo := a.o b.o c.o<br>bar := $(foo:%.o=%.c)<br></code></pre></td></tr></table></figure>
<p>这依赖于被替换字串中的有相同的模式，模式中必须包含一个“%”字符</p>
<p>第二种高级用法是——“把变量的值再当成变量”。先看一个例子：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">x = y<br>y = z<br>a := $(<span class="hljs-variable">$(x)</span>)<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<span
class="math inline">\((x)的值是“y”，所以\)</span>(<span
class="math inline">\((x))就是\)</span>(y)，于是$(a)的值就是“z”。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">x = <span class="hljs-variable">$(y)</span><br>y = z<br>z = Hello<br>a := $(<span class="hljs-variable">$(x)</span>)<br></code></pre></td></tr></table></figure>
<p>这里的<span class="math inline">\((\)</span>(x))被替换成了<span
class="math inline">\((\)</span>(y))，因为<span
class="math inline">\((y)值是“z”，所以，最终结果是：a:=\)</span>(z)，也就是“Hello”。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">x = variable1<br>variable2 := Hello<br>y = <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> 1,2,<span class="hljs-variable">$(x)</span>)</span><br>z = y<br>a := $($(<span class="hljs-variable">$(z)</span>))<br></code></pre></td></tr></table></figure>
<p>这个例子中，“<span class="math inline">\((\)</span>(<span
class="math inline">\((z)))”扩展为“\)</span>(<span
class="math inline">\((y))”，而其再次被扩展为“\)</span>(<span
class="math inline">\((subst 1,2,\)</span>(x)))”。<span
class="math inline">\((x)的值是“variable1”，subst函数把“variable1”中的所有“1”字串替换成“2”字串，再取其值，\)</span>(a)的值就是$(variable2)的值——“Hello”。</p>
<p>在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">first_second = Hello<br>a = first<br>b = second<br>all = $($a_$b)<br></code></pre></td></tr></table></figure>
<p>这里的“<span
class="math inline">\(a_\)</span>b”组成了“first_second”，于是，$(all)的值就是“Hello”。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">a_objects := a.o b.o c.o<br>1_objects := 1.o 2.o 3.o<br>sources := $(<span class="hljs-variable">$(a1)</span>_objects:.o=.c)<br></code></pre></td></tr></table></figure>
<p>这个例子中，如果<span
class="math inline">\((a1)的值是“a”的话，那么，\)</span>(sources)的值就是“a.c
b.c c.c”；如果<span
class="math inline">\((a1)的值是“1”，那么\)</span>(sources)的值是“1.c
2.c 3.c”。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifdef</span> do_sort<br>func := sort<br><span class="hljs-keyword">else</span><br>func := strip<br><span class="hljs-keyword">endif</span><br>bar := a d b g q c<br>foo := $(<span class="hljs-variable">$(func)</span> <span class="hljs-variable">$(bar)</span>)<br></code></pre></td></tr></table></figure>
<p>这个示例中，如果定义了“do_sort”，那么：foo := <span
class="math inline">\((sort a d b g q c)，于是\)</span>(foo)的值就是“a b
c d g q”，而如果没有定义“do_sort”，那么：foo := $(sort a d b g q
c)，调用的就是strip函数。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">dir = foo<br><span class="hljs-variable">$(dir)</span>_sources := <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dir)</span>/*.c)</span><br><span class="hljs-keyword">define</span> <span class="hljs-variable">$(dir)</span>_print<br>lpr $(<span class="hljs-variable">$(dir)</span>_sources)<br><span class="hljs-keyword">endef</span><br></code></pre></td></tr></table></figure>
<h3 id="追加变量值"><strong>追加变量值</strong></h3>
<p>使用<code>+=</code>操作符给变量追加值，如：</p>
<p>objects = main.o foo.o bar.o utils.o objects += another.o</p>
<p><code>$(objects)</code>值变成：<code>main.o foo.o bar.o utils.o another.o</code></p>
<p>如果变量之前没有定义过，那么，“+=”会自动变成“=”，如果前面有变量定义，那么“+=”会继承于前次操作的赋值符。如果前一次的是“:=”，那么“+=”会以“:=”作为其赋值符，如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">variable := value<br>variable += more<br></code></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">variable := value<br>variable := <span class="hljs-variable">$(variable)</span> more<br></code></pre></td></tr></table></figure>
<p>但如果是这种情况：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">variable = value<br>variable += more<br></code></pre></td></tr></table></figure>
<p>由于前次的赋值符是“=”，所以“+=”也会以“=”来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。</p>
<h3 id="override-指示符"><strong>override 指示符</strong></h3>
<p>如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是：</p>
<p>override <variable> = <value></p>
<p>override <variable> := <value></p>
<p>override <variable> += <more text></p>
<h3 id="多行变量"><strong>多行变量</strong></h3>
<p>使用define关键字设置变量的值可以有换行。define后面跟的是变量的名字，重起一行定义变量的值，以endef关键字结束。</p>
<p>变量的值可以包含<strong>函数、命令、文字，或是其它变量</strong>。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以[Tab]键开头，那么make就不会把其认为是命令。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">define</span> two-lines<br>echo foo<br>echo <span class="hljs-variable">$(bar)</span><br><span class="hljs-keyword">endef</span><br></code></pre></td></tr></table></figure>
<h3 id="环境变量"><strong>环境变量</strong></h3>
<p>make运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）</p>
<p>因此，如果我们在环境变量中设置了<code>CFLAGS</code>环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。<strong>如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量</strong>，如果没有定义则使用系统环境变量的值。</p>
<p>当make嵌套调用时，上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层Makefile传递，则需要使用exprot关键字来声明。</p>
<h3 id="目标变量"><strong>目标变量</strong></h3>
<p>Makefile中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量。“自动化变量”除外，如<code>$&lt;</code>等这种类量的自动化变量就属于“规则型变量”，这种变量的值<strong>依赖于规则的目标和依赖目标的定义</strong>。</p>
<p>当然，同样可以为某个目标设置局部变量，这种变量被称为“Target-specific
Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。</p>
<p>其语法是：</p>
<p>&lt;target ...&gt; : <variable-assignment></p>
<p>&lt;target ...&gt; : overide <variable-assignment></p>
<p><variable-assignment>可以是前面讲过的各种赋值表达式，如<code>=</code>、<code>:=</code>、<code>+=</code>或是<code>？=</code>。第二个语法是针对于make命令行带入的变量，或是系统环境变量。</p>
<p>这个特性非常的有用，当我们设置了这样一个变量，<strong>这个变量会作用到由这个目标所引发的所有的规则中</strong>去。如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile">prog : CFLAGS = -g<br>prog : prog.o foo.o bar.o<br>    <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> prog.o foo.o bar.o<br>prog.o : prog.c<br>    <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> prog.c<br>foo.o : foo.c<br>    <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> foo.c<br>bar.o : bar.c<br>    <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> bar.c<br></code></pre></td></tr></table></figure>
<p>在这个示例中，不管全局的<span
class="math inline">\((CFLAGS)的值是什么，在prog目标，以及其所引发的所有规则中（prog.o
foo.o bar.o的规则），\)</span>(CFLAGS)的值都是“-g”</p>
<h3 id="模式变量"><strong>模式变量</strong></h3>
<p>模式变量（Pattern-specific
Variable）。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。</p>
<p>我们知道，make的“模式”一般是至少含有一个“%”的，所以，我们可以以如下方式给所有以[.o]结尾的目标定义目标变量：</p>
<p>%.o : CFLAGS = -O</p>
<p>同样，模式变量的语法和“目标变量”一样：</p>
<p>&lt;pattern ...&gt; : <variable-assignment></p>
<p>&lt;pattern ...&gt; : override <variable-assignment></p>
<p>override同样是针对于系统环境传入的变量，或是make命令行指定的变量。</p>
<h2 id="七.使用条件判断">七.使用条件判断</h2>
<p>使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。</p>
<h3 id="示例"><strong>示例</strong></h3>
<p>下面的例子，判断$(CC)变量是否“gcc”，如果是的话，则使用GNU函数编译目标。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile">libs_for_gcc = -lgnu<br>normal_libs =<br><br><span class="hljs-section">foo: <span class="hljs-variable">$(objects)</span></span><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(CC)</span>,gcc)<br>    <span class="hljs-variable">$(CC)</span> -o foo <span class="hljs-variable">$(objects)</span> <span class="hljs-variable">$(libs_for_gcc)</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-variable">$(CC)</span> -o foo <span class="hljs-variable">$(objects)</span> <span class="hljs-variable">$(normal_libs)</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure>
<h3 id="语法"><strong>语法</strong></h3>
<p>条件表达式的语法为：</p>
<p><conditional-directive> <text-if-true> endif</p>
<p>以及：</p>
<p><conditional-directive> <text-if-true> else <text-if-false> endif</p>
<p>其中<conditional-directive>表示条件关键字，如“ifeq”。这个关键字有四个。</p>
<p>第一个是我们前面所见过的“ifeq”</p>
<p>ifeq (<arg1>, <arg2>) ifeq '<arg1>' '<arg2>' ifeq "<arg1>" "<arg2>"
ifeq "<arg1>" '<arg2>' ifeq '<arg1>' "<arg2>"</p>
<p>比较参数“arg1”和“arg2”的值是否相同。当然，参数中我们还可以使用make的函数。如：</p>
<p>ifeq ($(strip $(foo)),) <text-if-empty> endif</p>
<p>这个示例中使用了“strip”函数，如果这个函数的<strong>返回值是空（Empty）</strong>，那么<text-if-empty>就生效。</p>
<p>第二个条件关键字是“ifneq”。语法是：</p>
<p>ifneq (<arg1>, <arg2>) ifneq '<arg1>' '<arg2>' ifneq "<arg1>"
"<arg2>" ifneq "<arg1>" '<arg2>' ifneq '<arg1>' "<arg2>"</p>
<p>其比较参数“arg1”和“arg2”的值是否相同，如果不同，则为真。和“ifeq”类似。</p>
<p>第三个条件关键字是“ifdef”。语法是：</p>
<p>ifdef <variable-name></p>
<h1 id="看到这里了">看到这里了</h1>
<p>如果变量<variable-name>的值<strong>非空</strong>，那到表达式为真。否则，表达式为假。当然，<variable-name>同样可以是一个函数的返回值。注意，ifdef只是测试一个变量是否有值，其并不会把变量扩展到当前位置。</p>
<p>示例一： bar = foo = $(bar) ifdef foo frobozz = yes else frobozz = no
endif</p>
<p>示例二： foo = ifdef foo frobozz = yes else frobozz = no endif</p>
<p>第一个例子中，<code>$(frobozz)</code>值是<code>yes</code>，第二个则是<code>no</code>。</p>
<p>第四个条件关键字是“ifndef”。其语法是：</p>
<p>ifndef <variable-name></p>
<p>特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如<code>$@</code>等）放入条件表达式中，因为自动化变量是在运行时才有的。而且，为了避免混乱，make不允许把整个条件语句分成两部分放在不同的文件中。</p>
<h2 id="八.使用函数">八.使用函数</h2>
<p>在Makefile中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使用。</p>
<h3 id="函数的调用语法"><strong>函数的调用语法</strong></h3>
<p>函数调用，很像变量的使用，也是以“$”来标识的，其语法如下：</p>
<p>$(<function> <arguments>)</p>
<p>或是</p>
<p>${<function> <arguments>}</p>
<p>这里，<function>就是函数名，make支持的函数不多。<arguments>是函数的参数，参数间以逗号“,”分隔，而<strong>函数名和参数之间以“空格”分隔</strong>。函数调用以“$”开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？函数中的参数可以使用变量</p>
<p>comma:= , empty:= space:= $(empty) $(empty) foo:= a b c bar:= $(subst
<span class="math inline">\((space),\)</span>(comma),$(foo))</p>
<p>在这个示例中，<span
class="math inline">\((comma)的值是一个逗号。\)</span>(space)使用了<span
class="math inline">\((empty)定义了一个空格，\)</span>(foo)的值是“a b
c”，<span
class="math inline">\((bar)的定义用，调用了函数“subst”，这是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是把\)</span>(foo)中的空格替换成逗号，所以$(bar)的值是“a,b,c”。</p>
<h3 id="字符串处理函数"><strong>字符串处理函数</strong></h3>
<p><strong>$(subst <from>,<to>,<text>)</strong></p>
<p>名称：字符串替换函数——subst。
功能：把字串<text>中的<from>字符串替换成<to>。
返回：函数返回被替换过后的字符串。</p>
<p>示例： $(subst ee,EE,feet on the street)，</p>
<pre><code>把“feet on the street”中的“ee”替换成“EE”，返回结果是“fEEt on the strEEt”。</code></pre>
<p><strong>$(patsubst <pattern>,<replacement>,<text>)</strong></p>
<p>名称：模式字符串替换函数——patsubst。
功能：查找<text>中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式<pattern>，如果匹配的话，则以<replacement>替换。这里，<pattern>可以包括通配符“%”，表示任意长度的字串。如果<replacement>中也包含“%”，那么，<replacement>中的这个“%”将是<pattern>中的那个“%”所代表的字串。（可以用“/”来转义，以“/%”来表示真实含义的“%”字符）
返回：函数返回被替换过后的字符串。</p>
<p>示例：</p>
<p>​ $(patsubst %.c,%.o,x.c.c bar.c)</p>
<p>​ 把字串“x.c.c bar.c”符合模式[%.c]的单词替换成[%.o]，返回结果是“x.c.o
bar.o”</p>
<p>备注：</p>
<p>​ 这和我们前面“变量章节”说过的相关知识有点相似。如：</p>
<p>​ “<span
class="math inline">\((var:&lt;pattern&gt;=&lt;replacement&gt;)” ​ 相当于
​“\)</span>(patsubst <pattern>,<replacement>,$(var))”，</p>
<p>​ 而“<span class="math inline">\((var:
&lt;suffix&gt;=&lt;replacement&gt;)” ​ 则相当于 ​ “\)</span>(patsubst
%<suffix>,%<replacement>,$(var))”。</p>
<p>​ 例如有：objects = foo.o bar.o baz.o， ​ 那么，“<span
class="math inline">\((objects:.o=.c)”和“\)</span>(patsubst
%.o,%.c,$(objects))”是一样的。</p>
<p><strong>$(strip <string>)</strong></p>
<p>名称：去空格函数——strip。
功能：去掉<string>字串中开头和结尾的空字符。
返回：返回被去掉空格的字符串值。 示例：</p>
<pre><code>$(strip a b c )</code></pre>
<p>​ 把字串“a b c ”去到开头和结尾的空格，结果是“a b c”。</p>
<p><strong>$(findstring <find>,<in>)</strong></p>
<p>名称：查找字符串函数——findstring。 功能：在字串<in>中查找<find>字串。
返回：如果找到，那么返回<find>，否则返回空字符串。 示例：</p>
<p>​ $(findstring a,a b c) ​ $(findstring a,b c)</p>
<p>​ 第一个函数返回“a”字符串，第二个返回“”字符串（空字符串）</p>
<p><strong>$(filter &lt;pattern...&gt;,<text>)</strong></p>
<p>名称：过滤函数——filter。
功能：以<pattern>模式过滤<text>字符串中的单词，保留符合模式<pattern>的单词。可以有多个模式。
返回：返回符合模式<pattern>的字串。 示例：</p>
<p>​ sources := foo.c bar.c baz.s ugh.h ​ foo: $(sources) ​ cc <span
class="math inline">\((filter %.c %.s,\)</span>(sources)) -o foo</p>
<p>​ <span class="math inline">\((filter %.c
%.s,\)</span>(sources))返回的值是“foo.c bar.c baz.s”。</p>
<p><strong>$(filter-out &lt;pattern...&gt;,<text>)</strong></p>
<p>名称：反过滤函数——filter-out。
功能：以<pattern>模式过滤<text>字符串中的单词，去除符合模式<pattern>的单词。可以有多个模式。
返回：返回不符合模式<pattern>的字串。 示例：</p>
<p>​ objects=main1.o foo.o main2.o bar.o ​ mains=main1.o main2.o ​<br />
​$(filter-out <span class="math inline">\((mains),\)</span>(objects))
返回值是“foo.o bar.o”。 ​<br />
<strong>$(sort <list>)</strong></p>
<p>名称：排序函数——sort。 功能：给字符串<list>中的单词排序（升序）。
返回：返回排序后的字符串。 示例：$(sort foo bar lose)返回“bar foo lose”
。 备注：sort函数会去掉<list>中相同的单词。</p>
<p><strong>$(word <n>,<text>)</strong></p>
<p>名称：取单词函数——word。
功能：取字符串<text>中第<n>个单词。（从一开始）
返回：返回字符串<text>中第<n>个单词。如果<n>比<text>中的单词数要大，那么返回空字符串。
示例：$(word 2, foo bar baz)返回值是“bar”。</p>
<p><strong>$(wordlist <s>,<e>,<text>)</strong></p>
<p>名称：取单词串函数——wordlist。
功能：从字符串<text>中取从<s>开始到<e>的单词串。<s>和<e>是一个数字。
返回：返回字符串<text>中从<s>到<e>的单词字串。如果<s>比<text>中的单词数要大，那么返回空字符串。如果<e>大于<text>的单词数，那么返回从<s>开始，到<text>结束的单词串。
示例： $(wordlist 2, 3, foo bar baz)返回值是“bar baz”。</p>
<p><strong>$(words <text>)</strong></p>
<p>名称：单词个数统计函数——words。
功能：统计<text>中字符串中的单词个数。 返回：返回<text>中的单词数。
示例：<span class="math inline">\((words, foo bar
baz)返回值是“3”。  备注：如果我们要取&lt;text&gt;中最后的一个单词，我们可以这样：\)</span>(word
$(words <text>),<text>)。</p>
<p><strong>$(firstword <text>)</strong></p>
<p>名称：首单词函数——firstword。 功能：取字符串<text>中的第一个单词。
返回：返回字符串<text>的第一个单词。 示例：<span
class="math inline">\((firstword foo
bar)返回值是“foo”。  备注：这个函数可以用word函数来实现：\)</span>(word
1,<text>)。</p>
<p>以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，举一个现实中应用的例子。我们知道，make使用“VPATH”变量来指定“依赖文件”的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数CFLAGS，如：</p>
<p>override CFLAGS += <span class="math inline">\((patsubst
%,-I%,\)</span>(subst :, ,$(VPATH)))</p>
<p>如果我们的“<span
class="math inline">\((VPATH)”值是“src:../headers”，那么“\)</span>(patsubst
%,-I%,<span class="math inline">\((subst :,
,\)</span>(VPATH)))”将返回“-Isrc
-I../headers”，这正是cc或gcc搜索头文件路径的参数。</p>
<h3 id="文件名操作函数"><strong>文件名操作函数</strong></h3>
<p>下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是一系列的文件名来对待。</p>
<p><strong>$(dir &lt;names...&gt;)</strong></p>
<p>名称：取目录函数——dir。
功能：从文件名序列<names>中取出目录部分。目录部分是指最后一个反斜杠（“/”）之前的部分。如果没有反斜杠，那么返回“./”。
返回：返回文件名序列<names>的目录部分。 示例： $(dir src/foo.c
hacks)返回值是“src/ ./”。</p>
<p><strong>$(notdir &lt;names...&gt;)</strong></p>
<p>名称：取文件函数——notdir。
功能：从文件名序列<names>中取出非目录部分。非目录部分是指最后一个反斜杠（“/”）之后的部分。
返回：返回文件名序列<names>的非目录部分。 示例： $(notdir src/foo.c
hacks)返回值是“foo.c hacks”。</p>
<p><strong>$(suffix &lt;names...&gt;)</strong></p>
<p>名称：取后缀函数——suffix。
功能：从文件名序列<names>中取出各个文件名的后缀。
返回：返回文件名序列<names>的后缀序列，如果文件没有后缀，则返回空字串。
示例：$(suffix src/foo.c src-1.0/bar.c hacks)返回值是“.c .c”。</p>
<p><strong>$(basename &lt;names...&gt;)</strong></p>
<p>名称：取前缀函数——basename。
功能：从文件名序列<names>中取出各个文件名的前缀部分。
返回：返回文件名序列<names>的前缀序列，如果文件没有前缀，则返回空字串。
示例：$(basename src/foo.c src-1.0/bar.c hacks)返回值是“src/foo
src-1.0/bar hacks”。</p>
<p><strong>$(addsuffix <suffix>,&lt;names...&gt;)</strong></p>
<p>名称：加后缀函数——addsuffix。
功能：把后缀<suffix>加到<names>中的每个单词后面。
返回：返回加过后缀的文件名序列。 示例：$(addsuffix .c,foo
bar)返回值是“foo.c bar.c”。</p>
<p><strong>$(addprefix <prefix>,&lt;names...&gt;)</strong></p>
<p>名称：加前缀函数——addprefix。
功能：把前缀<prefix>加到<names>中的每个单词后面。
返回：返回加过前缀的文件名序列。 示例：$(addprefix src/,foo
bar)返回值是“src/foo src/bar”。</p>
<p><strong>$(join <list1>,<list2>)</strong></p>
<p>名称：连接函数——join。
功能：把<list2>中的单词对应地加到<list1>的单词后面。如果<list1>的单词个数要比<list2>的多，那么，<list1>中的多出来的单词将保持原样。如果<list2>的单词个数要比<list1>多，那么，<list2>多出来的单词将被复制到<list2>中。
返回：返回连接过后的字符串。 示例：$(join aaa bbb , 111 222
333)返回值是“aaa111 bbb222 333”。</p>
<h3 id="foreach-函数">foreach 函数</h3>
<p>foreach函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的foreach函数几乎是仿照于Unix标准Shell（/bin/sh）中的for语句，或是C-Shell（/bin/csh）中的foreach语句而构建的。它的语法是：</p>
<p>​</p>
<p>$(foreach <var>,<list>,<text>)</p>
<p>​</p>
<p>这个函数的意思是，把参数<list>中的单词逐一取出放到参数<var>所指定的变量中，然后再执行<text>所包含的表达式。每一次<text>会返回一个字符串，循环过程中，<text>的所返回的每个字符串会以空格分隔，最后当整个循环结束时，<text>所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。</p>
<p>​</p>
<p>所以，<var>最好是一个变量名，<list>可以是一个表达式，而<text>中一般会使用<var>这个参数来依次枚举<list>中的单词。举个例子：</p>
<p>​</p>
<p>names := a b c d</p>
<p>files := <span class="math inline">\((foreach
n,\)</span>(names),$(n).o)</p>
<p>​</p>
<p>上面的例子中，<span
class="math inline">\((name)中的单词会被挨个取出，并存到变量“n”中，“\)</span>(n).o”每次根据“<span
class="math inline">\((n)”计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以，\)</span>(files)的值是“a.o
b.o c.o d.o”。</p>
<p>​</p>
<p>注意，foreach中的<var>参数是一个临时的局部变量，foreach函数执行完后，参数<var>的变量将不在作用，其作用域只在foreach函数当中。</p>
<p>​</p>
<p>​</p>
<h3 id="if-函数">if 函数</h3>
<p>if函数很像GNU的make所支持的条件语句——ifeq（参见前面所述的章节），if函数的语法是：</p>
<p>$(if <condition>,<then-part>)</p>
<p>$(if <condition>,<then-part>,<else-part>)</p>
<p>可见，if函数可以包含“else”部分，或是不含。即if函数的参数可以是两个，也可以是三个。<condition>参数是if的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，<then-part>会被计算，否则<else-part>会被计算。</p>
<p>而if函数的返回值是，如果<condition>为真（非空字符串），那个<then-part>会是整个函数的返回值，如果<condition>为假（空字符串），那么<else-part>会是整个函数的返回值，此时如果<else-part>没有被定义，那么，整个函数返回空字串。</p>
<p>​</p>
<p>所以，<then-part>和<else-part>只会有一个被计算。</p>
<p>​</p>
<h3 id="call函数">call函数</h3>
<p>​</p>
<p>call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用call函数来向这个表达式传递参数。其语法是：</p>
<p>​</p>
<p>$(call <expression>,<parm1>,<parm2>,<parm3>...)</p>
<p>​</p>
<p>当make执行这个函数时，<expression>参数中的变量，如<span
class="math inline">\((1)，\)</span>(2)，$(3)等，会被参数<parm1>，<parm2>，<parm3>依次取代。而<expression>的返回值就是call函数的返回值。例如：</p>
<p>reverse = $(1) $(2)</p>
<p>foo = $(call reverse,a,b)</p>
<p>那么，foo的值就是“a
b”。当然，参数的次序是可以自定义的，不一定是顺序的，如：</p>
<p>​</p>
<p>reverse = $(2) $(1)</p>
<p>foo = $(call reverse,a,b)</p>
<p>此时的foo的值就是“b a”。</p>
<p>​</p>
<p>​</p>
<h3 id="origin函数">origin函数</h3>
<p>origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是：</p>
<p>​</p>
<p>$(origin <variable>)</p>
<p>​</p>
<p>注意，<variable>是变量的名字，不应该是引用。所以你最好不要在<variable>中使用“$”字符。Origin函数会以其返回值来告诉你这个变量的“出生情况”，下面，是origin函数的返回值:</p>
<p>​</p>
<p>“undefined”</p>
<p>如果<variable>从来没有定义过，origin函数返回这个值“undefined”。</p>
<p>​</p>
<p>“default”</p>
<p>如果<variable>是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。</p>
<p>​</p>
<p>“environment”</p>
<p>如果<variable>是一个环境变量，并且当Makefile被执行时，“-e”参数没有被打开。</p>
<p>​</p>
<p>“file”</p>
<p>如果<variable>这个变量被定义在Makefile中。</p>
<p>​</p>
<p>“command line”</p>
<p>如果<variable>这个变量是被命令行定义的。</p>
<p>​</p>
<p>“override”</p>
<p>如果<variable>是被override指示符重新定义的。</p>
<p>​</p>
<p>“automatic”</p>
<p>如果<variable>是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。</p>
<p>​</p>
<p>这些信息对于我们编写Makefile是非常有用的，例如，假设我们有一个Makefile其包了一个定义文件Make.def，在Make.def中定义了一个变量“bletch”，而我们的环境中也有一个环境变量“bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的Makefile中，我们可以这样写：</p>
<p>​</p>
<p>ifdef bletch</p>
<p>ifeq "$(origin bletch)" "environment"</p>
<p>bletch = barf, gag, etc.</p>
<p>endif</p>
<p>endif</p>
<p>​</p>
<p>当然，你也许会说，使用override关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用override是可以达到这样的效果，可是override过于粗暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的。</p>
<p>​</p>
<p>​</p>
<h3 id="shell函数">shell函数</h3>
<p>​</p>
<p>shell函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号“`”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：</p>
<p>​</p>
<p>contents := $(shell cat foo)</p>
<p>​</p>
<p>files := $(shell echo *.c)</p>
<p>​</p>
<p>注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。</p>
<p>​</p>
<p>​</p>
<h3 id="控制make的函数">控制make的函数</h3>
<p>​</p>
<p>make提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。</p>
<p>​</p>
<p><strong>$(error &lt;text ...&gt;)</strong></p>
<p>​</p>
<p>产生一个致命的错误，&lt;text
...&gt;是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。例如：</p>
<p>​</p>
<p>示例一：</p>
<p>ifdef ERROR_001</p>
<p>$(error error is $(ERROR_001))</p>
<p>endif</p>
<p>​</p>
<p>示例二：</p>
<p>ERR = $(error found an error!)</p>
<p>.PHONY: err</p>
<p>err: ; $(ERR)</p>
<p>​</p>
<p>示例一会在变量ERROR_001定义了后执行时产生error调用，而示例二则在目录err被执行时才发生error调用。</p>
<p>​</p>
<p><strong>$(warning &lt;text ...&gt;)</strong></p>
<p>​</p>
<p>这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。</p>
<h2 id="九.make-的运行">九.make 的运行</h2>
<p>一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的makefile来执行，一切都是自动的。但也有时你也许只想让make重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。本章节就是讲述如何使用make命令的。</p>
<h3 id="make的退出码"><strong>make的退出码</strong></h3>
<p>make命令执行后有三个退出码：</p>
<p>0 —— 表示成功执行。 1 —— 如果make运行时出现任何错误，其返回1。 2 ——
如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。</p>
<p>Make的相关参数我们会在后续章节中讲述。</p>
<h3 id="指定makefile"><strong>指定Makefile</strong></h3>
<p>前面我们说过，GNU
make找寻默认的Makefile的规则是在当前目录下依次找三个文件——“GNUmakefile”、“makefile”和“Makefile”。其按顺序找这三个文件，一旦找到，就开始读取这个文件并执行。</p>
<p>当前，我们也可以给make命令指定一个特殊名字的Makefile。要达到这个功能，我们要使用make的“-f”或是“--file”参数（“--makefile”参数也行）。例如，我们有个makefile的名字是“hchen.mk”，那么，我们可以这样来让make来执行这个文件：</p>
<p>make –f hchen.mk</p>
<p>如果在make的命令行是，你不只一次地使用了“-f”参数，那么，所有指定的makefile将会被连在一起传递给make执行。</p>
<h3 id="指定目标"><strong>指定目标</strong></h3>
<p>一般来说，make的最终目标是makefile中的第一个目标，而其它目标一般是由这个目标连带出来的。这是make的默认行为。当然，一般来说，你的makefile中的第一个目标是由许多个目标组成，你可以指示make，让其完成你所指定的目标。要达到这一目的很简单，需在make命令后直接跟目标的名字就可以完成（如前面提到的“make
clean”形式）</p>
<p>任何在makefile中的目标都可以被指定成终极目标，但是除了以“-”打头，或是包含了“=”的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。甚至没有被我们明确写出来的目标也可以成为make的终极目标，也就是说，只要make可以找到其隐含规则推导规则，那么这个隐含目标同样可以被指定成终极目标。</p>
<p>有一个make的环境变量叫“MAKECMDGOALS”，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子：</p>
<p>sources = foo.c bar.c ifneq ( $(MAKECMDGOALS),clean) include
$(sources:.c=.d) endif</p>
<p>基于上面的这个例子，只要我们输入的命令不是“make
clean”，那么makefile会自动包含“foo.d”和“bar.d”这两个makefile。</p>
<p>使用指定终极目标的方法可以很方便地让我们编译我们的程序，例如下面这个例子：</p>
<p>.PHONY: all all: prog1 prog2 prog3 prog4</p>
<p>从这个例子中，我们可以看到，这个makefile中有四个需要编译的程序——“prog1”，
“prog2”， “prog3”和 “prog4”，我们可以使用“make
all”命令来编译所有的目标（如果把all置成第一个目标，那么只需执行“make”），我们也可以使用“make
prog2”来单独编译目标“prog2”。</p>
<p>即然make可以指定所有makefile中的目标，那么也包括“伪目标”，于是我们可以根据这种性质来让我们的makefile根据指定的不同的目标来完成不同的事。在Unix世界中，软件发布时，特别是GNU这种开源软件的发布时，其makefile都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的makefile中的目标。</p>
<p>“all” 这个伪目标是所有目标的目标，其功能一般是编译所有的目标。
“clean” 这个伪目标功能是删除所有被make创建的文件。 “install”
这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。
“print” 这个伪目标的功能是例出改变过的源文件。 “tar”
这个伪目标功能是把源程序打包备份。也就是一个tar文件。 “dist”
这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。
“TAGS” 这个伪目标功能是更新所有的目标，以备完整地重编译使用。
“check”和“test” 这两个伪目标一般用来测试makefile的流程。</p>
<p>当然一个项目的makefile中也不一定要书写这样的目标，这些东西都是GNU的东西，但是我想，GNU搞出这些东西一定有其可取之处（等你的UNIX下的程序文件一多时你就会发现这些功能很有用了），这里只不过是说明了，如果你要书写这种功能，最好使用这种名字命名你的目标，这样规范一些，规范的好处就是——不用解释，大家都明白。而且如果你的makefile中有这些功能，一是很实用，二是可以显得你的makefile很专业（不是那种初学者的作品）。</p>
<h3 id="检查规则"><strong>检查规则</strong></h3>
<p>有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用make命令的下述参数：</p>
<p>“-n” “--just-print” “--dry-run” “--recon”
不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试makefile很有用处。</p>
<p>“-t” “--touch”
这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。</p>
<p>“-q” “--question”
这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。</p>
<p>“-W <file>” “--what-if=<file>” “--assume-new=<file>”
“--new-file=<file>”
这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令。</p>
<p>另外一个很有意思的用法是结合“-p”和“-v”来输出makefile被执行时的信息（这个将在后面讲述）。</p>
<h3 id="make的参数"><strong>make的参数</strong></h3>
<p>下面列举了所有GNU make
3.80版的参数定义。其它版本和产商的make大同小异，不过其它产商的make的具体参数还是请参考各自的产品文档。</p>
<p>“-b” “-m” 这两个参数的作用是忽略和其它版本make的兼容性。</p>
<p>“-B” “--always-make” 认为所有的目标都需要更新（重编译）。</p>
“-C
<dir>
” “--directory=
<dir>
<p>”
指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make
–C ~hchen/test –C prog”等价于“make –C ~hchen/test/prog”。</p>
<p>“—debug[=<options>]”
输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是<options>的取值：
a —— 也就是all，输出所有的调试信息。（会非常的多） b ——
也就是basic，只输出简单的调试信息。即输出不需要重编译的目标。 v ——
也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等。
i —— 也就是implicit，输出所以的隐含规则。 j ——
也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等。 m ——
也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息。</p>
<p>“-d” 相当于“--debug=a”。</p>
<p>“-e” “--environment-overrides”
指明环境变量的值覆盖makefile中定义的变量的值。</p>
<p>“-f=<file>” “--file=<file>” “--makefile=<file>”
指定需要执行的makefile。</p>
<p>“-h” “--help” 显示帮助信息。</p>
<p>“-i” “--ignore-errors” 在执行时忽略所有的错误。</p>
“-I
<dir>
” “--include-dir=
<dir>
<p>”
指定一个被包含makefile的搜索目标。可以使用多个“-I”参数来指定多个目录。</p>
<p>“-j [<jobsnum>]” “--jobs[=<jobsnum>]”
指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的“-j”参数，那么仅最后一个“-j”才是有效的。（注意这个参数在MS-DOS中是无用的）</p>
<p>“-k” “--keep-going”
出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。</p>
<p>“-l <load>” “--load-average[=&lt;load]” “—max-load[=<load>]”
指定make运行命令的负载。</p>
<p>“-n” “--just-print” “--dry-run” “--recon”
仅输出执行过程中的命令序列，但并不执行。</p>
<p>“-o <file>” “--old-file=<file>” “--assume-old=<file>”
不重新生成的指定的<file>，即使这个目标的依赖文件新于它。</p>
<p>“-p” “--print-data-base”
输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。如果你只是想输出信息而不想执行makefile，你可以使用“make
-qp”命令。如果你想查看执行makefile前的预设变量和规则，你可以使用“make –p
–f
/dev/null”。这个参数输出的信息会包含着你的makefile文件的文件名和行号，所以，用这个参数来调试你的makefile会是很有用的，特别是当你的环境变量很复杂的时候。</p>
<p>“-q” “--question”
不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说明有错误发生。</p>
<p>“-r” “--no-builtin-rules” 禁止make使用任何隐含规则。</p>
<p>“-R” “--no-builtin-variabes”
禁止make使用任何作用于变量上的隐含规则。</p>
<p>“-s” “--silent” “--quiet” 在命令运行时不输出命令的输出。</p>
<p>“-S” “--no-keep-going” “--stop”
取消“-k”选项的作用。因为有些时候，make的选项是从环境变量“MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效。</p>
<p>“-t” “--touch”
相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。</p>
<p>“-v” “--version” 输出make程序的版本、版权等关于make的信息。</p>
<p>“-w” “--print-directory”
输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。</p>
<p>“--no-print-directory” 禁止“-w”选项。</p>
<p>“-W <file>” “--what-if=<file>” “--new-file=<file>”
“--assume-file=<file>”
假定目标<file>需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得<file>的修改时间为当前时间。</p>
<p>“--warn-undefined-variables”
只要make发现有未定义的变量，那么就输出警告信息。</p>
<h2 id="十.隐含规则">十.隐含规则</h2>
<p>在我们使用Makefile时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译C/C++的源程序为中间目标文件（Unix下是[.o]文件，Windows下是[.obj]文件）。本章讲述的就是一些在Makefile中的“隐含的”，早先约定了的，不需要我们再写出来的规则。</p>
<p>“隐含规则”也就是一种惯例，make会按照这种“惯例”心照不喧地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把[.c]文件编译成[.o]文件这一规则，你根本就不用写出来，make会自动推导出这种规则，并生成我们需要的[.o]文件。</p>
<p>“隐含规则”会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量“CFLAGS”可以控制编译时的编译器参数。</p>
<p>我们还可以通过“模式规则”的方式写下自己的隐含规则。用“后缀规则”来定义隐含规则会有许多的限制。使用“模式规则”会更回得智能和清楚，但“后缀规则”可以用来保证我们Makefile的兼容性。
我们了解了“隐含规则”，可以让其为我们更好的服务，也会让我们知道一些“约定俗成”了的东西，而不至于使得我们在运行Makefile时出现一些我们觉得莫名其妙的东西。当然，任何事物都是矛盾的，水能载舟，亦可覆舟，所以，有时候“隐含规则”也会给我们造成不小的麻烦。只有了解了它，我们才能更好地使用它。</p>
<h3 id="使用隐含规则">使用隐含规则</h3>
<p>如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是make事先约定好的一些东西。例如，我们有下面的一个Makefile：</p>
<p>foo : foo.o bar.o cc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)</p>
<p>我们可以注意到，这个Makefile中并没有写下如何生成foo.o和bar.o这两目标的规则和命令。因为make的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。</p>
<p>make会在自己的“隐含规则”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make调用的隐含规则是，把[.o]的目标的依赖文件置成[.c]，并使用C的编译命令“cc
–c $(CFLAGS)
[.c]”来生成[.o]的目标。也就是说，我们完全没有必要写下下面的两条规则：</p>
<p>foo.o : foo.c cc –c foo.c $(CFLAGS) bar.o : bar.c cc –c bar.c
$(CFLAGS)</p>
<p>因为，这已经是“约定”好了的事了，make和我们约定好了用C编译器“cc”生成[.o]文件的规则，这就是隐含规则。</p>
<p>当然，如果我们为[.o]文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。</p>
<p>还有，在make的“隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则（没有命令）：</p>
<p>foo.o : foo.p</p>
<p>依赖文件“foo.p”（Pascal程序的源文件）有可能变得没有意义。如果目录下存在了“foo.c”文件，那么我们的隐含规则一样会生效，并会通过“foo.c”调用C的编译器生成foo.o文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后，所以，make找到可以生成foo.o的C的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出“依赖规则”，而不写命令。</p>
<h3 id="隐含规则一览">隐含规则一览</h3>
<p>这里我们将讲述所有预先设置（也就是make内建）的隐含规则，如果我们不明确地写下规则，那么，make就会在这些规则中寻找所需要规则和命令。当然，我们也可以使用make的参数“-r”或“--no-builtin-rules”选项来取消所有的预设置的隐含规则。</p>
<p>当然，即使是我们指定了“-r”参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了“后缀规则”来定义的，所以，只要隐含规则中有“后缀列表”（也就一系统定义在目标.SUFFIXES的依赖目标），那么隐含规则就会生效。默认的后缀列表是：.out,
.a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym,
.def, .h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web,
.sh, .elc, .el。具体的细节，我们会在后面讲述。</p>
<p>还是先来看一看常用的隐含规则吧。</p>
<p><strong>1、编译C程序的隐含规则。</strong>
“<n>.o”的目标的依赖目标会自动推导为“<n>.c”，并且其生成命令是“$(CC) –c
$(CPPFLAGS) $(CFLAGS)”</p>
<p><strong>2、编译C++程序的隐含规则。</strong>
“<n>.o”的目标的依赖目标会自动推导为“<n>.cc”或是“<n>.C”，并且其生成命令是“$(CXX)
–c $(CPPFLAGS)
$(CFLAGS)”。（建议使用“.cc”作为C++源文件的后缀，而不是“.C”）</p>
<p><strong>3、编译Pascal程序的隐含规则。
</strong>“<n>.o”的目标的依赖目标会自动推导为“<n>.p”，并且其生成命令是“$(PC)
–c $(PFLAGS)”。</p>
<p><strong>4、编译Fortran/Ratfor程序的隐含规则。
</strong>“<n>.o”的目标的依赖目标会自动推导为“<n>.r”或“<n>.F”或“<n>.f”，并且其生成命令是:
“.f” “$(FC) –c <span class="math inline">\((FFLAGS)”  “.F”
“\)</span>(FC) –c $(FFLAGS) <span
class="math inline">\((CPPFLAGS)”  “.f” “\)</span>(FC) –c $(FFLAGS)
$(RFLAGS)”</p>
<p><strong>5、预处理Fortran/Ratfor程序的隐含规则。</strong>
“<n>.f”的目标的依赖目标会自动推导为“<n>.r”或“<n>.F”。这个规则只是转换Ratfor或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：
“.F” “$(FC) –F $(CPPFLAGS) <span class="math inline">\((FFLAGS)”  “.r”
“\)</span>(FC) –F $(FFLAGS) $(RFLAGS)”</p>
<p><strong>6、编译Modula-2程序的隐含规则。
</strong>“<n>.sym”的目标的依赖目标会自动推导为“<n>.def”，并且其生成命令是：“$(M2C)
$(M2FLAGS) <span class="math inline">\((DEFFLAGS)”。“&lt;n.o&gt;”
的目标的依赖目标会自动推导为“&lt;n&gt;.mod”，并且其生成命令是：“\)</span>(M2C)
$(M2FLAGS) $(MODFLAGS)”。</p>
<p><strong>7、汇编和汇编预处理的隐含规则。 </strong>“<n>.o”
的目标的依赖目标会自动推导为“<n>.s”，默认使用编译品“as”，并且其生成命令是：“$(AS)
<span class="math inline">\((ASFLAGS)”。“&lt;n&gt;.s”
的目标的依赖目标会自动推导为“&lt;n&gt;.S”，默认使用C预编译器“cpp”，并且其生成命令是：“\)</span>(AS)
$(ASFLAGS)”。</p>
<p><strong>8、链接Object文件的隐含规则。</strong>
“<n>”目标依赖于“<n>.o”，通过运行C的编译器来运行链接程序生成（一般是“ld”），其生成命令是：“$(CC)
$(LDFLAGS) <n>.o $(LOADLIBES)
$(LDLIBS)”。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则：</p>
<p>x : y.o z.o</p>
<p>并且“x.c”、“y.c”和“z.c”都存在时，隐含规则将执行如下命令：</p>
<p>cc -c x.c -o x.o cc -c y.c -o y.o cc -c z.c -o z.o cc x.o y.o z.o -o
x rm -f x.o rm -f y.o rm -f z.o</p>
<p>如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。</p>
<p><strong>9、Yacc C程序时的隐含规则。
</strong>“<n>.c”的依赖文件被自动推导为“n.y”（Yacc生成的文件），其生成命令是：“$(YACC)
$(YFALGS)”。（“Yacc”是一个语法分析器，关于其细节请查看相关资料）</p>
<p><strong>10、Lex C程序时的隐含规则。</strong>
“<n>.c”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX)
$(LFALGS)”。（关于“Lex”的细节请查看相关资料）</p>
<p><strong>11、Lex Ratfor程序时的隐含规则。</strong>
“<n>.r”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX)
$(LFALGS)”。</p>
<p><strong>12、从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。</strong>
“<n>.ln”
（lint生成的文件）的依赖文件被自动推导为“n.c”，其生成命令是：“$(LINT)
$(LINTFALGS) $(CPPFLAGS) -i”。对于“<n>.y”和“<n>.l”也是同样的规则。</p>
<h3 id="隐含规则使用的变量">隐含规则使用的变量</h3>
<p>在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的“-R”或“--no–builtin-variables”参数来取消你所定义的变量对隐含规则的作用。</p>
<p>例如，第一条隐含规则——编译C程序的隐含规则的命令是“$(CC) –c $(CFLAGS)
<span
class="math inline">\((CPPFLAGS)”。Make默认的编译命令是“cc”，如果你把变量“\)</span>(CC)”重定义成“gcc”，把变量“$(CFLAGS)”重定义成“-g”，那么，隐含规则中的命令全部会以“gcc
–c -g $(CPPFLAGS)”的样子来执行了。</p>
<p>我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如“CC”；一种是参数相的关，如“CFLAGS”。下面是所有隐含规则中会用到的变量：</p>
<p><strong>1、关于命令的变量。</strong></p>
<p>AR 函数库打包程序。默认命令是“ar”。 AS
汇编语言编译程序。默认命令是“as”。 CC C语言编译程序。默认命令是“cc”。
CXX C++语言编译程序。默认命令是“g++”。 CO 从
RCS文件中扩展文件程序。默认命令是“co”。 CPP
C程序的预处理器（输出是标准输出设备）。默认命令是“$(CC) –E”。 FC Fortran
和 Ratfor 的编译器和预处理程序。默认命令是“f77”。 GET
从SCCS文件中扩展文件的程序。默认命令是“get”。 LEX
Lex方法分析器程序（针对于C或Ratfor）。默认命令是“lex”。 PC
Pascal语言编译程序。默认命令是“pc”。 YACC
Yacc文法分析器（针对于C程序）。默认命令是“yacc”。 YACCR
Yacc文法分析器（针对于Ratfor程序）。默认命令是“yacc –r”。 MAKEINFO
转换Texinfo源文件（.texi）到Info文件程序。默认命令是“makeinfo”。 TEX
从TeX源文件创建TeX DVI文件的程序。默认命令是“tex”。 TEXI2DVI
从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是“texi2dvi”。 WEAVE
转换Web到TeX的程序。默认命令是“weave”。 CWEAVE 转换C Web 到
TeX的程序。默认命令是“cweave”。 TANGLE
转换Web到Pascal语言的程序。默认命令是“tangle”。 CTANGLE 转换C Web 到
C。默认命令是“ctangle”。 RM 删除文件命令。默认命令是“rm –f”。</p>
<p><strong>2、关于命令参数的变量 </strong>
下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。</p>
<p>ARFLAGS 函数库打包程序AR命令的参数。默认值是“rv”。 ASFLAGS
汇编语言编译器参数。（当明显地调用“.s”或“.S”文件时）。 CFLAGS
C语言编译器参数。 CXXFLAGS C++语言编译器参数。 COFLAGS RCS命令参数。
CPPFLAGS C预处理器参数。（ C 和 Fortran 编译器也会用到）。 FFLAGS
Fortran语言编译器参数。 GFLAGS SCCS “get”程序参数。 LDFLAGS
链接器参数。（如：“ld”） LFLAGS Lex文法分析器参数。 PFLAGS
Pascal语言编译器参数。 RFLAGS Ratfor 程序的Fortran 编译器参数。 YFLAGS
Yacc文法分析器参数。</p>
<h3 id="隐含规则链">隐含规则链</h3>
<p>有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个[.o]的文件生成，可能会是先被Yacc的[.y]文件先成[.c]，然后再被C的编译器生成。我们把这一系列的隐含规则叫做“隐含规则链”。</p>
<p>在上面的例子中，如果文件[.c]存在，那么就直接调用C的编译器的隐含规则，如果没有[.c]文件，但有一个[.y]文件，那么Yacc的隐含规则会被调用，生成[.c]文件，然后，再调用C编译的隐含规则最终由[.c]生成[.o]文件，达到目标。</p>
<p>我们把这种[.c]的文件（或是目标），叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少，其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成？怎么我的makefile发疯了？</p>
<p>在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以“rm
-f”删除。</p>
<p>通常，一个被makefile指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标“.INTERMEDIATE”来强制声明。（如：.INTERMEDIATE
： mid ）</p>
<p>你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标“.SECONDARY”来强制声明（如：.SECONDARY
:
sec）。你还可以把你的目标，以模式的方式来指定（如：%.o）成伪目标“.PRECIOUS”的依赖目标，以保存被隐含规则所生成的中间文件。</p>
<p>在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。</p>
<p>Make会优化一些特殊的隐含规则，而不生成中间文件。如，从文件“foo.c”生成目标程序“foo”，按道理，make会编译生成中间文件“foo.o”，然后链接成“foo”，但在实际情况下，这一动作可以被一条“cc”的命令完成（cc
–o foo foo.c），于是优化过的规则就不会生成中间文件。</p>
<h3 id="定义模式规则">定义模式规则</h3>
<p>你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有<code>%</code>字符。<code>%</code>的意思是表示一个或多个任意字符。在依赖目标中同样可以使用<code>%</code>，只是依赖目标中的<code>%</code>的取值，取决于其目标。</p>
<p>有一点需要注意的是，<code>%</code>的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入Makefile时，而模式规则中的<code>%</code>则发生在运行时。</p>
<p><strong>1、模式规则介绍</strong></p>
<p>模式规则中，至少在规则的目标定义中要包含<code>%</code>，否则，就是一般的规则。目标中的<code>%</code>定义表示对文件名的匹配，<code>%</code>表示长度任意的非空字符串。例如：<code>%.c</code>表示以<code>.c</code>结尾的文件名（文件名的长度至少为3），而<code>s.%.c</code>则表示以<code>s.</code>开头，<code>.c</code>结尾的文件名（文件名的长度至少为5）。</p>
<p>如果<code>%</code>定义在目标中，那么，目标中的<code>%</code>的值决定了依赖目标中的<code>%</code>的值，也就是说，目标中的模式的<code>%</code>决定了依赖目标中<code>%</code>的样子。例如有一个模式规则如下：</p>
<p>%.o : %.c ; &lt;command ......&gt;</p>
<p>其含义是，指出了怎么从所有的[.c]文件生成相应的[.o]文件的规则。如果要生成的目标是<code>a.o b.o</code>，那么<code>%c</code>就是<code>a.c b.c</code>。</p>
<p>一旦依赖目标中的<code>%</code>模式被确定，那么，make会被要求去匹配当前目录下所有的文件名，一旦找到，make就会规则下的命令，所以，在模式规则中，目标可能会是多个的，如果有模式匹配出多个目标，make就会产生所有的模式目标，此时，make关心的是依赖的文件名和生成目标的命令这两件事。</p>
<p><strong>2、模式规则示例</strong></p>
<p>下面这个例子表示了,把所有的[.c]文件都编译成[.o]文件.</p>
<p>%.o : %.c $(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@</p>
<p>其中，<code>$@</code>表示所有的目标的挨个值，<code>$&lt;</code>表示了所有依赖目标的挨个值。这些奇怪的变量我们叫<code>自动化变量</code>，后面会详细讲述。</p>
<p>下面的这个例子中有两个目标是模式的：</p>
<p>%.tab.c %.tab.h: %.y bison -d $&lt;</p>
<p>这条规则告诉make把所有的[.y]文件都以<code>bison -d  &lt;n&gt;.y</code>执行，然后生成<code>&lt;n&gt;.tab.c</code>和<code>&lt;n&gt;.tab.h</code>文件。（其中，<code>&lt;n&gt;</code>表示一个任意字符串）。如果我们的执行程序<code>foo</code>依赖于文件<code>parse.tab.o</code>和<code>scan.o</code>，并且文件<code>scan.o</code>依赖于文件<code>parse.tab.h</code>，如果<code>parse.y</code>文件被更新了，那么根据上述的规则，<code>bison -d  parse.y</code>就会被执行一次，于是，<code>parse.tab.o</code>和<code>scan.o</code>的依赖文件就齐了。（假设，<code>parse.tab.o</code>由<code>parse.tab.c</code>生成，和<code>scan.o</code>由<code>scan.c</code>生成，而<code>foo</code>由<code>parse.tab.o</code>和<code>scan.o</code>链接生成，而且foo和其[.o]文件的依赖关系也写好，那么，所有的目标都会得到满足）</p>
<p><strong>3、自动化变量</strong></p>
<p>在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。</p>
<p>自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。</p>
<p>下面是所有的自动化变量及其说明：</p>
<p>**<span
class="math inline">\(@**  表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，`\)</span>@`就是匹配于目标中模式定义的集合。</p>
<p>**<span
class="math inline">\(%**  仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是`foo.a(bar.o)`，那么，`\)</span>%<code>就是</code>bar.o<code>，</code>$@<code>就是</code>foo.a`。如果目标不是函数库文件（Unix下是[.a]，Windows下是[.lib]），那么，其值为空。</p>
<p>**<span
class="math inline">\(&lt;**  依赖目标中的第一个目标名字。如果依赖目标是以模式（即`%`）定义的，那么`\)</span>&lt;`将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</p>
<p><strong>$?</strong> 所有比目标新的依赖目标的集合。以空格分隔。</p>
<p><strong>$^</strong>
所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。</p>
<p>**<span
class="math inline">\(+**  这个变量很像`\)</span>^`，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</p>
<p>**<span
class="math inline">\(\***  这个变量表示目标模式中`%`及其之前的部分。如果目标是`dir/a.foo.b`，并且目标的模式是`a.%.b`，那么，`\)</span><em><code>的值就是</code>dir/a.foo<code>。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么</code><span
class="math inline">\(*`也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么`\)</span></em><code>就是除了后缀的那一部分。例如：如果目标是</code>foo.c<code>，因为</code>.c<code>是make所能识别的后缀名，所以，</code><span
class="math inline">\(*`的值就是`foo`。这个特性是GNU
make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用`\)</span><em><code>，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么</code>$</em>`就是空值。</p>
<p>当你希望只对更新过的依赖文件进行操作时，<code>$?</code>在显式规则中很有用，例如，假设有一个函数库文件叫<code>lib</code>，其由其它几个object文件更新。那么把object文件打包的比较有效率的Makefile规则是：</p>
<p>lib : foo.o bar.o lose.o win.o ar r lib $?</p>
<p>在上述所列出来的自动量变量中。四个变量（<span
class="math inline">\(@、\)</span>&lt;、<span
class="math inline">\(%、\)</span>*）在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上<code>D</code>或<code>F</code>字样。这是GNU
make中老版本的特性，在新版本中，我们使用函数<code>dir</code>或<code>notdir</code>就可以做到了。<code>D</code>的含义就是Directory，就是目录，<code>F</code>的含义就是File，就是文件。</p>
<p>下面是对于上面的七个变量分别加上<code>D</code>或是<code>F</code>的含义：</p>
<p>**<span
class="math inline">\((@D)**  表示`\)</span>@<code>的目录部分（不以斜杠作为结尾），如果</code><span
class="math inline">\(@`值是`dir/foo.o`，那么`\)</span>(<span
class="citation"
data-cites="D">@D</span>)<code>就是</code>dir<code>，而如果</code>$@<code>中没有包含斜杠的话，其值就是</code>.`（当前目录）。</p>
<p>**<span
class="math inline">\((@F)**  表示`\)</span>@<code>的文件部分，如果</code><span
class="math inline">\(@`值是`dir/foo.o`，那么`\)</span>(<span
class="citation"
data-cites="F">@F</span>)<code>就是</code>foo.o<code>，</code><span
class="math inline">\((@F)`相当于函数`\)</span>(notdir $@)`。</p>
<p><strong><code>$(\*D)</code> <code>$(\*F)</code></strong>
和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子，<code>$(*D)</code>返回<code>dir</code>，而<code>$(*F)</code>返回<code>foo</code></p>
<p><strong><code>$(%D)</code> <code>$(%F)</code></strong>
分别表示了函数包文件成员的目录部分和文件部分。这对于形同<code>archive(member)</code>形式的目标中的<code>member</code>中包含了不同的目录很有用。</p>
<p><strong><code>$(&lt;D)</code> <code>$(&lt;F)</code></strong>
分别表示依赖文件的目录部分和文件部分。</p>
<p><strong><code>$(^D)</code> <code>$(^F)</code></strong>
分别表示所有依赖文件的目录部分和文件部分。（无相同的）</p>
<p><strong><code>$(+D)</code> <code>$(+F)</code></strong>
分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）</p>
<p><strong><code>$(?D)</code> <code>$(?F)</code></strong>
分别表示被更新的依赖文件的目录部分和文件部分。</p>
<p>最后想提醒一下的是，对于<code>$&lt;</code>，为了避免产生不必要的麻烦，我们最好给<span
class="math inline">\(后面的那个特定字符都加上圆括号，比如，`\)</span>(&lt;)<code>就要比</code>$&lt;`要好一些。</p>
<p>还得要注意的是，这些变量只使用在规则的命令中，而且一般都是<code>显式规则</code>和<code>静态模式规则</code>（参见前面<code>书写规则</code>一章）。其在隐含规则中并没有意义。</p>
<p><strong>4、模式的匹配</strong></p>
<p>一般来说，一个目标的模式有一个有前缀或是后缀的<code>%</code>，或是没有前后缀，直接就是一个<code>%</code>。因为<code>%</code>代表一个或多个字符，所以在定义好了的模式中，我们把<code>%</code>所匹配的内容叫做<code>茎</code>，例如<code>%.c</code>所匹配的文件<code>test.c</code>中<code>test</code>就是<code>茎</code>。因为在目标和依赖目标中同时有<code>%</code>时，依赖目标的<code>茎</code>会传给目标，当做目标中的<code>茎</code>。</p>
<p>当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行<code>茎</code>的传递时，我们需要知道这个步骤。例如有一个模式<code>e%t</code>，文件<code>src/eat</code>匹配于该模式，于是<code>src/a</code>就是其<code>茎</code>，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式<code>c%r</code>，那么，目标就是<code>src/car</code>。（<code>茎</code>被传递）</p>
<p><strong>5、重载内建隐含规则</strong></p>
<p>你可以重载内建的隐含规则（或是定义一个全新的），例如你可以重新构造和内建隐含规则不同的命令，如：</p>
<p>%.o : %.c $(CC) -c $(CPPFLAGS) <span class="math inline">\((CFLAGS)
-D\)</span>(date)</p>
<p>你可以取消内建的隐含规则，只要不在后面写命令就行。如：</p>
<p>%.o : %.s</p>
<p>同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。</p>
<h3 id="老式风格的后缀规则">老式风格的后缀规则</h3>
<p>后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规则更强更清晰。为了和老版本的Makefile兼容，GNU
make同样兼容于这些东西。后缀规则有两种方式：<code>双后缀</code>和<code>单后缀</code>。</p>
<p>双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如<code>.c.o</code>相当于<code>%o : %c</code>。单后缀规则只定义一个后缀，也就是源文件的后缀。如<code>.c</code>相当于<code>% : %.c</code>。</p>
<p>后缀规则中所定义的后缀应该是make所认识的，如果一个后缀是make所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被make所认识，那就是双后缀规则。例如：<code>.c</code>和<code>.o</code>都是make所知道。因而，如果你定义了一个规则是<code>.c.o</code>那么其就是双后缀规则，意义就是<code>.c</code>是源文件的后缀，<code>.o</code>是目标文件的后缀。如下示例：</p>
<p>.c.o: $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;</p>
<p>后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如：</p>
<p>.c.o: foo.h $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;</p>
<p>这个例子，就是说，文件<code>.c.o</code>依赖于文件<code>foo.h</code>，而不是我们想要的这样：</p>
<p>%.o: %.c foo.h $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;</p>
<p>后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。</p>
<p>而要让make知道一些特定的后缀，我们可以使用伪目标<code>.SUFFIXES</code>来定义或是删除，如：</p>
<p>.SUFFIXES: .hack .win</p>
<p>把后缀.hack和.win加入后缀列表中的末尾。</p>
<p>.SUFFIXES: # 删除默认的后缀 .SUFFIXES: .c .o .h # 定义自己的后缀</p>
<p>先清楚默认后缀，后定义自己的后缀列表。</p>
<p>make的参数<code>-r</code>或<code>-no-builtin-rules</code>也会使用得默认的后缀列表为空。而变量<code>SUFFIXE</code>被用来定义默认的后缀列表，你可以用<code>.SUFFIXES</code>来改变后缀列表，但请不要改变变量<code>SUFFIXE</code>的值。</p>
<h3 id="隐含规则搜索算法">隐含规则搜索算法</h3>
<p>比如我们有一个目标叫
T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是<code>archive(member)</code>的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把<code>member</code>当作T来搜索。</p>
<p>1、把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是<code>src/foo.o</code>，那么，D就是<code>src/</code>，N就是<code>foo.o</code>）</p>
<p>2、创建所有匹配于T或是N的模式规则列表。</p>
<p>3、如果在模式规则列表中有匹配所有文件的模式，如<code>%</code>，那么从列表中移除其它的模式。</p>
<p>4、移除列表中没有命令的规则。</p>
<p>5、对于第一个在列表中的模式规则：
1）推导其<code>茎</code>S，S应该是T或是N匹配于模式中<code>%</code>非空的部分。
2）计算依赖文件。把依赖文件中的<code>%</code>都替换成<code>茎</code>S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。
3）测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫<code>理当存在</code>）
4）如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。</p>
<p>6、如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：
1）如果规则是终止规则，那就忽略它，继续下一条模式规则。
2）计算依赖文件。（同第5步） 3）测试所有的依赖文件是否存在或是理当存在。
4）对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。
5）如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。</p>
<p>7、如果没有隐含规则可以使用，查看<code>.DEFAULT</code>规则，如果有，采用，把<code>.DEFAULT</code>的命令给T使用。</p>
<p>一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。</p>
<h2 id="十一.使用make更新函数库文件">十一.使用make更新函数库文件</h2>
<p>函数库文件也就是对Object文件（程序编译的中间文件）的打包文件。在Unix下，一般是由命令<code>ar</code>来完成打包工作。</p>
<h3 id="函数库文件的成员"><strong>函数库文件的成员</strong></h3>
<p>一个函数库文件由多个文件组成。你可以以如下格式指定函数库文件及其组成：</p>
<p>archive(member)</p>
<p>这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了<code>ar</code>命令来服务的。如：</p>
<p>foolib(hack.o) : hack.o ar cr foolib hack.o</p>
<p>如果要指定多个member，那就以空格分开，如：</p>
<p>foolib(hack.o kludge.o)</p>
<p>其等价于：</p>
<p>foolib(hack.o) foolib(kludge.o)</p>
<p>你还可以使用Shell的文件通配符来定义，如：</p>
<p>foolib(*.o)</p>
<h3 id="函数库成员的隐含规则"><strong>函数库成员的隐含规则</strong></h3>
<p>当make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是<code>a(m)</code>形式的，其会把目标变成<code>(m)</code>。于是，如果我们的成员是<code>%.o</code>的模式定义，并且如果我们使用<code>make  foo.a(bar.o)</code>的形式调用Makefile时，隐含规则会去找<code>bar.o</code>的规则，如果没有定义bar.o的规则，那么内建隐含规则生效，make会去找bar.c文件来生成bar.o，如果找得到的话，make执行的命令大致如下：</p>
<p>cc -c bar.c -o bar.o ar r foo.a bar.o rm -f bar.o</p>
<p>还有一个变量要注意的是<code>$%</code>，这是专属函数库文件的自动化变量，有关其说明请参见<code>自动化变量</code>一节。</p>
<h3 id="函数库文件的后缀规则"><strong>函数库文件的后缀规则</strong></h3>
<p>你可以使用<code>后缀规则</code>和<code>隐含规则</code>来生成函数库打包文件，如：</p>
<p>.c.a: $(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $<em>.o $(AR) r $@
$</em>.o $(RM) $*.o</p>
<p>其等效于：</p>
<p>(%.o) : %.c $(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $<em>.o $(AR) r
$@ $</em>.o $(RM) $*.o</p>
<h3 id="注意事项"><strong>注意事项</strong></h3>
<p>在进行函数库打包文件生成时，请小心使用make的并行机制（<code>-j</code>参数）。如果多个ar命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。所以，在make未来的版本中，应该提供一种机制来避免并行操作发生在函数打包文件上。</p>
<p>但就目前而言，你还是应该不要尽量不要使用<code>-j</code>参数。</p>
<p>WORK_DIR = /home/lzm/ysyx-workbench/nemu</p>
<p>BUILD_DIR = $(WORK_DIR)/build</p>

    </div>

    
    
    
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Makefile/" rel="tag"># Makefile</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/11/%E6%A2%85%E6%A3%AE%E8%9E%BA%E6%97%8B%E7%AE%97%E6%B3%95/" rel="prev" title="梅森旋转算法">
      <i class="fa fa-chevron-left"></i> 梅森旋转算法
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/11/20/%E6%80%BB%E7%BA%BF/" rel="next" title="总线">
      总线 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>
      
      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#makefile%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="nav-text">Makefile学习笔记</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#basename-names"><span class="nav-text">$(basename NAMES…)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#notdir-names"><span class="nav-text">$(notdir NAMES…)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#addprefix-%E5%89%8D%E7%BC%80-%E5%BE%85%E5%8A%A0%E5%89%8D%E7%BC%80%E7%9A%84"><span class="nav-text">$(addprefix 前缀 待加前缀的)。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#makefile%E4%BD%BF%E7%94%A8-d%E9%80%89%E9%A1%B9%E6%9B%B4%E6%94%B9%E5%AE%8F%E5%AE%9A%E4%B9%89%E8%AE%B0%E5%BE%97%E8%A6%81clean"><span class="nav-text">Makefile使用-D选项更改宏定义，记得要clean</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#makefile%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-text">Makefile调用函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99-makefile"><span class="nav-text">跟我一起写 Makefile</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80.%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="nav-text">一.基础使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5"><span class="nav-text">1.关于程序的编译和链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%9B%AE%E6%A0%87"><span class="nav-text">2.基本目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B"><span class="nav-text">3.一个示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#make%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="nav-text">4.make是如何工作的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#makefile%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F"><span class="nav-text">5.makefile中使用变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A9make%E8%87%AA%E5%8A%A8%E6%8E%A8%E5%AF%BC"><span class="nav-text">6.让make自动推导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%A6%E7%B1%BB%E9%A3%8E%E6%A0%BC%E7%9A%84makefile"><span class="nav-text">7.另类风格的makefile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#makefile%E9%87%8C%E6%9C%89%E4%BB%80%E4%B9%88"><span class="nav-text">8.Makefile里有什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-text">9.通配符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C.%E6%96%87%E4%BB%B6%E6%90%9C%E5%AF%BB"><span class="nav-text">二.文件搜寻</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89.%E5%A4%9A%E7%9B%AE%E6%A0%87"><span class="nav-text">三.多目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B.%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BE%9D%E8%B5%96%E6%80%A7"><span class="nav-text">四.自动生成依赖性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94.%E4%B9%A6%E5%86%99%E5%91%BD%E4%BB%A4"><span class="nav-text">五.书写命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E5%91%BD%E4%BB%A4"><span class="nav-text">显示命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C"><span class="nav-text">命令执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E5%87%BA%E9%94%99"><span class="nav-text">命令出错</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E6%89%A7%E8%A1%8Cmake"><span class="nav-text">嵌套执行make</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4%E5%8C%85"><span class="nav-text">定义命令包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD.%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F"><span class="nav-text">六.使用变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%9F%BA%E7%A1%80"><span class="nav-text">变量的基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F"><span class="nav-text">变量中的变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95"><span class="nav-text">变量高级用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%BD%E5%8A%A0%E5%8F%98%E9%87%8F%E5%80%BC"><span class="nav-text">追加变量值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#override-%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="nav-text">override 指示符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%A1%8C%E5%8F%98%E9%87%8F"><span class="nav-text">多行变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-text">环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87%E5%8F%98%E9%87%8F"><span class="nav-text">目标变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%8F%98%E9%87%8F"><span class="nav-text">模式变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83.%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="nav-text">七.使用条件判断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-text">示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95"><span class="nav-text">语法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9C%8B%E5%88%B0%E8%BF%99%E9%87%8C%E4%BA%86"><span class="nav-text">看到这里了</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB.%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-text">八.使用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%AF%AD%E6%B3%95"><span class="nav-text">函数的调用语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-text">字符串处理函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%90%8D%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="nav-text">文件名操作函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#foreach-%E5%87%BD%E6%95%B0"><span class="nav-text">foreach 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#if-%E5%87%BD%E6%95%B0"><span class="nav-text">if 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#call%E5%87%BD%E6%95%B0"><span class="nav-text">call函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#origin%E5%87%BD%E6%95%B0"><span class="nav-text">origin函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shell%E5%87%BD%E6%95%B0"><span class="nav-text">shell函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6make%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-text">控制make的函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%9D.make-%E7%9A%84%E8%BF%90%E8%A1%8C"><span class="nav-text">九.make 的运行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#make%E7%9A%84%E9%80%80%E5%87%BA%E7%A0%81"><span class="nav-text">make的退出码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E5%AE%9Amakefile"><span class="nav-text">指定Makefile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E7%9B%AE%E6%A0%87"><span class="nav-text">指定目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E8%A7%84%E5%88%99"><span class="nav-text">检查规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#make%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-text">make的参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81.%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99"><span class="nav-text">十.隐含规则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99"><span class="nav-text">使用隐含规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99%E4%B8%80%E8%A7%88"><span class="nav-text">隐含规则一览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8F%98%E9%87%8F"><span class="nav-text">隐含规则使用的变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99%E9%93%BE"><span class="nav-text">隐含规则链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%BC%8F%E8%A7%84%E5%88%99"><span class="nav-text">定义模式规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%80%81%E5%BC%8F%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99"><span class="nav-text">老式风格的后缀规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95"><span class="nav-text">隐含规则搜索算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%B8%80.%E4%BD%BF%E7%94%A8make%E6%9B%B4%E6%96%B0%E5%87%BD%E6%95%B0%E5%BA%93%E6%96%87%E4%BB%B6"><span class="nav-text">十一.使用make更新函数库文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BA%93%E6%96%87%E4%BB%B6%E7%9A%84%E6%88%90%E5%91%98"><span class="nav-text">函数库文件的成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BA%93%E6%88%90%E5%91%98%E7%9A%84%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99"><span class="nav-text">函数库成员的隐含规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BA%93%E6%96%87%E4%BB%B6%E7%9A%84%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99"><span class="nav-text">函数库文件的后缀规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">注意事项</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zmaiLee"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">zmaiLee</p>
  <div class="site-description" itemprop="description">HUSTer19. ICdesign & Computer Architecture</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zmaiLee" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zmaiLee" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_45631071" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_45631071" rel="noopener" target="_blank"><i class="crosshairs fa-fw"></i>CSDN</a>
      </span>
  </div>



        <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=386538&auto=1&height=66"></iframe>
      </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">劢</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  
<div class="moon-menu">
  <div class="moon-menu-items">
    
    <div id="moon-menu-item-back2bottom" class="moon-menu-item">
      <i class='fas fa-chevron-down'></i>    </div>
    
    <div id="moon-menu-item-back2top" class="moon-menu-item">
      <i class='fas fa-chevron-up'></i>    </div>
    
  </div>
  <div class="moon-menu-button">
    <svg class="moon-menu-bg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle>
    </svg>
    <div class="moon-menu-content">
      <div class="moon-menu-icon"><i class='fas fa-ellipsis-v'></i></div>
      <div class="moon-menu-text"></div>
    </div>
  </div>
</div><script src="/js/injector.js"></script>
</body>
</html>
