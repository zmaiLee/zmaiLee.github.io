<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>DPI学习笔记 | Mai's blog</title><meta name="author" content="zmaiLee"><meta name="copyright" content="zmaiLee"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="DPI学习笔记一、DPI前世-PLI首先思考几个问题：  用户如何获得Verilog描述的电路的内部数据结构信息?  EDA仿真器在仿真verilog的tb时，FSDB波形是如何生成的？  $display，$stop，$finish等系统函数,如何被不同EDA仿真器识别?   除了底层描述硬件的能力，Verilog同样应该具有与上层交互的能力，基于此Verilog PLI(Programming">
<meta property="og:type" content="article">
<meta property="og:title" content="DPI学习笔记">
<meta property="og:url" content="https://zmailee.github.io/2022/10/30/DPI/index.html">
<meta property="og:site_name" content="Mai&#39;s blog">
<meta property="og:description" content="DPI学习笔记一、DPI前世-PLI首先思考几个问题：  用户如何获得Verilog描述的电路的内部数据结构信息?  EDA仿真器在仿真verilog的tb时，FSDB波形是如何生成的？  $display，$stop，$finish等系统函数,如何被不同EDA仿真器识别?   除了底层描述硬件的能力，Verilog同样应该具有与上层交互的能力，基于此Verilog PLI(Programming">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zmailee.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2022-10-30T14:39:30.544Z">
<meta property="article:modified_time" content="2022-10-31T04:20:01.788Z">
<meta property="article:author" content="zmaiLee">
<meta property="article:tag" content="SystemVerilog">
<meta property="article:tag" content="DPI-C">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zmailee.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zmailee.github.io/2022/10/30/DPI/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'DPI学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-31 12:20:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" type="text/css" href="/css/injector/main.css" /><link rel="preload" as="style" href="/css/injector/light.css" /><link rel="preload" as="style" href="/css/injector/dark.css" /><link rel="alternate" href="/atom.xml" title="Mai's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Mai's blog"><span class="site-name">Mai's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">DPI学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-30T14:39:30.544Z" title="发表于 2022-10-30 22:39:30">2022-10-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-31T04:20:01.788Z" title="更新于 2022-10-31 12:20:01">2022-10-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/">基础课程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="DPI学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="DPI学习笔记"><a href="#DPI学习笔记" class="headerlink" title="DPI学习笔记"></a>DPI学习笔记</h1><h2 id="一、DPI前世-PLI"><a href="#一、DPI前世-PLI" class="headerlink" title="一、DPI前世-PLI"></a>一、DPI前世-PLI</h2><p>首先思考几个问题：</p>
<ul>
<li><p>用户如何获得Verilog描述的电路的内部<strong>数据结构信息</strong>?</p>
</li>
<li><p>EDA仿真器在仿真verilog的tb时，FSDB波形是如何生成的？</p>
</li>
<li><p>$display，$stop，$finish等系统函数,如何被不同EDA仿真器识别?</p>
</li>
</ul>
<p>除了底层描述硬件的能力，Verilog同样应该具有与上层交互的能力，基于此<strong>Verilog PLI</strong>(Programming Language Interface)应运而生，它是一种从Verilog代码调用C/C++函数的机制。可以说PLI的出现是Verilog语言在硬件设计方面如此成功的原因之一。<br>使用PLI，第三方公司和最终用户可以扩展商业Verilog仿真器的功能。在Verilog代码中调用的函数称为<strong>系统调用</strong>。内置系统函数的一个示例是$display，$stop，$finish等。 PLI允许用户创建自定义系统调用，这是Verilog语法不允许我们做的事情。基于PLI其实我们可以做的更多：</p>
<span id="more"></span>
<ul>
<li>功耗分析</li>
<li>代码覆盖率工具</li>
<li>修改Verilog仿真数据结构 - 更准确的延迟。</li>
<li>自定义输出显示</li>
<li>协同仿真。</li>
<li>设计调试工具。</li>
<li>仿真结果分析</li>
<li>C模型接口加速仿真</li>
<li>Testbench建模</li>
</ul>
<p>为了实现PLI的这些应用，C代码应该可以访问Verilog仿真器的内部数据结构。为方便起见，Verilog PLI提供了一些称为acc例程或简单访问例程的东西。还有第二组例程，称为tf例程，或简称为任务和函数例程。 tf和acc是PLI 1.0例程，并且非常庞大且陈旧。</p>
<h3 id="VPI"><a href="#VPI" class="headerlink" title="VPI"></a>VPI</h3><p>Verilog程序接口（VPI），最初称为PLI2.0，主要用于C编程语言的接口。它允许行为Verilog代码调用C函数，C函数调用标准Verilog系统任务。 Verilog程序接口是IEEE 1364编程语言接口标准的一部分;该标准的最新版本是从2005年开始的。VPI也取代了已弃用的PLI。</p>
<p>虽然PLI1被弃用而支持VPI（又名PLI2），但由于其广泛记录的tf_put，tf_get函数接口在许多verilog参考书中有所描述，因此PLI1仍常用于VPI。</p>
<p>综上所述：PLI有三个libraries, TF(task/function) interface, ACC(access) interface, 以及VPI(Verilog Procedural Interface)，三者的时间先后顺序是1985-1989-1995而前面两个已经在IEEE 1364-2005中被删除。</p>
<h3 id="PLI的应用和维护问题"><a href="#PLI的应用和维护问题" class="headerlink" title="PLI的应用和维护问题"></a>PLI的应用和维护问题</h3><p>写PLI例程，是件痛苦的事情，不仅需要好几个步骤，更让人头痛的是PLI三个库中提供的一大堆难记的标准例程名字。写完了，还必须再用checktf例程，calltf例程包一层，才能在verilog中调用。<br>另外一个问题， 就是谁来负责写这些PLI例程，通常情况下，不管是设计者还是验证人员通常都不需要了解仿真器生成的verilog数据结构。我们只是使用者，不是生产者。</p>
<p>编写PLI应用程序很难</p>
<ul>
<li>必须学习奇怪的PLI术语</li>
<li>必须了解PLI库中的内容</li>
<li>必须创建checktf例程，calltf例程等</li>
</ul>
<p>将PLI应用程序链接到仿真器很难</p>
<ul>
<li>涉及多个步骤</li>
<li>每个仿真器都不同</li>
<li>谁链接？设计工程师 or EDA工程师？</li>
<li>管理多个PLI应用程序很困难</li>
<li>PLI代码很少与二进制兼容</li>
<li>必须为每个仿真器重新编译</li>
</ul>
<p>综上，PLI的缺点它严重阻碍着设计者和验证者使用更高级的语言来加强verilog语言的功力，尤其是日益复杂的设计和验证工作迫切需要一种新的编程语言接口，为我们提供强大的生产力的时候。</p>
<p>SystemVerilog引入了<strong>DPI(Direct Programming Interface</strong>)，能够更简洁的连接C/C++或者其他非<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Verilog&amp;spm=1001.2101.3001.7020">Verilog</a>的编程语言。</p>
<h2 id="二、DPI横空出世"><a href="#二、DPI横空出世" class="headerlink" title="二、DPI横空出世"></a>二、DPI横空出世</h2><p>在2003年IEEE 1800 SV LRM 3.1a中提出了一种直接的编程语言接口DPI。SystemVerilog DPI是将SystemVerilog与外部语言连接的一个接口。理论上外部语言可以是C，C ++，SystemC以及其他语言。但是现在，SystemVerilog仅为C语言定义了一个外部语言层。</p>
<p>DPI由两层组成：SystemVerilog层和外部语言层。两层都彼此隔离。实际使用哪种编程语言作为外语是透明的，与此接口的SystemVerilog端无关。</p>
<p>DPI标准源自两个专有接口，一个来自Synopsys公司的VCS DirectC接口，另一个是来自Co-Design公司（已被Synopsys收购）的SystemSim Cblend接口。这两个专有接口起初是为他们各自的仿真器开发的， 而不是一个能够工作在任何仿真器上的标准。后来Synopsys公司将这两个技术捐献给了Accellera组织，Accellera的SystemVerilog标准委员会把这两个捐献技术合并在一起，并定义了DPI接口的语义，使得DPI能够与任何Verilog仿真器一起工作。</p>
<h3 id="两者之间的关系"><a href="#两者之间的关系" class="headerlink" title="两者之间的关系"></a>两者之间的关系</h3><p>DPI不是PLI的替代品。相反，他们的角色是互补的。 PLI和VPI将来会继续存在并蓬勃发展，这主要有两个原因。</p>
<ul>
<li>PLI和VPI是经过时间考验的方法确保了对仿真器数据库的保护。 PLI和VPI将继续提供访问设计数据的安全机制，同时保持仿真器数据库的完整性。</li>
<li>对于许多人来说，PLI在未来几年仍将是首选接口语言。有许多应用程序使用PLI和VPI编写。将维护这些遗留应用程序，创建新的附加组件，并且将出现全新的应用程序 - 全部使用PLI和VPI。在Accellera决定对整个SystemVerilog语言提供完整的VPI支持时，PLI也就证明了其顽强的生命力。你熟悉和喜爱的VPI方法现在将适用于SystemVerilog的整个对象集。</li>
</ul>
<h2 id="三、为什么需要DPI？"><a href="#三、为什么需要DPI？" class="headerlink" title="三、为什么需要DPI？"></a>三、为什么需要DPI？</h2><p>DPI出现的动机是双重的。</p>
<p>方法论要求接口应该允许<strong>构建异构系统</strong>（设计或测试平台），其中一些组件可以用除SystemVerilog之外的语言（或更多语言）编写。</p>
<p>另一方面，需要一种简单有效的方法来连接通常用C或C++编写的现有代码，而不需要PLI或VPI的知识开销。</p>
<p><strong>DPI遵循黑盒的原则</strong>：组件的规范和实现明确分开，实际实现对系统的其余部分是透明的。因此，实现的实际编程语言也是透明的，尽管该标准仅定义了C链接语义。 SystemVerilog代码与外部语言之间的分离基于使用函数作为SystemVerilog中的自然封装单元。总的来说，任何函数都可以被视为一个黑盒子，并以透明的方式在SystemVerilog或外部语言中实现，而无需更改其调用。</p>
<p>现实世界中，C和C++应该是IC世界，最被广泛使用的高级编程语言，而且有很多开源的代码和工具都是C或者C++代码编写。按照DPI的方法论，我们理应为C和C++世界通往SV世界打开一扇门。</p>
<p>DPI是在SystemVerilog LRM 3.1a 2003中定义的关键字<br>DPI-C是在SystemVerilog IEEE 1800-2012中定义的关键字</p>
<p>目前DPI已弃用，应替换为DPI-C</p>
<p>DPI-C的出现使得SV和C之间的互动变得简单直接</p>
<ul>
<li>使用C函数作为SV函数/任务，反之亦然</li>
<li>直接调用C/C++库中的函数</li>
<li>直接将输入传递给函数</li>
<li>直接从C/C++函数接收返回值</li>
</ul>
<p>其是在验证领域，使用C/C++代码作为参考模型很普遍</p>
<ul>
<li>使用功能强大的OpenSSL、OpenCV等开源库</li>
<li>参考模型是由设计师或软件团队使用C/C++编写的</li>
<li>使用MATLAB生成DPI组件</li>
</ul>
<p>SystemVerilog可以调用C，C可以调用SV</p>
<ul>
<li>支持函数和任务</li>
<li>在协同仿真中很有用</li>
</ul>
<p>（1）在模块级乃至子系统级的验证，使用SV就完全够用了，而在更上面的层级，例如系统级，多采用大量的C代码组成。那么<strong>为了完成测试用例从子系统到系统级的复用</strong>，我们最好在子系统级开始就有意识地建立支持C测试的环境，并且使用一些基于C的测试用例，这样才能使得整体具有更好的复用性。</p>
<p>（2）处理器的需要。子系统测试时，不一定本身自带了处理器的硬件实例(Verilog编写的)，因此在构建子系统时还要考虑如何模拟外部处理器对子系统的访问行为。当然，我们直接加上一个外部的处理器实例是完全可以的，等验证完子系统的功能后再撤掉就行。注意，这个处理器实例也是verilog编写的。但是，这种方法也存在了一些弊端：即使这个外部处理器再小巧，但硬件体积还是过大了，肯定会影响整个仿真的速度；针对不同子系统的预留接口(APB/AHB/AXI等)，处理器子系统也要进行对应的调整吧；这种真实的处理器，必然要处理C代码，所以要进行编译、转换成二进制bin文件以及下载到memory中，还是太麻烦；还需要额外的启动配置文件，而且仿真时需要额外的额时间进行初始化。总结一下真实处理器的弊端，那就是麻烦，处理C代码也繁琐，影响了仿真速度。</p>
<h2 id="四、DPI基础"><a href="#四、DPI基础" class="headerlink" title="四、DPI基础"></a>四、DPI基础</h2><h3 id="4-1数据类型转换"><a href="#4-1数据类型转换" class="headerlink" title="4.1数据类型转换"></a>4.1数据类型转换</h3><h4 id="数据映射关系"><a href="#数据映射关系" class="headerlink" title="数据映射关系"></a>数据映射关系</h4><p>当SV与C环境交互时，会发生数据交换。 数据需要在两端以完全相同的方式解释，否则通信将失败。 SystemVerilog和C之间的数据交换通常使用DPI-C接口完成，该接口标准化类型对应关系和基本API（另请参见仿真器安装路径下的svdpi.h）。</p>
<p>大多数SystemVerilog数据类型在C语言中具有直接的对应关系，而其他（例如，4值类型，数组）需要DPI-C定义的类型和API。 </p>
<p>通过DPI传递的每个变量都有两个相匹配的定义，一个在SV中，一个在C语言中。 在使用中必须，确认使用的是兼容的数据类型。<strong>C输出数据给SV，只能通过指针的方式输出</strong>。所以输出数据也是在SV中建立空间，然后在C中得到指针，将值写进去，这样C的内存空间的控制不会影响到SV端。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">SystemVerilog</th>
<th>C(input)</th>
<th>C(output)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">byte</td>
<td>char</td>
<td>char*</td>
</tr>
<tr>
<td style="text-align:left">shortint</td>
<td>short int</td>
<td>short int*</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td>int</td>
<td>int*</td>
</tr>
<tr>
<td style="text-align:left">longint</td>
<td>long int</td>
<td>long int*</td>
</tr>
<tr>
<td style="text-align:left">shortreal</td>
<td>float</td>
<td>float*</td>
</tr>
<tr>
<td style="text-align:left">real</td>
<td>double</td>
<td>double*</td>
</tr>
<tr>
<td style="text-align:left">string</td>
<td>const char*</td>
<td>char**</td>
</tr>
<tr>
<td style="text-align:left">string[n]</td>
<td>const char**</td>
<td>char**</td>
</tr>
<tr>
<td style="text-align:left">bit</td>
<td>svBit(unsigned char)</td>
<td>svBit*(unsigned char)</td>
</tr>
<tr>
<td style="text-align:left">logic, reg</td>
<td>svLogic</td>
<td>svLogic*</td>
</tr>
<tr>
<td style="text-align:left">bit[N:0]</td>
<td>const svBitVecVal*</td>
<td>svBitVecVal*</td>
</tr>
<tr>
<td style="text-align:left">logic[N:0], reg[N:0]</td>
<td>const svLogicVecVal*</td>
<td>svLogicVecVal*</td>
</tr>
<tr>
<td style="text-align:left">Open array[] (import only)</td>
<td>const svOpenArrayHandle</td>
<td>svOpenArrayHandle</td>
</tr>
<tr>
<td style="text-align:left">chandle</td>
<td>const void*</td>
<td>void*</td>
</tr>
</tbody>
</table>
</div>
<p>DPI调入C函数返回值，SV LRM推荐使用<strong>small values</strong> ：void,byte,shortint,int,longint,real,shortreal,chandle,string,bit,logic</p>
<p>不推荐使用bit[6:0]或者logic[6:0]这样的值，因为这样需要返回一个svBitVecVal或者svLogicVecVal的指针。</p>
<h4 id="四值逻辑变量转换关系"><a href="#四值逻辑变量转换关系" class="headerlink" title="四值逻辑变量转换关系"></a><strong>四值逻辑变量转换关系</strong></h4><p>假设SV一侧有一个logic f，那么它在C一侧，会用一个无符号的字节来保存。分为aval和bval，其中aval保存在最低位，bval保存在紧邻的高位。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>四状态值</th>
<th>bval</th>
<th>aval</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>Z</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>X</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>1’b0 -&gt; 0x0，1’b1 -&gt; 0x1，1’bz -&gt; 0x2，1’bx -&gt; 0x3</p>
<p>logic[31:0] word，采用一对32bit的变量来表示，aval[31:0]与bval[31:0]。</p>
<p>在导入数组时，需要同时赋值aval和bval，如data[31:0]，例如要将data[0]=1，那么需要data[0].aval=1, data[0].bval=0;</p>
<h3 id="4-2接口调用"><a href="#4-2接口调用" class="headerlink" title="4.2接口调用"></a>4.2接口调用</h3><p>通过import声明C任务和函数的原型：</p>
<ul>
<li><strong>带有返回值</strong>的C函数被映射成一个sv的<strong>function</strong></li>
<li><strong>void类型</strong>的C函数被映射为一个sv的<strong>task</strong>或<strong>void function</strong></li>
</ul>
<p>如果C函数名和SV中的命名冲突，可以在import导入时，赋予新的函数名。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> test(); <br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> test=<span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_test(); <span class="hljs-comment">//将C中的test-&gt;my_test</span><br></code></pre></td></tr></table></figure>
<h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>在C和SV中有两种传递参数的方法：</p>
<ul>
<li>按值传递：被调用者函数将使用来自调用者的参数的副本</li>
<li>通过引用传递：被调用者函数将使用来自调用者的参数的指针/引用</li>
</ul>
<p>如果函数正在更改其参数的值，则仅当参数通过引用传递时，更改才会在函数外部可见。 当参数按值传递时，对函数内部完成的参数的任何更改都不会在其外部可见。</p>
<p>在SystemVerilog中，按值或按引用传递由参数方向确定。<br>在C中，通过值或引用传递是由参数类型是否为指针确定的。<br>默认情况下，SV和C都按值传递参数。</p>
<p>导入的C函数参数可以作为输入，输出或inout（双向）</p>
<ul>
<li>输入的行为就像在调用时复制到C函数中一样，C函数不应修改输入参数</li>
<li>当函数返回时，输出的行为就像复制到Verilog中一样</li>
<li>Inouts的行为就像在调用中复制一样，并在返回时复制出来</li>
</ul>
<p>除非另有说明，否则假定参数为输入</p>
<p>SV提供了丰富的数据类型可以作为参数：</p>
<ul>
<li>void, byte, shortint, int, longint, real, shortreal, chandle, time, integer, and string</li>
<li>Scalar values of type bit and logic</li>
<li>Packed arrays, structs, and unions composed of types bit and logic</li>
<li>Types constructed from the supported types with the help of the constructs: struct , union , Unpacked array , typedef</li>
</ul>
<p>返回值数据类型：</p>
<ul>
<li>void, byte, shortint, int, longint, real, shortreal, chandle, and string</li>
<li>Scalar values of type bit and logic</li>
<li>Restrictions apply for import and export functions</li>
</ul>
<h4 id="参数方向"><a href="#参数方向" class="headerlink" title="参数方向"></a>参数方向</h4><blockquote>
<p>对于参数方向，支持<strong>input, output以及inout</strong>。<strong>Ref则不被支持</strong>。<strong>默认是input</strong></p>
<p>例子：Import “DPI-C” function int add(input int a, b, output int sum);</p>
</blockquote>
<h4 id="导入方式"><a href="#导入方式" class="headerlink" title="导入方式"></a><strong>导入方式</strong></h4><figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">import</span> “DPI-C” <span class="hljs-keyword">context</span> <span class="hljs-keyword">task</span> core0_thread();<br></code></pre></td></tr></table></figure>
<ul>
<li><p>pure：函数严格根据输入来计算输出，跟外部环境没有其它交互。作为pure函数，函数的结果必须仅仅依赖于通过形参传递进来的数值。优点在于仿真器可以执行优化以改进仿真性能。Pure函数不能使用全局或者静态变量，不能执行文件I/O操作，不能访问操作系统环境变量，不能调用来自Verilog PLI 库的函数。<strong>只有没有输出或者inout的非void函数（必须有return值）可以被指定成pure。Pure函数不能作为Verilog任务导入。</strong></p>
</li>
<li><p>context：表示的是<strong>关联导入</strong>，关联类型会导致额外的开销。context C函数明确函数声明所在工作域的Verilog的层次。可以是void函数，可以有输出和inout参数，可以从C库调用函数（用于文件I/O等)，可以调用PLI库中的许多函数，这使得被导入的C函数能够调用来自PLI或者VPI库的函数，从而DPI函数可以充分利用PLI的优势特性，比如写仿真器的log文件以及Verilog源代码打开的文件。</p>
</li>
<li><p>generic：函数使用了全局变量，但没有调用任何的PLI（缺省下为此类型）。本文把那些既没有明确声明为pure，也没有声明为context的函数称为generic函数(SystemVerilog标准没有给除了pure或context之外的函数特定的称呼)。generic C函数可以作为Verilog函数或者Verilog任务导入。任务或者函数可以由输入、输出以及inout的参数。函数可以有一个返回值，或者声明为void。generic C函数不允许调用Verilog PLI函数，不能访问除了参数以外的任何数据，只能修改这些参数。</p>
</li>
</ul>
<p><strong>正确的声明导入的函数为pure还是context是用户的责任</strong>。缺省情况下，DPI函数假定是generic函数。调用一个不正确声明成pure的C函数可能返回不正确或者不一致的结果，导致不可预测的运行时错误，甚至于让仿真崩溃。同样，如果一个C函数访问Verilog PLI库或者其他API库，却没有声明为context函数，会导致不可预见的仿真结果甚至仿真崩溃。</p>
<h4 id="导出方式"><a href="#导出方式" class="headerlink" title="导出方式"></a><strong>导出方式</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">export “DPI-C” function sv_display;<br></code></pre></td></tr></table></figure>
<p>注意后面不需要加括号和参数，如果需要改变名字，则可以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">export “DPI-C” dpi_writew = task writew;<br></code></pre></td></tr></table></figure>
<p>而在C一侧，则只需要extern void sv_display();</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> dpi_writew(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> addr, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> data);<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> dpi_readw(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> addr, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *data);<br></code></pre></td></tr></table></figure>
<h4 id="绑定别名"><a href="#绑定别名" class="headerlink" title="绑定别名"></a>绑定别名</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> gloval_name_space;<br>    <span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span>  <span class="hljs-keyword">context</span> <span class="hljs-keyword">task</span> sv_import_task ();<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> gloval_name_space1;<br>	<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span>  <span class="hljs-keyword">context</span> C_task1=<span class="hljs-keyword">task</span> sv_import_task ();<br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-keyword">module</span> gloval_name_space2;<br>	<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span>  <span class="hljs-keyword">context</span> C_task2=<span class="hljs-keyword">task</span> sv_import_task ();<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">export</span> <span class="hljs-string">&quot;DPI-C&quot;</span> f_plus = <span class="hljs-keyword">function</span> f ; <span class="hljs-comment">// &quot;f&quot; exported as &quot;f_plus&quot;</span><br><span class="hljs-keyword">export</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-keyword">function</span> f; <span class="hljs-comment">// &quot;f&quot; exported under its own name</span><br></code></pre></td></tr></table></figure>
<p>C的命名空间是全局可见的。sv_import_task中的声明变为等于C的链接名称。<br>对于所有模块，名称必须是唯一的。 C的链接是全局性的。因此，<br>上面是一种别名C链接名称的方法。 SV上的名称相同，但在C上，使用别名C_task1和C_task2执行链接。</p>
<h4 id="DPI-各种使用方式"><a href="#DPI-各种使用方式" class="headerlink" title="DPI 各种使用方式"></a>DPI 各种使用方式</h4><ul>
<li>通过import定义的函数可以在任何位置</li>
<li>在Verilog模块中</li>
<li>在SystemVerilog interface中</li>
<li>在SystemVerilog package中</li>
<li>在SystemVerilog“编译单元”中</li>
<li>import声明必须具有参数的原型</li>
<li>必须与C函数中的参数数完全匹配</li>
<li>必须指定兼容的数据类型</li>
<li>可以在多个位置导入相同的C功能</li>
<li>每个原型必须完全相同</li>
<li>更好的方法是在包中定义一个导入</li>
</ul>
<h3 id="4-3常用数据类型映射"><a href="#4-3常用数据类型映射" class="headerlink" title="4.3常用数据类型映射"></a>4.3常用数据类型映射</h3><ul>
<li>SV byte -&gt; C char</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_byte(input byte i_value, output byte result);<br>import &quot;DPI-C&quot; function byte get_byte(input byte i_value);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_byte</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> i_value, <span class="hljs-type">char</span>* result)</span>;<br><span class="hljs-type">char</span> <span class="hljs-title function_">get_byte</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> i_value)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>SV shortint -&gt; C short int</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_shortint(input shortint i_value, output shortint result);<br>import &quot;DPI-C&quot; function shortint get_shortint(input shortint i_value);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_shortint</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> i_value, <span class="hljs-type">short</span> <span class="hljs-type">int</span>* result)</span>;<br><span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_shortint</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> i_value)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>SV int -&gt; C int</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_int(input int i_value, output int result);<br>import &quot;DPI-C&quot; function int get_int(input int i_value);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_int</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> i_value, <span class="hljs-type">int</span>* result)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">get_int</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> i_value)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>SV longint -&gt; C long int</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_longint(input longint i_value, output longint result);<br>import &quot;DPI-C&quot; function longint get_longint(input longint i_value);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_longint</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> i_value, <span class="hljs-type">long</span> <span class="hljs-type">int</span>* result)</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_longint</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> i_value)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>SV real -&gt; C double</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_real(input real i_value, output real result);<br>import &quot;DPI-C&quot; function real get_real(input real i_value);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_real</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> i_value, <span class="hljs-type">double</span>* result)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">get_real</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> i_value)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>SV string -&gt; C char*</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_string(input string i_value, output string result);<br>import &quot;DPI-C&quot; function string get_string(input string i_value);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_string</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* i_value, <span class="hljs-type">char</span>** result)</span>;<br><span class="hljs-type">char</span>* <span class="hljs-title function_">get_string</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* i_value)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>SV chandle -&gt; C void*</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_chandle(output chandle result);<br>import &quot;DPI-C&quot; function chandle get_chandle();<br>import &quot;DPI-C&quot; function void call_chandle(input chandle i_value, output int result);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_chandle</span><span class="hljs-params">(<span class="hljs-type">void</span>** result)</span>;<br><span class="hljs-type">void</span>** <span class="hljs-title function_">get_chandle</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">call_chandle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* i_value, <span class="hljs-type">int</span>* o_value)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>SV bit -&gt; C svbit</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_bit(input bit i_value, output bit result);<br>import &quot;DPI-C&quot; function bit get_bit(input bit i_value);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_bit</span><span class="hljs-params">(<span class="hljs-type">const</span> svBit i_value, svBit* result)</span>;<br>svBit <span class="hljs-title function_">get_bit</span><span class="hljs-params">(<span class="hljs-type">const</span> svBit i_value)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>SV bit[n:0] -&gt; C svBitVecVal</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_bit_vector(input bit[`BIT_ARRAY_SIZE - 1 : 0] i_val, output bit[`BIT_ARRAY_SIZE - 1 : 0] result);<br>import &quot;DPI-C&quot; function bit[`BIT_ARRAY_SIZE - 1 : 0] get_bit_vector(input bit[`BIT_ARRAY_SIZE - 1 : 0] i_val);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_bit_vector</span><span class="hljs-params">(<span class="hljs-type">const</span> svBitVecVal* i_value, svBitVecVal* result)</span>;<br>svBitVecVal <span class="hljs-title function_">get_bit_vector</span><span class="hljs-params">(<span class="hljs-type">const</span> svBitVecVal* i_value)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>SV logic -&gt; C svLogic</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_logic(input logic i_value, output logic result);<br>import &quot;DPI-C&quot; function logic get_logic(input logic i_value);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_logic</span><span class="hljs-params">(<span class="hljs-type">const</span> svLogic i_value, svLogic* result)</span>;<br>svLogic <span class="hljs-title function_">get_logic</span><span class="hljs-params">(<span class="hljs-type">const</span> svLogic i_value)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>SV reg -&gt; C svLogic</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_reg(input reg i_value, output reg result);<br>import &quot;DPI-C&quot; function reg  get_reg(input reg i_value);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_reg</span><span class="hljs-params">(<span class="hljs-type">const</span> svLogic i_value, svLogic* result)</span>;<br>svLogic <span class="hljs-title function_">get_reg</span><span class="hljs-params">(<span class="hljs-type">const</span> svLogic i_value)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>SV logic[n:0] -&gt; C svLogicVecVal</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_logic_vector(input logic[`LOGIC_ARRAY_SIZE - 1 : 0] i_val, output logic[`LOGIC_ARRAY_SIZE - 1 : 0] result, input int asize);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br>svLogicVecVal*  <span class="hljs-title function_">get_logic_vector</span><span class="hljs-params">(<span class="hljs-type">const</span> svLogicVecVal* i_value, <span class="hljs-type">int</span> asize)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>SV reg[n:0] -&gt; C svLogicVecVal</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_reg_vector(input reg[\`REG_ARRAY_SIZE - 1 : 0] i_val, output reg[\`REG_ARRAY_SIZE - 1 : 0] result, input int asize);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_reg_vector</span><span class="hljs-params">(<span class="hljs-type">const</span> svLogicVecVal* i_value, svLogicVecVal* result, <span class="hljs-type">int</span> asize)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>SV int[] -&gt; C svOpenArrayHandle</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_unsized_int_array(input int i_value[], output int result[]);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_unsized_int_array</span><span class="hljs-params">(<span class="hljs-type">const</span> svOpenArrayHandle i_value, svOpenArrayHandle result)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>SV struct -&gt; C struct</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>`define BIT_ARRAY_SIZE 16<br>typedef struct &#123;<br>	byte aByte;<br>	int anInt;<br>	bit aBit;<br>	longint aLongInt;<br>	bit[`BIT_ARRAY_SIZE-1:0] aBitVector;<br>&#125; dpi_c_ex_s;<br>import &quot;DPI-C&quot; function void compute_struct(input dpi_c_ex_s i_value, output dpi_c_ex_s result);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dpi_c_ex_s</span> &#123;</span><br>	<span class="hljs-type">char</span> aChar;<br>	<span class="hljs-type">int</span> anInt;<br>	svBit aBit;<br>	<span class="hljs-type">long</span> <span class="hljs-type">int</span> aLongInt;<br>	svBitVecVal aBitVector;<br>&#125; dpi_c_ex_s;<br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_struct</span><span class="hljs-params">(<span class="hljs-type">const</span> dpi_c_ex_s* i_value, dpi_c_ex_s* output)</span>;<br></code></pre></td></tr></table></figure>
<h2 id="五、DPI进阶"><a href="#五、DPI进阶" class="headerlink" title="五、DPI进阶"></a>五、DPI进阶</h2><h4 id="5-1压缩数组（Packed-arrays）"><a href="#5-1压缩数组（Packed-arrays）" class="headerlink" title="5.1压缩数组（Packed arrays）"></a>5.1压缩数组（Packed arrays）</h4><p>压缩数组被视为数组和单个值，既可以访问整个值，也可以将其分成更小的元素。与非压缩的数组不同，它存储为一组连续的没有未使用空间的位。可以方便地将其作为数组元素进行访问。</p>
<p><strong>压缩数组：在数据类型标识符名称之前声明的维度</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">bit [7:0] p; // packed array of scalar bit types<br>bit [3:0][7:0] bytes // 4 bytes packed into 32-bits<br></code></pre></td></tr></table></figure>
<p>具有预定义宽度的整数类型不能声明为带维度的压缩数组。 这些类型是byte，shortint，int，longint，integer和time。 虽然是具有预定义宽度n的整数类型，它不是一个打包数组，但其自身是可以分解为子字段的，可以理解为一个具有单个[n-1:0]维度的压缩数组类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">byte c2; // same as bit signed [7:0] c2;`<br>integer i1; // same as logic signed [31:0] i1;<br></code></pre></td></tr></table></figure>
<h4 id="5-2非压缩数组（Unpacked-arrays）"><a href="#5-2非压缩数组（Unpacked-arrays）" class="headerlink" title="5.2非压缩数组（Unpacked arrays）"></a>5.2非压缩数组（Unpacked arrays）</h4><p>非压缩数组可以由任何数据类型组成。每个固定大小的维度应由地址范围[0:size-1]或单个正数[size]表示，以指定固定大小的非压缩数组的大小。</p>
<p><strong>非压缩数组：在数据类型标识符名称后声明的维度</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">bit u [7:0];<br>int Array[0:7][0:31]; // array declaration using ranges<br>int Array[8][32]; // array declaration using sizes<br></code></pre></td></tr></table></figure>
<p>SV 索引 [min：max] -&gt; C端数组索引从0开始</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">SV: a[1:7] -&gt; C: a[7]<br>SV: a[1] -&gt; C: a[0], SV a[7] -&gt; C: a[6]<br></code></pre></td></tr></table></figure>
<p>SV压缩数组被当做一维数组对待</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">//SV: a[l][m][n] -&gt; C: a[n+m*k+l*j*k]<br>bit[5:2]a; a[5]=1 a[4]=0 a[3]=1 a[2]=0; -&gt; C: a=10<br></code></pre></td></tr></table></figure>
<p><strong>所有数据类型最终都等同于最多32位的压缩数组</strong><br>        SV byte -&gt; C int，只使用低8位<br>        <strong>C char数组无法映射到SV byte类型的非压缩数组</strong></p>
<h4 id="5-3混合压缩和非压缩的数组"><a href="#5-3混合压缩和非压缩的数组" class="headerlink" title="5.3混合压缩和非压缩的数组"></a>5.3混合压缩和非压缩的数组</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">bit [3:0] Bytes [0:2] [0:5]<br></code></pre></td></tr></table></figure>
<p><img src="DPI.assets/bfa1d0786bdd9d9435609c5734afe49a.png" alt="img"></p>
<h4 id="5-4SV-PACKED-DATA-NELEMS（width）"><a href="#5-4SV-PACKED-DATA-NELEMS（width）" class="headerlink" title="5.4SV_PACKED_DATA_NELEMS（width）"></a>5.4SV_PACKED_DATA_NELEMS（width）</h4><p>该宏将位转换为元素数，在bit和word之间转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">include <span class="hljs-string">&quot;svdpi.h&quot;</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">packet_C</span><span class="hljs-params">(<span class="hljs-type">const</span> svLogicVecVal* packet)</span> &#123;<br>   <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span>  elements=SV_PACKED_DATA_NELEMS(<span class="hljs-number">128</span>);<br>   svLogicVecVal mem[elements];<br><br>   <span class="hljs-built_in">memcpy</span>(mem,packet,<span class="hljs-keyword">sizeof</span>(mem));<br>   io_printf(“C: data from SV side\n<span class="hljs-string">&quot;);</span><br><span class="hljs-string">   for (unsigned i=0;i&lt; elements;i++)&#123;</span><br><span class="hljs-string">      io_printf(&quot;</span>mem[%<span class="hljs-number">2</span>d]=&#123;%<span class="hljs-number">4</span>x,%<span class="hljs-number">4</span>x&#125;\n<span class="hljs-string">&quot;,i,mem[i].aval,mem[i].bval);</span><br><span class="hljs-string">   &#125;    </span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">module test;<br>import &quot;DPI-C&quot; function void packet_C( input logic [127:0]);<br><br>   logic [127:0] packet;<br>   initial　begin<br>      packet=128&#x27;h1234_5678_aaaa_bbbb_cccc_dddd_eeee_ffff;<br>      $display(“SV: data sent to C side: %x&quot;,packet);<br>      packet_C(packet);<br>   end<br><br>endmodule<br></code></pre></td></tr></table></figure>
<h4 id="5-5bit和logic标量和矢量的使用"><a href="#5-5bit和logic标量和矢量的使用" class="headerlink" title="5.5bit和logic标量和矢量的使用"></a>5.5bit和logic标量和矢量的使用</h4><p>在svdpi.h的头文件中，有如下自定义类型声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint8_t</span> svScalar;<br><span class="hljs-keyword">typedef</span> svScalar svBit; <span class="hljs-comment">/* scalar */</span><br><span class="hljs-keyword">typedef</span> svScalar svLogic; <span class="hljs-comment">/* scalar */</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> svBitVecVal;<br><br>Typedef <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>     <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> aval;<br>     <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bval;<br>&#125; svLogicVecVal;<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;svdpi.h&gt;</span> </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(svLogic a)</span>&#123; <br>	<span class="hljs-keyword">if</span>(a == <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; a is 0 \n&quot;</span>);<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a == <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; a is 1 \n&quot;</span>);<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a == <span class="hljs-number">2</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; a is x \n&quot;</span>);<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a == <span class="hljs-number">3</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; a is z \n&quot;</span>);<br>&#125; <br><span class="hljs-type">void</span>  <span class="hljs-title function_">displaylogicvec</span><span class="hljs-params">(svLogicVecVal *n)</span> &#123;<br>       <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot; data = %d control = %d\n&quot;</span>, n-&gt;aval, n-&gt;bval) ; <br>&#125;<br><br><span class="hljs-type">void</span>  <span class="hljs-title function_">displaybitvec</span><span class="hljs-params">(<span class="hljs-type">const</span> svBitVecVal *k)</span> &#123; <br>       <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot; data = %d\n &quot;</span>, k) ; <br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="5-6在DPI中使用压缩数组（Packed-Arrays）"><a href="#5-6在DPI中使用压缩数组（Packed-Arrays）" class="headerlink" title="5.6在DPI中使用压缩数组（Packed Arrays）"></a>5.6在DPI中使用压缩数组（Packed Arrays）</h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;svdpi.h&quot;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_nums</span> <span class="hljs-params">(svLogicVecVal nums[<span class="hljs-number">10</span>])</span>&#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;<br>    nums[i] = i ;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">program main; <br>import &quot;DPI-C&quot; function void get_nums(output logic [15:0] nums[10]); <br>logic [15:0] nums[10]; <br><br>initial begin <br>	get_nums(nums); <br>	foreach (nums[i]) <br>		$display(i,nums[i]); <br>end <br>  <br>endprogram <br></code></pre></td></tr></table></figure>
<h4 id="5-7DPI中使用开放数组（Open-arrays）"><a href="#5-7DPI中使用开放数组（Open-arrays）" class="headerlink" title="5.7DPI中使用开放数组（Open arrays）"></a>5.7DPI中使用开放数组（Open arrays）</h4><p>压缩数组维度，非压缩维度或两个维度的大小可以保持未指定，这种情况称为开放数组（或未定义大小的数组） </p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">include &lt;stdio.h&gt;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;svdpi.h&gt;</span> </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">pass_array</span><span class="hljs-params">(<span class="hljs-type">const</span> svOpenArrayHandle dy_ar )</span> &#123; <br>  <span class="hljs-type">int</span> i; <br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Array Pointer is %x \n&quot;</span>, svGetArrayPtr(dyn_arr) ); <br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Lower index %d \n&quot;</span>, svLow(dyn_arr,<span class="hljs-number">1</span>)); <br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Higher index %d \n&quot;</span>, svHigh(dyn_arr, <span class="hljs-number">1</span>) ); <br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Left index %d \n&quot;</span>, svLeft(dyn_arr,<span class="hljs-number">1</span>)); <br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Right index %d \n&quot;</span>, svRight(dyn_arr, <span class="hljs-number">1</span>) ); <br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Length of array %d \n&quot;</span>, svLength(dyn_arr,<span class="hljs-number">1</span>) ); <br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Incremental %d \n&quot;</span>,svIncrement(dyn_arr,<span class="hljs-number">1</span>)); <br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Dimentions of Array %d \n&quot;</span>, svDimensions(dyn_arr )); <br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Size of Array in bytes %d \n&quot;</span>, svSizeOfArray(dyn_arr) ); <br>  <span class="hljs-keyword">for</span> (i= svRight(dy_ar,<span class="hljs-number">1</span>); i &lt;= svLeft(dy_ar,<span class="hljs-number">1</span>); i++) &#123; <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;C: %d %d \n&quot;</span>, i, *(<span class="hljs-type">int</span>*)svGetArrElemPtr1(dy_ar, i) ); <br>  &#125; <br>&#125; <br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">program main; <br>int fxd_arr_1[8:3]; <br>int fxd_arr_2[12:1]; <br>import &quot;DPI-C&quot; context function void pass_array(input int dyn_arr[] ); <br><br>initial begin <br>	for (int i = 3; i&lt;=8 ; i++) begin <br>		fxd_arr_1[i] = $random(); <br>		$display(&quot;SV:fxd_arr_1 %0d %d &quot;,i, fxd_arr_1[i] ); <br>	end <br>	pass_array( fxd_arr_1 ); <br><br>	for (int i = 1; i&lt;=12 ; i++) begin <br>		fxd_arr_2[i] = $random() ; <br>		$display(&quot;SV: fxd_arr_2 %0d %d &quot;,i, fxd_arr_2[i] ); <br>	end <br>	pass_array( fxd_arr_2 ); <br><br>end <br>endprogram<br></code></pre></td></tr></table></figure>
<ul>
<li>Passing fxd_arr_1 to C<br>Array Pointer is 80fdc58<br>Lower index 3<br>Higher index 8<br>Left index 8<br>Right index 3<br>Length of array 6<br>Incremental 1<br>Dimentions of Array 1<br>Size of Array in bytes 24</li>
<li>Passing fxd_arr_2 to C<br>Array Pointer is 80fdc70<br>Lower index 1<br>Higher index 13<br>Left index 1<br>Right index 13<br>Length of array 13<br>Incremental -1<br>Dimentions of Array 1<br>Size of Array in bytes 52</li>
</ul>
<p><strong>开放数组提供了一系列查询和访问数组的方法</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>int svLeft(const svOpenArrayHandle h, int d);</td>
<td>Left bound for dimension d</td>
</tr>
<tr>
<td>int svRight(h, d)</td>
<td>Right bound for dimension d</td>
</tr>
<tr>
<td>int svLow(h, d)</td>
<td>Low bound for dimension d</td>
</tr>
<tr>
<td>int svHigh(h, d)</td>
<td>High bound for dimension d</td>
</tr>
<tr>
<td>int svIncrement(h, d)</td>
<td>If left &gt;= right 1 else -1</td>
</tr>
<tr>
<td>int svSize(h, d)</td>
<td>Number of elements in dimension d: svHigh−svLow+1</td>
</tr>
<tr>
<td>int svDimensions(h)</td>
<td>Number of dimensions in open array</td>
</tr>
<tr>
<td>int svSizeOfArray(h)</td>
<td>Total size of array in bytes</td>
</tr>
<tr>
<td>void *svGetArrayPtr(const svOpenArrayHandle h)</td>
<td>storage for the entire array</td>
</tr>
<tr>
<td>void svGetArrElemPtr(const svOpenArrayHandle h, int i1, …)</td>
<td>an element in the array</td>
</tr>
<tr>
<td>void *svGetArrElemPtr1(h, i1)</td>
<td>an element in a 1-D array</td>
</tr>
<tr>
<td>void *svGetArrElemPtr2(h, i1, i2)</td>
<td>an element in a 2-D array</td>
</tr>
<tr>
<td>void *svGetArrElemPtr3(h, i1, i2, i3)</td>
<td>an element in a 3-D array</td>
</tr>
</tbody>
</table>
</div>
<h4 id="5-8在DPI中使用结构体"><a href="#5-8在DPI中使用结构体" class="headerlink" title="5.8在DPI中使用结构体"></a>5.8在DPI中使用结构体</h4><p>在传递<code>struct</code>数据类型时，数据被打包到数组中并从SV传递到C，然后数组被解码回到C中的<code>struct</code>中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;svdpi.h&quot;</span> </span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123; <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span> <br>  <span class="hljs-type">int</span> a; <br>  <span class="hljs-type">int</span> b; <br>  <span class="hljs-type">char</span> c; <br>&#125; C_struct; <br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">export_func</span><span class="hljs-params">(svBitVecVal x[<span class="hljs-number">3</span>])</span>; <br><span class="hljs-type">void</span> <span class="hljs-title function_">import_func</span><span class="hljs-params">()</span> &#123; <br>  C_struct s_data; <br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>]; <br><br>  s_data.a = <span class="hljs-number">51</span>; <br>  s_data.b = <span class="hljs-number">242</span>; <br>  s_data.c = <span class="hljs-number">35</span>; <br>  <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;C : s_data.a = %d\n&quot;</span>, s_data.a ); <br>  <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;C : s_data.b = %d\n&quot;</span>, s_data.b ); <br>  <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;C : s_data.c = %d\n&quot;</span>, s_data.c ); <br><br>  arr[<span class="hljs-number">0</span>] = s_data.a ; <br>  arr[<span class="hljs-number">1</span>] = s_data.b ; <br>  arr[<span class="hljs-number">2</span>] = s_data.c ; <br>  export_func(arr); <br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">program main; <br><br>export &quot;DPI-C&quot; function export_func; <br>import &quot;DPI-C&quot; function void import_func(); <br><br>typedef struct packed&#123; <br>  int a; <br>  int b; <br>  byte c; <br>&#125; SV_struct; <br><br>function void export_func(input int arr[3]); <br>	SV_struct s_data; <br><br>  s_data.a = arr[0]; <br>  s_data.b = arr[1]; <br>  s_data.c = arr[2]; <br>  $display(&quot; SV: s_data.a = %0d&quot;, s_data.a ); <br>  $display(&quot; SV: s_data.b = %0d&quot;, s_data.b ); <br>  $display(&quot; SV: s_data.c = %0d \n&quot;, s_data.c ); <br>endfunction <br><br>initial begin <br>	import_func(); <br>end <br><br>endprogram<br></code></pre></td></tr></table></figure>
<p>在SV和C/C++代码使用定义的未压缩的结构体数据类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;svdpi.h&quot;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><br>	<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>		<span class="hljs-type">int</span> a;<br>		<span class="hljs-type">int</span> b;<br>	&#125;mystruct;<br>	<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">mydisplay</span><span class="hljs-params">(mystruct *s1)</span>&#123;<br>		<span class="hljs-type">int</span> s2;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;C: gets values from SV, s1.a=%d, s1.b=%d\\\\\\\\\\\\\\\\n&quot;</span>,s1-&gt;a,s1-&gt;b);<br>		s1-&gt;a = <span class="hljs-number">100</span>;<br>		s1-&gt;b = <span class="hljs-number">200</span>;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;C: set values,  s1.a=%d, s1.b=%d\\\\\\\\\\\\\\\\n&quot;</span>,s1-&gt;a,s1-&gt;b);<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">program p1;<br>	typedef struct &#123;<br>		int a;<br>		int b;<br>	&#125; mystruct;<br><br>	import &quot;DPI-C&quot; function void mydisplay(inout mystruct s1);<br>	mystruct s1;<br>	initial begin<br>		s1.a =10;<br>		s1.b =20;<br>		$display(&quot;SV: s1.a=%0d,s1.b=%0d&quot;,s1.a,s1.b);<br>	<br>		mydisplay(s1);<br>		$display(&quot;SV after DPI call: s1.a=%0d,s1.b=%0d&quot;,s1.a,s1.b);<br>	end <br><br>endprogram<br></code></pre></td></tr></table></figure>
<p>试着将上面例子中sv端结构体，改为packed类型，试试看C端打印信息会是什么样的？</p>
<p>压缩的结构体是包含packed保留字的结构体。 在结构内，保证了位连续性。 因此，成员也必须是矢量类型。 （不要混合real / shortreal。）如果混合使用2值或者4值逻辑，它们将在内存布局方面生成4个值，因此不要混用它们。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;svdpi.h&quot;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(svBitVecVal*)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">struct_operation</span><span class="hljs-params">()</span>&#123;<br>   svBitVecVal rgb;<br>   svPutPartselBit(&amp;rgb,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>);<span class="hljs-comment">//b</span><br>   svPutPartselBit(&amp;rgb,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>);<span class="hljs-comment">//g</span><br>   svPutPartselBit(&amp;rgb,<span class="hljs-number">3</span>,<span class="hljs-number">16</span>,<span class="hljs-number">8</span>);<span class="hljs-comment">//r</span><br>   func(&amp;rgb);<br>   svBitVecVal blue=<span class="hljs-number">0</span>;<br>   svBitVecVal red=<span class="hljs-number">0</span>;<br>   svBitVecVal green=<span class="hljs-number">0</span>;<br>   svGetPartselBit(&amp;blue,&amp;rgb,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>);<br>   svGetPartselBit(&amp;green,&amp;rgb,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>);<br>   svGetPartselBit(&amp;red,&amp;rgb,<span class="hljs-number">16</span>,<span class="hljs-number">8</span>);<br><br>   io_printf(<span class="hljs-string">&quot;C: data from SV side. red %3d green %3d blue %3d.\\\\\\\\\\\\\\\\n&quot;</span>,red,green,blue);<br><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">module root_scope;<br>    export &quot;DPI-C&quot; function func;<br>    import &quot;DPI-C&quot; context task struct_operation();<br><br>   typedef struct packed &#123;<br>      byte red;//MSB<br>      byte green;<br>      byte blue;//LSB ↑<br>   &#125; RGB_TYPE;<br><br>   function void func(inout RGB_TYPE A);<br>      $display(&quot;SV: data from C side. red=%3d blue=%3d green=%3d.&quot;,A.red,A.green,A.blue);<br>      A.blue=101;<br>      A.green=102;<br>      A.red=103;<br>      $display(&quot;SV: data change for C side read.&quot;);<br>          <br>   endfunction<br><br>   initial begin<br>      struct_operation();<br>   end<br><br>endmodule<br></code></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://zmailee.github.io">zmaiLee</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zmailee.github.io/2022/10/30/DPI/">https://zmailee.github.io/2022/10/30/DPI/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zmailee.github.io" target="_blank">Mai's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SystemVerilog/">SystemVerilog</a><a class="post-meta__tags" href="/tags/DPI-C/">DPI-C</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/02/linux/" title="Linux学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/19/%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E7%B3%BB%E7%BB%9F/" title="智能计算系统"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">智能计算系统</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">zmaiLee</div><div class="author-info__description">HUSTer19. ICdesign & Computer Architecture</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#DPI%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">DPI学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81DPI%E5%89%8D%E4%B8%96-PLI"><span class="toc-number">1.1.</span> <span class="toc-text">一、DPI前世-PLI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#VPI"><span class="toc-number">1.1.1.</span> <span class="toc-text">VPI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PLI%E7%9A%84%E5%BA%94%E7%94%A8%E5%92%8C%E7%BB%B4%E6%8A%A4%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.2.</span> <span class="toc-text">PLI的应用和维护问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81DPI%E6%A8%AA%E7%A9%BA%E5%87%BA%E4%B8%96"><span class="toc-number">1.2.</span> <span class="toc-text">二、DPI横空出世</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.1.</span> <span class="toc-text">两者之间的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81DPI%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">三、为什么需要DPI？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81DPI%E5%9F%BA%E7%A1%80"><span class="toc-number">1.4.</span> <span class="toc-text">四、DPI基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1数据类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">数据映射关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E5%80%BC%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">四值逻辑变量转换关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2接口调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">参数传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E6%96%B9%E5%90%91"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">参数方向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">导入方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">导出方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E5%88%AB%E5%90%8D"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">绑定别名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DPI-%E5%90%84%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.2.6.</span> <span class="toc-text">DPI 各种使用方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3常用数据类型映射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81DPI%E8%BF%9B%E9%98%B6"><span class="toc-number">1.5.</span> <span class="toc-text">五、DPI进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1%E5%8E%8B%E7%BC%A9%E6%95%B0%E7%BB%84%EF%BC%88Packed-arrays%EF%BC%89"><span class="toc-number">1.5.0.1.</span> <span class="toc-text">5.1压缩数组（Packed arrays）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2%E9%9D%9E%E5%8E%8B%E7%BC%A9%E6%95%B0%E7%BB%84%EF%BC%88Unpacked-arrays%EF%BC%89"><span class="toc-number">1.5.0.2.</span> <span class="toc-text">5.2非压缩数组（Unpacked arrays）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3%E6%B7%B7%E5%90%88%E5%8E%8B%E7%BC%A9%E5%92%8C%E9%9D%9E%E5%8E%8B%E7%BC%A9%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-number">1.5.0.3.</span> <span class="toc-text">5.3混合压缩和非压缩的数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4SV-PACKED-DATA-NELEMS%EF%BC%88width%EF%BC%89"><span class="toc-number">1.5.0.4.</span> <span class="toc-text">5.4SV_PACKED_DATA_NELEMS（width）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5bit%E5%92%8Clogic%E6%A0%87%E9%87%8F%E5%92%8C%E7%9F%A2%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.0.5.</span> <span class="toc-text">5.5bit和logic标量和矢量的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6%E5%9C%A8DPI%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8E%8B%E7%BC%A9%E6%95%B0%E7%BB%84%EF%BC%88Packed-Arrays%EF%BC%89"><span class="toc-number">1.5.0.6.</span> <span class="toc-text">5.6在DPI中使用压缩数组（Packed Arrays）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7DPI%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%BC%80%E6%94%BE%E6%95%B0%E7%BB%84%EF%BC%88Open-arrays%EF%BC%89"><span class="toc-number">1.5.0.7.</span> <span class="toc-text">5.7DPI中使用开放数组（Open arrays）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8%E5%9C%A8DPI%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.5.0.8.</span> <span class="toc-text">5.8在DPI中使用结构体</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/04/User%20Guide/" title="3D堆叠">3D堆叠</a><time datetime="2023-03-04T02:10:01.955Z" title="发表于 2023-03-04 10:10:01">2023-03-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/03/3D%E5%A0%86%E5%8F%A0/" title="3D堆叠">3D堆叠</a><time datetime="2023-03-03T07:17:23.252Z" title="发表于 2023-03-03 15:17:23">2023-03-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/02/Transformer/" title="Transformer">Transformer</a><time datetime="2023-03-02T01:38:40.575Z" title="发表于 2023-03-02 09:38:40">2023-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/12/12/SRAM%E8%AE%BE%E8%AE%A1/" title="SRAM设计">SRAM设计</a><time datetime="2022-12-12T14:57:04.669Z" title="发表于 2022-12-12 22:57:04">2022-12-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/12/11/%E7%89%88%E5%9B%BE/" title="版图">版图</a><time datetime="2022-12-11T12:13:51.445Z" title="发表于 2022-12-11 20:13:51">2022-12-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By zmaiLee</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div class="moon-menu">
  <div class="moon-menu-items">
    
    <div id="moon-menu-item-back2bottom" class="moon-menu-item">
      <i class='fas fa-chevron-down'></i>    </div>
    
    <div id="moon-menu-item-back2top" class="moon-menu-item">
      <i class='fas fa-chevron-up'></i>    </div>
    
  </div>
  <div class="moon-menu-button">
    <svg class="moon-menu-bg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle>
    </svg>
    <div class="moon-menu-content">
      <div class="moon-menu-icon"><i class='fas fa-ellipsis-v'></i></div>
      <div class="moon-menu-text"></div>
    </div>
  </div>
</div><script src="/js/injector.js"></script></body></html>