<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>3D堆叠</title>
    <url>/2023/03/03/3D%E5%A0%86%E5%8F%A0/</url>
    <content><![CDATA[<h1 id="d堆叠的出现"><strong>3D堆叠的出现</strong></h1>
<p>现代芯片的功能越来越复杂，芯片尺寸也越来越大，导致工艺技术越来越复杂，由此带来了成本问题：不但制造成本高，设计成本也越来越高。为了应对这个问题，很多人想到了使用模块化设计方法，即把功能块分离成小型模块，做成一个个高良率、低成本的芯粒，然后根据需要灵活组装起来，即把芯片合理剪裁到各种不同的应用。</p>
<p>近年来，学术界和产业界都在进行芯粒的研发工作。芯粒一般可以通过2.5D架构的中介层来组装或堆叠。2.5D技术是指将多块芯片粒在<strong>硅载片（silicon
interposer）</strong>上使用互联线连接在一起，由于硅载片上的互联线密度可以远高于传统PCB上的互联线密度，因此可以实现高性能互联。其典型的技术即TSMC推出的CoWoS，InFO以及Intel的EMIB等技术。</p>
<p>而传统的3D
IC技术则是将多块芯片堆叠在一起，并使用<strong>TSV技术</strong>将不同的芯片做互联。目前，3D
IC主要用在内存芯片之间的堆叠架构和传感器的堆叠，而2.5D技术则已经广泛应用在多款高端芯片组中。另外3D和2.5D之间也不是完全对立，例如在<strong>HBM内存</strong>中，多块内存之间使用3D
IC集成，而内存与主芯片之间则使用2.5D技术集成在一起。</p>
<p>通过调整放置在一个芯片封装中的芯粒数量，就可以创建不同规模的系统，大大提升了系统设计的灵活性和可扩展性，同时也大大降低了研发成本，缩短了研发周期。</p>
<span id="more"></span>
<h1 id="什么是3d堆叠技术"><strong>什么是3D堆叠技术？</strong></h1>
<p>3D堆叠技术是利用堆叠技术或通过互连和其他微加工技术在芯片或结构的<strong>Z轴方向上形成三维集成</strong>，信号连接以及晶圆级，芯片级和硅盖封装具有不同的功能。针对包装和可靠性技术的三维堆叠处理技术。该技术用于微系统集成，是在片上系统（SOC）和多芯片模块（MCM）之后开发的先进的系统级封装制造技术。</p>
<p>所谓的3D堆叠技术其实很好理解，就是在原本的封装体里面，封装进两个以上不同功能的芯片，一般都是在不改变原本的封装体积大小，而在垂直方向进行的芯片叠放，这种技术所带来的特点就是改变了原有的在单位面积上不断增加晶体管的方式，而是在垂直方向上进行芯片叠放，自然也会实现芯片的功能多样化。</p>
<p>总体上看，3D堆叠技术在<strong>集成度、性能、功耗</strong>等方面更具优势，同时设计自由度更高，开发时间更短，是各封装技术中最具发展前景的一种。当前，随着高效能运算、人工智能等应用兴起，加上用于提供多个晶圆垂直通信的TSV技术愈来愈成熟，可以看到越来越多的CPU、GPU和存储器开始采用3D堆叠技术。</p>
<p>在传统的SiP封装系统中，任何芯片堆栈都可以称为3D，因为在Z轴上功能和信号都有扩展，无论堆栈位于IC内部还是外部。</p>
<h1 id="amd-的-zen-3"><strong>AMD 的 Zen 3</strong></h1>
<figure>
<img src="3D堆叠.assets/v2-e97d3c77e5f25517bb8a3cbc6bf750bb_720w.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>AMD 的 3D V-Cache 技术将一个 64 MB的 SRAM 缓存 [红色]
和两个空白结构小芯片连接到 Zen 3 计算小芯片上。</p>
<p>尽管Zen 2和新的Zen
3处理器内核都使用相同的台积电制造工艺制造——因此具有相同尺寸的晶体管、互连和其他一切——AMD
进行了如此多的架构改动，这让他们即使没有额外的高速缓存的前提下，Zen
3也能平均提供 19% 的性能提升。其中一个架构瑰宝是包含一组硅通孔
(TSV)，垂直互连直接穿过大部分硅。TSV 构建在 Zen 3 的L3
级别缓存中，它位于计算小芯片的中间，并在其所有八个内核之间共享。</p>
<p>在用于数据繁重工作负载的处理器中，Zen 3 晶圆的背面被减薄，直到 TSV
暴露出来。然后使用所谓的混合键合将一个 64 兆字节的 SRAM
小芯片键合到那些暴露的 TSV
上——这一过程类似于将铜冷焊在一起。结果是一组密集的连接可以紧密到 9
微米。最后，为了结构稳定性和热传导，附加空白硅芯片以覆盖 Zen 3 CPU
芯片的其余部分。</p>
<p>通过将额外的内存设置在 CPU
芯片旁边来添加额外的内存不是一种选择，因为数据需要很长时间才能到达处理器内核。“尽管
L3 [缓存] 大小增加了三倍，但 3D V-Cache 仅增加了四个 [时钟]
周期的延迟——这只能通过 3D 堆叠来实现，” AMD 高级设计工程师 John
Wuu表示。</p>
<p>更大的缓存在高端游戏中占有一席之地。使用台式机锐龙 CPU 和 3D V-Cache
可将 1080p 的游戏速度平均提高
15%。它也适用于更严肃的工作，将困难的半导体设计计算的运行时间缩短了
66%。</p>
<p>与缩小逻辑的能力相比，业界缩小 SRAM
的能力正在放缓。因此，您可以预期未来的 SRAM
扩展包将继续使用更成熟的制造工艺制造，而计算芯片则被推向摩尔定律的前沿。</p>
<p>台积电3D WoW硅晶圆堆叠技术</p>
]]></content>
      <categories>
        <category>微电子工艺</category>
      </categories>
      <tags>
        <tag>3D堆叠</tag>
      </tags>
  </entry>
  <entry>
    <title>CadenceEDA</title>
    <url>/2022/12/09/CadenceEDA/</url>
    <content><![CDATA[<ul>
<li><p><strong>IC618</strong> for xxx</p></li>
<li><p>xxx for xxx</p></li>
<li><p>xxx for xxx</p></li>
</ul>
<span id="more"></span>
<h1 id="第一章virtuoso使用">第一章：Virtuoso使用</h1>
<h2 id="virtuoso使用">Virtuoso使用</h2>
<p>新项目attach工艺库 tools→ tech file manager→attach→可以重新关联工艺库
新库 →右键property查看其它这个库的相关属性
如何用脚本快速配置工业库：1）找到该脚本liblnit.il
文件，注意一定是il后缀的，终端打开 pwd查看路径，
2）在virturoso的CIS窗口，输入 load "pwd路径+liblnit.il"
3）既可以自动配置库 Tips:选中某个库时候，可以不用勾选其他的库，ckt
文件不一定要勾选</p>
<h2 id="schematic">Schematic</h2>
<table>
<thead>
<tr class="header">
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>I</td>
<td>添加元件</td>
</tr>
<tr class="even">
<td>C</td>
<td>复制</td>
</tr>
<tr class="odd">
<td>M</td>
<td>移动</td>
</tr>
<tr class="even">
<td>Shift+M</td>
<td>移动器件但连线保持不变&lt;</td>
</tr>
<tr class="odd">
<td>F</td>
<td>整体居中显示</td>
</tr>
<tr class="even">
<td>右键拉框</td>
<td>放大该区域</td>
</tr>
<tr class="odd">
<td>U</td>
<td>撤销上一次操作</td>
</tr>
<tr class="even">
<td>R</td>
<td>旋转或</td>
</tr>
<tr class="odd">
<td>9</td>
<td>高亮选中节点所有连线</td>
</tr>
<tr class="even">
<td>S</td>
<td>存盘</td>
</tr>
<tr class="odd">
<td>W</td>
<td>wire</td>
</tr>
<tr class="even">
<td>P</td>
<td>添加port</td>
</tr>
<tr class="odd">
<td>L</td>
<td>添加label</td>
</tr>
<tr class="even">
<td>Q</td>
<td>属性编辑</td>
</tr>
<tr class="odd">
<td>E 查看底层电路</td>
<td></td>
</tr>
<tr class="even">
<td>Ctrl+E 返回顶层电路</td>
<td></td>
</tr>
<tr class="odd">
<td>Shift+R</td>
<td>镜像</td>
</tr>
<tr class="even">
<td>X</td>
<td>save and check</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="simulation">Simulation</h2>
<h2 id="layout">Layout</h2>
<ul>
<li>F4：单独调线宽模式</li>
<li>S：移动</li>
<li>O：放置contact</li>
<li>P：</li>
<li>R：</li>
<li>K：标尺</li>
</ul>
<p>AA有源层 NW 为N＃ DNW为P# GT 栅极 SN N型注入 SP为P型注入 M1234
为金属层 V表示过孔<br />
DRW表示可以画的层</p>
<p>先选择元件→connectivity→pick from schematic shift +f 显示所有的层
ctrl+f 只显示最外层边框 打散层 edit→hercany→flatten→pin</p>
<p>option→display 更改间距 layout过程中 P+F3可以修改线宽 快捷键K
调出尺子使用 Shift+K清楚所有标识层 R画矩形的快捷键
Shift+Z逐步缩小所画的版图 ctrl＋Z逐步放大所画的版图 O快速画出过孔
点击一下滑轮进行元器件的旋转 延长/拉动
连线/器件：首先按F4，让状态栏处的“(F)select”变成“(P)select”，接着按S，点击前面选中的器件，然后拉动，就可以延长连线了
L增加标签</p>
<h2 id="drccalibre使用">DRC→Calibre使用</h2>
<h2 id="工艺库文件">工艺库文件</h2>
<p>tech.db</p>
<p>techfile.tf</p>
<p>display.drf</p>
<ol type="1">
<li>techfile.tf 内为自然语言，可以用vim等工具直接编辑，tech.db
经过编译。</li>
<li>函数 <code>tcLoadTechFile(d_tech t_techfile)</code>
并不会修改上述任意一个文件，只会写入虚拟内存，需要 save 才能写入 tech.db
。</li>
<li>Virtuoso启动时自动加载的不是techfile.tf
，而是<strong>tech.db</strong></li>
<li>display.drf中含有一个个的 Packet，理解为颜色包 ，techfile 含有 Layer
与 Packet 的对应关系。因此 Packet 像是一个“纽带”，把 display.drf
中的颜色信息跟 techfile 中定义的 Layer Purpose Pair ( lpp )
联系起来。</li>
</ol>
<p><a href="https://www.cnblogs.com/yeungchie/p/13406021.html">Virtuoso
] display.drf、techfile.tf、tech.db 之间的关系，以及 Packet
在它们之间的作用 - YEUNGCHIE - 博客园 (cnblogs.com)</a></p>
<h1 id="数模混合仿真流程">数模混合仿真流程</h1>
<h2 id="新建cell">1.新建cell</h2>
<p><strong>file—new—cellview</strong></p>
<p>cell type：Verilog</p>
<p>编辑器：text editor</p>
<h2 id="产生symbol">2.产生symbol</h2>
<p>按照verilog要求，编写verilog代码并产生symbol</p>
<h2 id="建立-analog---digital-混合仿真原理图">3.建立 Analog - Digital
混合仿真原理图</h2>
<p>新建cell type选择
schematic。在schematic中导入之前生成的symbol。加入时钟信号，地。暂时不用考虑数字模块的电源电压，后续仿真会设置。如果跟模拟模块联合仿真，按照正常步骤添加模拟symbol即可。</p>
<p><strong>如果输出端口为多位数据，可以将对应label命名为out&lt;n:0&gt;这种格式，表明输出有n+1位</strong></p>
<h2 id="建立-analog---digital-混合仿真config文件">4.建立 Analog -
Digital 混合仿真config文件</h2>
<p>创建 Cellview ，名字要与混合仿真的schematic的名字相同。Type要选
config。这样在View中也是 config。 或者在library
manager界面选中仿真原理图cell后，点击file——new——cellview。此时cell的名称自动为count4_test,但type为config</p>
<h1 id="cadence-ams数模混合仿真">Cadence AMS数模混合仿真</h1>
<p>以实现一个全加器为例，复现一次混合信号电路的仿真过程。通过Verilog
实现半加器的功能，通过外加逻辑门（模拟电路） 实现整体的全加器功能。</p>
<h2 id="建立数字模块">1、建立数字模块</h2>
<figure>
<img src="CadenceEDA.assets/20200508220432143.png" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img src="CadenceEDA.assets/20200508220513691.png"
alt="20200508220513691" />
<figcaption aria-hidden="true">20200508220513691</figcaption>
</figure>
<h1 id="verilog-aams系统设计与仿真">Verilog-A/AMS系统设计与仿真</h1>
<p>Verilog-ams是Verilog标准的模拟混合信号版本。开发的第一阶段是Verilog-A，描述模拟电路所必需的一组连续时间构造。这是基于SPICE的语言。Verilog-A并不打算直接与Verilog-HDL一起工作。相反，它是一种具有类似语法和相关语义的语言，旨在为模拟系统建模。</p>
<p>Verilog-A在1996年被OVI标准化。Verilog-AMS的最新版本是2.4，发布于2014年，基于IEEE
1364-2005。这将是它的最后一个版本，因为从那时起，Verilog已经被SystemVerilog取代。模拟扩展从来没有交给过IEEE。</p>
<p>工作组目前正在努力使Verilog-AMS与IEEE
1800的SystemVerilog保持一致，或者在新的SystemVerilog-AMS”标准中包含AMS能力。此外，工作正在进行中，重点关注社区要求的新功能和增强，以改进混合信号设计和验证，以及通过小组委员会将SystemVerilog断言扩展到模拟和混合信号设计。</p>
<p><a href="https://verilogams.com/index.html">Verilog-A/MS —
Documentation (verilogams.com)</a>
Verilog-AMS是一种硬件描述语言，可以对模拟和数字系统进行建模。Verilog-AMS语言的官方描述包含在Verilog-AMS语言参考手册中。本网站旨在成为你的Verilog-A和Verilog-AMS的快速参考指南。在这一点上，参考资料还不完整，但仍然很有用。随着时间的推移，参考材料应该填写并补充有用的应用注释和注释模型，这将帮助您学习更有效地使用Verilog-A/MS。重点是模拟和混合信号建模。</p>
<p>如果您正在寻找关于综合或Verilog语言的模糊角落的信息，您必须到别处寻找。我们的目标是使www.VerilogAMS.com成为您关于Verilog-A/MS的日常信息来源。请四处看看，并告诉你的朋友和同事。如果你有关于Verilog-AMS的问题，请在designers-guide.org的论坛上问他们。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>EDA</tag>
        <tag>模拟IC</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2022/10/19/Git/</url>
    <content><![CDATA[<h1 id="git">Git</h1>
<p>用git执行下面语句时报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git push -u origin master<br>error: failed to push some refs to ‘xxxxx’<br>hint: Updates were rejected because the tip of your current branch is behind<br>hint: its remote counterpart. Integrate the remote changes (e.g.<br>hint: ‘git pull …’) before pushing again.<br>hint: See the ‘Note about fast-forwards’ <span class="hljs-keyword">in</span> ‘git push --<span class="hljs-built_in">help</span>’ <span class="hljs-keyword">for</span> details.<br></code></pre></td></tr></table></figure>
<p>原因：<strong>Github端已经产生了commit没有同步到本地端</strong></p>
<span id="more"></span>
<p>1.使用强制push的方法，这样会使远程修改丢失</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git push -u origin master -f<br></code></pre></td></tr></table></figure>
<p>2.先将远程repository修改pull下来再push</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git pull origin master<br>git push -u origin master<br></code></pre></td></tr></table></figure>
<p>结果又报refusing to merge unrelated histories</p>
<p>解决方案</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git pull origin master --allow-unrelated-histories<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>DPI学习笔记</title>
    <url>/2022/10/30/DPI/</url>
    <content><![CDATA[<h1 id="dpi学习笔记">DPI学习笔记</h1>
<h2 id="一dpi前世-pli">一、DPI前世-PLI</h2>
<p>首先思考几个问题：</p>
<ul>
<li><p>用户如何获得Verilog描述的电路的内部<strong>数据结构信息</strong>?</p></li>
<li><p>EDA仿真器在仿真verilog的tb时，FSDB波形是如何生成的？</p></li>
<li><p>$display，$stop，$finish等系统函数,如何被不同EDA仿真器识别?</p></li>
</ul>
<p>除了底层描述硬件的能力，Verilog同样应该具有与上层交互的能力，基于此<strong>Verilog
PLI</strong>(Programming Language
Interface)应运而生，它是一种从Verilog代码调用C/C++函数的机制。可以说PLI的出现是Verilog语言在硬件设计方面如此成功的原因之一。
使用PLI，第三方公司和最终用户可以扩展商业Verilog仿真器的功能。在Verilog代码中调用的函数称为<strong>系统调用</strong>。内置系统函数的一个示例是$display，$stop，$finish等。
PLI允许用户创建自定义系统调用，这是Verilog语法不允许我们做的事情。基于PLI其实我们可以做的更多：</p>
<span id="more"></span>
<ul>
<li>功耗分析</li>
<li>代码覆盖率工具</li>
<li>修改Verilog仿真数据结构 - 更准确的延迟。</li>
<li>自定义输出显示</li>
<li>协同仿真。</li>
<li>设计调试工具。</li>
<li>仿真结果分析</li>
<li>C模型接口加速仿真</li>
<li>Testbench建模</li>
</ul>
<p>为了实现PLI的这些应用，C代码应该可以访问Verilog仿真器的内部数据结构。为方便起见，Verilog
PLI提供了一些称为acc例程或简单访问例程的东西。还有第二组例程，称为tf例程，或简称为任务和函数例程。
tf和acc是PLI 1.0例程，并且非常庞大且陈旧。</p>
<h3 id="vpi">VPI</h3>
<p>Verilog程序接口（VPI），最初称为PLI2.0，主要用于C编程语言的接口。它允许行为Verilog代码调用C函数，C函数调用标准Verilog系统任务。
Verilog程序接口是IEEE
1364编程语言接口标准的一部分;该标准的最新版本是从2005年开始的。VPI也取代了已弃用的PLI。</p>
<p>虽然PLI1被弃用而支持VPI（又名PLI2），但由于其广泛记录的tf_put，tf_get函数接口在许多verilog参考书中有所描述，因此PLI1仍常用于VPI。</p>
<p>综上所述：PLI有三个libraries, TF(task/function) interface,
ACC(access) interface, 以及VPI(Verilog Procedural
Interface)，三者的时间先后顺序是1985-1989-1995而前面两个已经在IEEE
1364-2005中被删除。</p>
<h3 id="pli的应用和维护问题">PLI的应用和维护问题</h3>
<p>写PLI例程，是件痛苦的事情，不仅需要好几个步骤，更让人头痛的是PLI三个库中提供的一大堆难记的标准例程名字。写完了，还必须再用checktf例程，calltf例程包一层，才能在verilog中调用。
另外一个问题，
就是谁来负责写这些PLI例程，通常情况下，不管是设计者还是验证人员通常都不需要了解仿真器生成的verilog数据结构。我们只是使用者，不是生产者。</p>
<p>编写PLI应用程序很难</p>
<ul>
<li>必须学习奇怪的PLI术语</li>
<li>必须了解PLI库中的内容</li>
<li>必须创建checktf例程，calltf例程等</li>
</ul>
<p>将PLI应用程序链接到仿真器很难</p>
<ul>
<li>涉及多个步骤</li>
<li>每个仿真器都不同</li>
<li>谁链接？设计工程师 or EDA工程师？</li>
<li>管理多个PLI应用程序很困难</li>
<li>PLI代码很少与二进制兼容</li>
<li>必须为每个仿真器重新编译</li>
</ul>
<p>综上，PLI的缺点它严重阻碍着设计者和验证者使用更高级的语言来加强verilog语言的功力，尤其是日益复杂的设计和验证工作迫切需要一种新的编程语言接口，为我们提供强大的生产力的时候。</p>
<p>SystemVerilog引入了<strong>DPI(Direct Programming
Interface</strong>)，能够更简洁的连接C/C++或者其他非<a
href="https://so.csdn.net/so/search?q=Verilog&amp;spm=1001.2101.3001.7020">Verilog</a>的编程语言。</p>
<h2 id="二dpi横空出世">二、DPI横空出世</h2>
<p>在2003年IEEE 1800 SV LRM
3.1a中提出了一种直接的编程语言接口DPI。SystemVerilog
DPI是将SystemVerilog与外部语言连接的一个接口。理论上外部语言可以是C，C
++，SystemC以及其他语言。但是现在，SystemVerilog仅为C语言定义了一个外部语言层。</p>
<p>DPI由两层组成：SystemVerilog层和外部语言层。两层都彼此隔离。实际使用哪种编程语言作为外语是透明的，与此接口的SystemVerilog端无关。</p>
<p>DPI标准源自两个专有接口，一个来自Synopsys公司的VCS
DirectC接口，另一个是来自Co-Design公司（已被Synopsys收购）的SystemSim
Cblend接口。这两个专有接口起初是为他们各自的仿真器开发的，
而不是一个能够工作在任何仿真器上的标准。后来Synopsys公司将这两个技术捐献给了Accellera组织，Accellera的SystemVerilog标准委员会把这两个捐献技术合并在一起，并定义了DPI接口的语义，使得DPI能够与任何Verilog仿真器一起工作。</p>
<h3 id="两者之间的关系">两者之间的关系</h3>
<p>DPI不是PLI的替代品。相反，他们的角色是互补的。
PLI和VPI将来会继续存在并蓬勃发展，这主要有两个原因。</p>
<ul>
<li>PLI和VPI是经过时间考验的方法确保了对仿真器数据库的保护。
PLI和VPI将继续提供访问设计数据的安全机制，同时保持仿真器数据库的完整性。</li>
<li>对于许多人来说，PLI在未来几年仍将是首选接口语言。有许多应用程序使用PLI和VPI编写。将维护这些遗留应用程序，创建新的附加组件，并且将出现全新的应用程序
-
全部使用PLI和VPI。在Accellera决定对整个SystemVerilog语言提供完整的VPI支持时，PLI也就证明了其顽强的生命力。你熟悉和喜爱的VPI方法现在将适用于SystemVerilog的整个对象集。</li>
</ul>
<h2 id="三为什么需要dpi">三、为什么需要DPI？</h2>
<p>DPI出现的动机是双重的。</p>
<p>方法论要求接口应该允许<strong>构建异构系统</strong>（设计或测试平台），其中一些组件可以用除SystemVerilog之外的语言（或更多语言）编写。</p>
<p>另一方面，需要一种简单有效的方法来连接通常用C或C++编写的现有代码，而不需要PLI或VPI的知识开销。</p>
<p><strong>DPI遵循黑盒的原则</strong>：组件的规范和实现明确分开，实际实现对系统的其余部分是透明的。因此，实现的实际编程语言也是透明的，尽管该标准仅定义了C链接语义。
SystemVerilog代码与外部语言之间的分离基于使用函数作为SystemVerilog中的自然封装单元。总的来说，任何函数都可以被视为一个黑盒子，并以透明的方式在SystemVerilog或外部语言中实现，而无需更改其调用。</p>
<p>现实世界中，C和C++应该是IC世界，最被广泛使用的高级编程语言，而且有很多开源的代码和工具都是C或者C++代码编写。按照DPI的方法论，我们理应为C和C++世界通往SV世界打开一扇门。</p>
<p>DPI是在SystemVerilog LRM 3.1a 2003中定义的关键字
DPI-C是在SystemVerilog IEEE 1800-2012中定义的关键字</p>
<p>目前DPI已弃用，应替换为DPI-C</p>
<p>DPI-C的出现使得SV和C之间的互动变得简单直接</p>
<ul>
<li>使用C函数作为SV函数/任务，反之亦然</li>
<li>直接调用C/C++库中的函数</li>
<li>直接将输入传递给函数</li>
<li>直接从C/C++函数接收返回值</li>
</ul>
<p>其是在验证领域，使用C/C++代码作为参考模型很普遍</p>
<ul>
<li>使用功能强大的OpenSSL、OpenCV等开源库</li>
<li>参考模型是由设计师或软件团队使用C/C++编写的</li>
<li>使用MATLAB生成DPI组件</li>
</ul>
<p>SystemVerilog可以调用C，C可以调用SV</p>
<ul>
<li>支持函数和任务</li>
<li>在协同仿真中很有用</li>
</ul>
<p>（1）在模块级乃至子系统级的验证，使用SV就完全够用了，而在更上面的层级，例如系统级，多采用大量的C代码组成。那么<strong>为了完成测试用例从子系统到系统级的复用</strong>，我们最好在子系统级开始就有意识地建立支持C测试的环境，并且使用一些基于C的测试用例，这样才能使得整体具有更好的复用性。</p>
<p>（2）处理器的需要。子系统测试时，不一定本身自带了处理器的硬件实例(Verilog编写的)，因此在构建子系统时还要考虑如何模拟外部处理器对子系统的访问行为。当然，我们直接加上一个外部的处理器实例是完全可以的，等验证完子系统的功能后再撤掉就行。注意，这个处理器实例也是verilog编写的。但是，这种方法也存在了一些弊端：即使这个外部处理器再小巧，但硬件体积还是过大了，肯定会影响整个仿真的速度；针对不同子系统的预留接口(APB/AHB/AXI等)，处理器子系统也要进行对应的调整吧；这种真实的处理器，必然要处理C代码，所以要进行编译、转换成二进制bin文件以及下载到memory中，还是太麻烦；还需要额外的启动配置文件，而且仿真时需要额外的额时间进行初始化。总结一下真实处理器的弊端，那就是麻烦，处理C代码也繁琐，影响了仿真速度。</p>
<h2 id="四dpi基础">四、DPI基础</h2>
<h3 id="数据类型转换">4.1数据类型转换</h3>
<h4 id="数据映射关系">数据映射关系</h4>
<p>当SV与C环境交互时，会发生数据交换。
数据需要在两端以完全相同的方式解释，否则通信将失败。
SystemVerilog和C之间的数据交换通常使用DPI-C接口完成，该接口标准化类型对应关系和基本API（另请参见仿真器安装路径下的svdpi.h）。</p>
<p>大多数SystemVerilog数据类型在C语言中具有直接的对应关系，而其他（例如，4值类型，数组）需要DPI-C定义的类型和API。</p>
<p>通过DPI传递的每个变量都有两个相匹配的定义，一个在SV中，一个在C语言中。
在使用中必须，确认使用的是兼容的数据类型。<strong>C输出数据给SV，只能通过指针的方式输出</strong>。所以输出数据也是在SV中建立空间，然后在C中得到指针，将值写进去，这样C的内存空间的控制不会影响到SV端。</p>
<table>
<colgroup>
<col style="width: 37%" />
<col style="width: 32%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">SystemVerilog</th>
<th>C(input)</th>
<th>C(output)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">byte</td>
<td>char</td>
<td>char*</td>
</tr>
<tr class="even">
<td style="text-align: left;">shortint</td>
<td>short int</td>
<td>short int*</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int</td>
<td>int</td>
<td>int*</td>
</tr>
<tr class="even">
<td style="text-align: left;">longint</td>
<td>long int</td>
<td>long int*</td>
</tr>
<tr class="odd">
<td style="text-align: left;">shortreal</td>
<td>float</td>
<td>float*</td>
</tr>
<tr class="even">
<td style="text-align: left;">real</td>
<td>double</td>
<td>double*</td>
</tr>
<tr class="odd">
<td style="text-align: left;">string</td>
<td>const char*</td>
<td>char**</td>
</tr>
<tr class="even">
<td style="text-align: left;">string[n]</td>
<td>const char**</td>
<td>char**</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bit</td>
<td>svBit(unsigned char)</td>
<td>svBit*(unsigned char)</td>
</tr>
<tr class="even">
<td style="text-align: left;">logic, reg</td>
<td>svLogic</td>
<td>svLogic*</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bit[N:0]</td>
<td>const svBitVecVal*</td>
<td>svBitVecVal*</td>
</tr>
<tr class="even">
<td style="text-align: left;">logic[N:0], reg[N:0]</td>
<td>const svLogicVecVal*</td>
<td>svLogicVecVal*</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Open array[] (import only)</td>
<td>const svOpenArrayHandle</td>
<td>svOpenArrayHandle</td>
</tr>
<tr class="even">
<td style="text-align: left;">chandle</td>
<td>const void*</td>
<td>void*</td>
</tr>
</tbody>
</table>
<p>DPI调入C函数返回值，SV LRM推荐使用<strong>small values</strong>
：void,byte,shortint,int,longint,real,shortreal,chandle,string,bit,logic</p>
<p>不推荐使用bit[6:0]或者logic[6:0]这样的值，因为这样需要返回一个svBitVecVal或者svLogicVecVal的指针。</p>
<h4 id="四值逻辑变量转换关系"><strong>四值逻辑变量转换关系</strong></h4>
<p>假设SV一侧有一个logic
f，那么它在C一侧，会用一个无符号的字节来保存。分为aval和bval，其中aval保存在最低位，bval保存在紧邻的高位。</p>
<table>
<thead>
<tr class="header">
<th>四状态值</th>
<th>bval</th>
<th>aval</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="odd">
<td>Z</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="even">
<td>X</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>1’b0 -&gt; 0x0，1’b1 -&gt; 0x1，1’bz -&gt; 0x2，1’bx -&gt; 0x3</p>
<p>logic[31:0]
word，采用一对32bit的变量来表示，aval[31:0]与bval[31:0]。</p>
<p>在导入数组时，需要同时赋值aval和bval，如data[31:0]，例如要将data[0]=1，那么需要data[0].aval=1,
data[0].bval=0;</p>
<h3 id="接口调用">4.2接口调用</h3>
<p>通过import声明C任务和函数的原型：</p>
<ul>
<li><strong>带有返回值</strong>的C函数被映射成一个sv的<strong>function</strong></li>
<li><strong>void类型</strong>的C函数被映射为一个sv的<strong>task</strong>或<strong>void
function</strong></li>
</ul>
<p>如果C函数名和SV中的命名冲突，可以在import导入时，赋予新的函数名。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> test(); <br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> test=<span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_test(); <span class="hljs-comment">//将C中的test-&gt;my_test</span><br></code></pre></td></tr></table></figure>
<h4 id="参数传递">参数传递</h4>
<p>在C和SV中有两种传递参数的方法：</p>
<ul>
<li>按值传递：被调用者函数将使用来自调用者的参数的副本</li>
<li>通过引用传递：被调用者函数将使用来自调用者的参数的指针/引用</li>
</ul>
<p>如果函数正在更改其参数的值，则仅当参数通过引用传递时，更改才会在函数外部可见。
当参数按值传递时，对函数内部完成的参数的任何更改都不会在其外部可见。</p>
<p>在SystemVerilog中，按值或按引用传递由参数方向确定。
在C中，通过值或引用传递是由参数类型是否为指针确定的。
默认情况下，SV和C都按值传递参数。</p>
<p>导入的C函数参数可以作为输入，输出或inout（双向）</p>
<ul>
<li>输入的行为就像在调用时复制到C函数中一样，C函数不应修改输入参数</li>
<li>当函数返回时，输出的行为就像复制到Verilog中一样</li>
<li>Inouts的行为就像在调用中复制一样，并在返回时复制出来</li>
</ul>
<p>除非另有说明，否则假定参数为输入</p>
<p>SV提供了丰富的数据类型可以作为参数：</p>
<ul>
<li>void, byte, shortint, int, longint, real, shortreal, chandle, time,
integer, and string</li>
<li>Scalar values of type bit and logic</li>
<li>Packed arrays, structs, and unions composed of types bit and
logic</li>
<li>Types constructed from the supported types with the help of the
constructs: struct , union , Unpacked array , typedef</li>
</ul>
<p>返回值数据类型：</p>
<ul>
<li>void, byte, shortint, int, longint, real, shortreal, chandle, and
string</li>
<li>Scalar values of type bit and logic</li>
<li>Restrictions apply for import and export functions</li>
</ul>
<h4 id="参数方向">参数方向</h4>
<blockquote>
<p>对于参数方向，支持<strong>input,
output以及inout</strong>。<strong>Ref则不被支持</strong>。<strong>默认是input</strong></p>
<p>例子：Import “DPI-C” function int add(input int a, b, output int
sum);</p>
</blockquote>
<h4 id="导入方式"><strong>导入方式</strong></h4>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">import</span> “DPI-C” <span class="hljs-keyword">context</span> <span class="hljs-keyword">task</span> core0_thread();<br></code></pre></td></tr></table></figure>
<ul>
<li><p>pure：函数严格根据输入来计算输出，跟外部环境没有其它交互。作为pure函数，函数的结果必须仅仅依赖于通过形参传递进来的数值。优点在于仿真器可以执行优化以改进仿真性能。Pure函数不能使用全局或者静态变量，不能执行文件I/O操作，不能访问操作系统环境变量，不能调用来自Verilog
PLI
库的函数。<strong>只有没有输出或者inout的非void函数（必须有return值）可以被指定成pure。Pure函数不能作为Verilog任务导入。</strong></p></li>
<li><p>context：表示的是<strong>关联导入</strong>，关联类型会导致额外的开销。context
C函数明确函数声明所在工作域的Verilog的层次。可以是void函数，可以有输出和inout参数，可以从C库调用函数（用于文件I/O等)，可以调用PLI库中的许多函数，这使得被导入的C函数能够调用来自PLI或者VPI库的函数，从而DPI函数可以充分利用PLI的优势特性，比如写仿真器的log文件以及Verilog源代码打开的文件。</p></li>
<li><p>generic：函数使用了全局变量，但没有调用任何的PLI（缺省下为此类型）。本文把那些既没有明确声明为pure，也没有声明为context的函数称为generic函数(SystemVerilog标准没有给除了pure或context之外的函数特定的称呼)。generic
C函数可以作为Verilog函数或者Verilog任务导入。任务或者函数可以由输入、输出以及inout的参数。函数可以有一个返回值，或者声明为void。generic
C函数不允许调用Verilog
PLI函数，不能访问除了参数以外的任何数据，只能修改这些参数。</p></li>
</ul>
<p><strong>正确的声明导入的函数为pure还是context是用户的责任</strong>。缺省情况下，DPI函数假定是generic函数。调用一个不正确声明成pure的C函数可能返回不正确或者不一致的结果，导致不可预测的运行时错误，甚至于让仿真崩溃。同样，如果一个C函数访问Verilog
PLI库或者其他API库，却没有声明为context函数，会导致不可预见的仿真结果甚至仿真崩溃。</p>
<h4 id="导出方式"><strong>导出方式</strong></h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">export “DPI-C” function sv_display;<br></code></pre></td></tr></table></figure>
<p>注意后面不需要加括号和参数，如果需要改变名字，则可以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">export “DPI-C” dpi_writew = task writew;<br></code></pre></td></tr></table></figure>
<p>而在C一侧，则只需要extern void sv_display();</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> dpi_writew(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> addr, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> data);<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> dpi_readw(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> addr, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *data);<br></code></pre></td></tr></table></figure>
<h4 id="绑定别名">绑定别名</h4>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> gloval_name_space;<br>    <span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span>  <span class="hljs-keyword">context</span> <span class="hljs-keyword">task</span> sv_import_task ();<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> gloval_name_space1;<br>	<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span>  <span class="hljs-keyword">context</span> C_task1=<span class="hljs-keyword">task</span> sv_import_task ();<br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-keyword">module</span> gloval_name_space2;<br>	<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span>  <span class="hljs-keyword">context</span> C_task2=<span class="hljs-keyword">task</span> sv_import_task ();<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">export</span> <span class="hljs-string">&quot;DPI-C&quot;</span> f_plus = <span class="hljs-keyword">function</span> f ; <span class="hljs-comment">// &quot;f&quot; exported as &quot;f_plus&quot;</span><br><span class="hljs-keyword">export</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-keyword">function</span> f; <span class="hljs-comment">// &quot;f&quot; exported under its own name</span><br></code></pre></td></tr></table></figure>
<p>C的命名空间是全局可见的。sv_import_task中的声明变为等于C的链接名称。
对于所有模块，名称必须是唯一的。 C的链接是全局性的。因此，
上面是一种别名C链接名称的方法。
SV上的名称相同，但在C上，使用别名C_task1和C_task2执行链接。</p>
<h4 id="dpi-各种使用方式">DPI 各种使用方式</h4>
<ul>
<li>通过import定义的函数可以在任何位置</li>
<li>在Verilog模块中</li>
<li>在SystemVerilog interface中</li>
<li>在SystemVerilog package中</li>
<li>在SystemVerilog“编译单元”中</li>
<li>import声明必须具有参数的原型</li>
<li>必须与C函数中的参数数完全匹配</li>
<li>必须指定兼容的数据类型</li>
<li>可以在多个位置导入相同的C功能</li>
<li>每个原型必须完全相同</li>
<li>更好的方法是在包中定义一个导入</li>
</ul>
<h3 id="常用数据类型映射">4.3常用数据类型映射</h3>
<ul>
<li>SV byte -&gt; C char</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_byte(input byte i_value, output byte result);<br>import &quot;DPI-C&quot; function byte get_byte(input byte i_value);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_byte</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> i_value, <span class="hljs-type">char</span>* result)</span>;<br><span class="hljs-type">char</span> <span class="hljs-title function_">get_byte</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> i_value)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>SV shortint -&gt; C short int</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_shortint(input shortint i_value, output shortint result);<br>import &quot;DPI-C&quot; function shortint get_shortint(input shortint i_value);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_shortint</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> i_value, <span class="hljs-type">short</span> <span class="hljs-type">int</span>* result)</span>;<br><span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_shortint</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> i_value)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>SV int -&gt; C int</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_int(input int i_value, output int result);<br>import &quot;DPI-C&quot; function int get_int(input int i_value);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_int</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> i_value, <span class="hljs-type">int</span>* result)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">get_int</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> i_value)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>SV longint -&gt; C long int</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_longint(input longint i_value, output longint result);<br>import &quot;DPI-C&quot; function longint get_longint(input longint i_value);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_longint</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> i_value, <span class="hljs-type">long</span> <span class="hljs-type">int</span>* result)</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_longint</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> i_value)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>SV real -&gt; C double</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_real(input real i_value, output real result);<br>import &quot;DPI-C&quot; function real get_real(input real i_value);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_real</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> i_value, <span class="hljs-type">double</span>* result)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">get_real</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> i_value)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>SV string -&gt; C char*</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_string(input string i_value, output string result);<br>import &quot;DPI-C&quot; function string get_string(input string i_value);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_string</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* i_value, <span class="hljs-type">char</span>** result)</span>;<br><span class="hljs-type">char</span>* <span class="hljs-title function_">get_string</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* i_value)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>SV chandle -&gt; C void*</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_chandle(output chandle result);<br>import &quot;DPI-C&quot; function chandle get_chandle();<br>import &quot;DPI-C&quot; function void call_chandle(input chandle i_value, output int result);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_chandle</span><span class="hljs-params">(<span class="hljs-type">void</span>** result)</span>;<br><span class="hljs-type">void</span>** <span class="hljs-title function_">get_chandle</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">call_chandle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* i_value, <span class="hljs-type">int</span>* o_value)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>SV bit -&gt; C svbit</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_bit(input bit i_value, output bit result);<br>import &quot;DPI-C&quot; function bit get_bit(input bit i_value);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_bit</span><span class="hljs-params">(<span class="hljs-type">const</span> svBit i_value, svBit* result)</span>;<br>svBit <span class="hljs-title function_">get_bit</span><span class="hljs-params">(<span class="hljs-type">const</span> svBit i_value)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>SV bit[n:0] -&gt; C svBitVecVal</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_bit_vector(input bit[`BIT_ARRAY_SIZE - 1 : 0] i_val, output bit[`BIT_ARRAY_SIZE - 1 : 0] result);<br>import &quot;DPI-C&quot; function bit[`BIT_ARRAY_SIZE - 1 : 0] get_bit_vector(input bit[`BIT_ARRAY_SIZE - 1 : 0] i_val);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_bit_vector</span><span class="hljs-params">(<span class="hljs-type">const</span> svBitVecVal* i_value, svBitVecVal* result)</span>;<br>svBitVecVal <span class="hljs-title function_">get_bit_vector</span><span class="hljs-params">(<span class="hljs-type">const</span> svBitVecVal* i_value)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>SV logic -&gt; C svLogic</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_logic(input logic i_value, output logic result);<br>import &quot;DPI-C&quot; function logic get_logic(input logic i_value);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_logic</span><span class="hljs-params">(<span class="hljs-type">const</span> svLogic i_value, svLogic* result)</span>;<br>svLogic <span class="hljs-title function_">get_logic</span><span class="hljs-params">(<span class="hljs-type">const</span> svLogic i_value)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>SV reg -&gt; C svLogic</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_reg(input reg i_value, output reg result);<br>import &quot;DPI-C&quot; function reg  get_reg(input reg i_value);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_reg</span><span class="hljs-params">(<span class="hljs-type">const</span> svLogic i_value, svLogic* result)</span>;<br>svLogic <span class="hljs-title function_">get_reg</span><span class="hljs-params">(<span class="hljs-type">const</span> svLogic i_value)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>SV logic[n:0] -&gt; C svLogicVecVal</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_logic_vector(input logic[`LOGIC_ARRAY_SIZE - 1 : 0] i_val, output logic[`LOGIC_ARRAY_SIZE - 1 : 0] result, input int asize);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br>svLogicVecVal*  <span class="hljs-title function_">get_logic_vector</span><span class="hljs-params">(<span class="hljs-type">const</span> svLogicVecVal* i_value, <span class="hljs-type">int</span> asize)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>SV reg[n:0] -&gt; C svLogicVecVal</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_reg_vector(input reg[\`REG_ARRAY_SIZE - 1 : 0] i_val, output reg[\`REG_ARRAY_SIZE - 1 : 0] result, input int asize);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_reg_vector</span><span class="hljs-params">(<span class="hljs-type">const</span> svLogicVecVal* i_value, svLogicVecVal* result, <span class="hljs-type">int</span> asize)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>SV int[] -&gt; C svOpenArrayHandle</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_unsized_int_array(input int i_value[], output int result[]);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_unsized_int_array</span><span class="hljs-params">(<span class="hljs-type">const</span> svOpenArrayHandle i_value, svOpenArrayHandle result)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>SV struct -&gt; C struct</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">// SV<br>`define BIT_ARRAY_SIZE 16<br>typedef struct &#123;<br>	byte aByte;<br>	int anInt;<br>	bit aBit;<br>	longint aLongInt;<br>	bit[`BIT_ARRAY_SIZE-1:0] aBitVector;<br>&#125; dpi_c_ex_s;<br>import &quot;DPI-C&quot; function void compute_struct(input dpi_c_ex_s i_value, output dpi_c_ex_s result);<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dpi_c_ex_s</span> &#123;</span><br>	<span class="hljs-type">char</span> aChar;<br>	<span class="hljs-type">int</span> anInt;<br>	svBit aBit;<br>	<span class="hljs-type">long</span> <span class="hljs-type">int</span> aLongInt;<br>	svBitVecVal aBitVector;<br>&#125; dpi_c_ex_s;<br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_struct</span><span class="hljs-params">(<span class="hljs-type">const</span> dpi_c_ex_s* i_value, dpi_c_ex_s* output)</span>;<br></code></pre></td></tr></table></figure>
<h2 id="五dpi进阶">五、DPI进阶</h2>
<h4 id="压缩数组packed-arrays">5.1压缩数组（Packed arrays）</h4>
<p>压缩数组被视为数组和单个值，既可以访问整个值，也可以将其分成更小的元素。与非压缩的数组不同，它存储为一组连续的没有未使用空间的位。可以方便地将其作为数组元素进行访问。</p>
<p><strong>压缩数组：在数据类型标识符名称之前声明的维度</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">bit [7:0] p; // packed array of scalar bit types<br>bit [3:0][7:0] bytes // 4 bytes packed into 32-bits<br></code></pre></td></tr></table></figure>
<p>具有预定义宽度的整数类型不能声明为带维度的压缩数组。
这些类型是byte，shortint，int，longint，integer和time。
虽然是具有预定义宽度n的整数类型，它不是一个打包数组，但其自身是可以分解为子字段的，可以理解为一个具有单个[n-1:0]维度的压缩数组类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">byte c2; // same as bit signed [7:0] c2;`<br>integer i1; // same as logic signed [31:0] i1;<br></code></pre></td></tr></table></figure>
<h4 id="非压缩数组unpacked-arrays">5.2非压缩数组（Unpacked arrays）</h4>
<p>非压缩数组可以由任何数据类型组成。每个固定大小的维度应由地址范围[0:size-1]或单个正数[size]表示，以指定固定大小的非压缩数组的大小。</p>
<p><strong>非压缩数组：在数据类型标识符名称后声明的维度</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">bit u [7:0];<br>int Array[0:7][0:31]; // array declaration using ranges<br>int Array[8][32]; // array declaration using sizes<br></code></pre></td></tr></table></figure>
<p>SV 索引 [min：max] -&gt; C端数组索引从0开始</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">SV: a[1:7] -&gt; C: a[7]<br>SV: a[1] -&gt; C: a[0], SV a[7] -&gt; C: a[6]<br></code></pre></td></tr></table></figure>
<p>SV压缩数组被当做一维数组对待</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">//SV: a[l][m][n] -&gt; C: a[n+m*k+l*j*k]<br>bit[5:2]a; a[5]=1 a[4]=0 a[3]=1 a[2]=0; -&gt; C: a=10<br></code></pre></td></tr></table></figure>
<p><strong>所有数据类型最终都等同于最多32位的压缩数组</strong> SV byte
-&gt; C int，只使用低8位 <strong>C char数组无法映射到SV
byte类型的非压缩数组</strong></p>
<h4 id="混合压缩和非压缩的数组">5.3混合压缩和非压缩的数组</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">bit [3:0] Bytes [0:2] [0:5]<br></code></pre></td></tr></table></figure>
<figure>
<img src="DPI.assets/bfa1d0786bdd9d9435609c5734afe49a.png" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h4
id="sv_packed_data_nelemswidth">5.4SV_PACKED_DATA_NELEMS（width）</h4>
<p>该宏将位转换为元素数，在bit和word之间转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">include <span class="hljs-string">&quot;svdpi.h&quot;</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">packet_C</span><span class="hljs-params">(<span class="hljs-type">const</span> svLogicVecVal* packet)</span> &#123;<br>   <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span>  elements=SV_PACKED_DATA_NELEMS(<span class="hljs-number">128</span>);<br>   svLogicVecVal mem[elements];<br><br>   <span class="hljs-built_in">memcpy</span>(mem,packet,<span class="hljs-keyword">sizeof</span>(mem));<br>   io_printf(“C: data from SV side\n<span class="hljs-string">&quot;);</span><br><span class="hljs-string">   for (unsigned i=0;i&lt; elements;i++)&#123;</span><br><span class="hljs-string">      io_printf(&quot;</span>mem[%<span class="hljs-number">2</span>d]=&#123;%<span class="hljs-number">4</span>x,%<span class="hljs-number">4</span>x&#125;\n<span class="hljs-string">&quot;,i,mem[i].aval,mem[i].bval);</span><br><span class="hljs-string">   &#125;    </span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">module test;<br>import &quot;DPI-C&quot; function void packet_C( input logic [127:0]);<br><br>   logic [127:0] packet;<br>   initial　begin<br>      packet=128&#x27;h1234_5678_aaaa_bbbb_cccc_dddd_eeee_ffff;<br>      $display(“SV: data sent to C side: %x&quot;,packet);<br>      packet_C(packet);<br>   end<br><br>endmodule<br></code></pre></td></tr></table></figure>
<h4 id="bit和logic标量和矢量的使用">5.5bit和logic标量和矢量的使用</h4>
<p>在svdpi.h的头文件中，有如下自定义类型声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint8_t</span> svScalar;<br><span class="hljs-keyword">typedef</span> svScalar svBit; <span class="hljs-comment">/* scalar */</span><br><span class="hljs-keyword">typedef</span> svScalar svLogic; <span class="hljs-comment">/* scalar */</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> svBitVecVal;<br><br>Typedef <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>     <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> aval;<br>     <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bval;<br>&#125; svLogicVecVal;<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;svdpi.h&gt;</span> </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(svLogic a)</span>&#123; <br>	<span class="hljs-keyword">if</span>(a == <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; a is 0 \n&quot;</span>);<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a == <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; a is 1 \n&quot;</span>);<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a == <span class="hljs-number">2</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; a is x \n&quot;</span>);<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a == <span class="hljs-number">3</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; a is z \n&quot;</span>);<br>&#125; <br><span class="hljs-type">void</span>  <span class="hljs-title function_">displaylogicvec</span><span class="hljs-params">(svLogicVecVal *n)</span> &#123;<br>       <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot; data = %d control = %d\n&quot;</span>, n-&gt;aval, n-&gt;bval) ; <br>&#125;<br><br><span class="hljs-type">void</span>  <span class="hljs-title function_">displaybitvec</span><span class="hljs-params">(<span class="hljs-type">const</span> svBitVecVal *k)</span> &#123; <br>       <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot; data = %d\n &quot;</span>, k) ; <br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="在dpi中使用压缩数组packed-arrays">5.6在DPI中使用压缩数组（Packed
Arrays）</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;svdpi.h&quot;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_nums</span> <span class="hljs-params">(svLogicVecVal nums[<span class="hljs-number">10</span>])</span>&#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;<br>    nums[i] = i ;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">program main; <br>import &quot;DPI-C&quot; function void get_nums(output logic [15:0] nums[10]); <br>logic [15:0] nums[10]; <br><br>initial begin <br>	get_nums(nums); <br>	foreach (nums[i]) <br>		$display(i,nums[i]); <br>end <br>  <br>endprogram <br></code></pre></td></tr></table></figure>
<h4 id="dpi中使用开放数组open-arrays">5.7DPI中使用开放数组（Open
arrays）</h4>
<p>压缩数组维度，非压缩维度或两个维度的大小可以保持未指定，这种情况称为开放数组（或未定义大小的数组）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">include &lt;stdio.h&gt;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;svdpi.h&gt;</span> </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">pass_array</span><span class="hljs-params">(<span class="hljs-type">const</span> svOpenArrayHandle dy_ar )</span> &#123; <br>  <span class="hljs-type">int</span> i; <br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Array Pointer is %x \n&quot;</span>, svGetArrayPtr(dyn_arr) ); <br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Lower index %d \n&quot;</span>, svLow(dyn_arr,<span class="hljs-number">1</span>)); <br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Higher index %d \n&quot;</span>, svHigh(dyn_arr, <span class="hljs-number">1</span>) ); <br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Left index %d \n&quot;</span>, svLeft(dyn_arr,<span class="hljs-number">1</span>)); <br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Right index %d \n&quot;</span>, svRight(dyn_arr, <span class="hljs-number">1</span>) ); <br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Length of array %d \n&quot;</span>, svLength(dyn_arr,<span class="hljs-number">1</span>) ); <br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Incremental %d \n&quot;</span>,svIncrement(dyn_arr,<span class="hljs-number">1</span>)); <br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Dimentions of Array %d \n&quot;</span>, svDimensions(dyn_arr )); <br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Size of Array in bytes %d \n&quot;</span>, svSizeOfArray(dyn_arr) ); <br>  <span class="hljs-keyword">for</span> (i= svRight(dy_ar,<span class="hljs-number">1</span>); i &lt;= svLeft(dy_ar,<span class="hljs-number">1</span>); i++) &#123; <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;C: %d %d \n&quot;</span>, i, *(<span class="hljs-type">int</span>*)svGetArrElemPtr1(dy_ar, i) ); <br>  &#125; <br>&#125; <br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">program main; <br>int fxd_arr_1[8:3]; <br>int fxd_arr_2[12:1]; <br>import &quot;DPI-C&quot; context function void pass_array(input int dyn_arr[] ); <br><br>initial begin <br>	for (int i = 3; i&lt;=8 ; i++) begin <br>		fxd_arr_1[i] = $random(); <br>		$display(&quot;SV:fxd_arr_1 %0d %d &quot;,i, fxd_arr_1[i] ); <br>	end <br>	pass_array( fxd_arr_1 ); <br><br>	for (int i = 1; i&lt;=12 ; i++) begin <br>		fxd_arr_2[i] = $random() ; <br>		$display(&quot;SV: fxd_arr_2 %0d %d &quot;,i, fxd_arr_2[i] ); <br>	end <br>	pass_array( fxd_arr_2 ); <br><br>end <br>endprogram<br></code></pre></td></tr></table></figure>
<ul>
<li>Passing fxd_arr_1 to C Array Pointer is 80fdc58 Lower index 3 Higher
index 8 Left index 8 Right index 3 Length of array 6 Incremental 1
Dimentions of Array 1 Size of Array in bytes 24</li>
<li>Passing fxd_arr_2 to C Array Pointer is 80fdc70 Lower index 1 Higher
index 13 Left index 1 Right index 13 Length of array 13 Incremental -1
Dimentions of Array 1 Size of Array in bytes 52</li>
</ul>
<p><strong>开放数组提供了一系列查询和访问数组的方法</strong></p>
<table>
<colgroup>
<col style="width: 54%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr class="header">
<th>function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>int svLeft(const svOpenArrayHandle h, int d);</td>
<td>Left bound for dimension d</td>
</tr>
<tr class="even">
<td>int svRight(h, d)</td>
<td>Right bound for dimension d</td>
</tr>
<tr class="odd">
<td>int svLow(h, d)</td>
<td>Low bound for dimension d</td>
</tr>
<tr class="even">
<td>int svHigh(h, d)</td>
<td>High bound for dimension d</td>
</tr>
<tr class="odd">
<td>int svIncrement(h, d)</td>
<td>If left &gt;= right 1 else -1</td>
</tr>
<tr class="even">
<td>int svSize(h, d)</td>
<td>Number of elements in dimension d: svHigh−svLow+1</td>
</tr>
<tr class="odd">
<td>int svDimensions(h)</td>
<td>Number of dimensions in open array</td>
</tr>
<tr class="even">
<td>int svSizeOfArray(h)</td>
<td>Total size of array in bytes</td>
</tr>
<tr class="odd">
<td>void *svGetArrayPtr(const svOpenArrayHandle h)</td>
<td>storage for the entire array</td>
</tr>
<tr class="even">
<td>void svGetArrElemPtr(const svOpenArrayHandle h, int i1, …)</td>
<td>an element in the array</td>
</tr>
<tr class="odd">
<td>void *svGetArrElemPtr1(h, i1)</td>
<td>an element in a 1-D array</td>
</tr>
<tr class="even">
<td>void *svGetArrElemPtr2(h, i1, i2)</td>
<td>an element in a 2-D array</td>
</tr>
<tr class="odd">
<td>void *svGetArrElemPtr3(h, i1, i2, i3)</td>
<td>an element in a 3-D array</td>
</tr>
</tbody>
</table>
<h4 id="在dpi中使用结构体">5.8在DPI中使用结构体</h4>
<p>在传递<code>struct</code>数据类型时，数据被打包到数组中并从SV传递到C，然后数组被解码回到C中的<code>struct</code>中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;svdpi.h&quot;</span> </span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123; <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span> <br>  <span class="hljs-type">int</span> a; <br>  <span class="hljs-type">int</span> b; <br>  <span class="hljs-type">char</span> c; <br>&#125; C_struct; <br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">export_func</span><span class="hljs-params">(svBitVecVal x[<span class="hljs-number">3</span>])</span>; <br><span class="hljs-type">void</span> <span class="hljs-title function_">import_func</span><span class="hljs-params">()</span> &#123; <br>  C_struct s_data; <br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>]; <br><br>  s_data.a = <span class="hljs-number">51</span>; <br>  s_data.b = <span class="hljs-number">242</span>; <br>  s_data.c = <span class="hljs-number">35</span>; <br>  <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;C : s_data.a = %d\n&quot;</span>, s_data.a ); <br>  <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;C : s_data.b = %d\n&quot;</span>, s_data.b ); <br>  <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;C : s_data.c = %d\n&quot;</span>, s_data.c ); <br><br>  arr[<span class="hljs-number">0</span>] = s_data.a ; <br>  arr[<span class="hljs-number">1</span>] = s_data.b ; <br>  arr[<span class="hljs-number">2</span>] = s_data.c ; <br>  export_func(arr); <br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">program main; <br><br>export &quot;DPI-C&quot; function export_func; <br>import &quot;DPI-C&quot; function void import_func(); <br><br>typedef struct packed&#123; <br>  int a; <br>  int b; <br>  byte c; <br>&#125; SV_struct; <br><br>function void export_func(input int arr[3]); <br>	SV_struct s_data; <br><br>  s_data.a = arr[0]; <br>  s_data.b = arr[1]; <br>  s_data.c = arr[2]; <br>  $display(&quot; SV: s_data.a = %0d&quot;, s_data.a ); <br>  $display(&quot; SV: s_data.b = %0d&quot;, s_data.b ); <br>  $display(&quot; SV: s_data.c = %0d \n&quot;, s_data.c ); <br>endfunction <br><br>initial begin <br>	import_func(); <br>end <br><br>endprogram<br></code></pre></td></tr></table></figure>
<p>在SV和C/C++代码使用定义的未压缩的结构体数据类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;svdpi.h&quot;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><br>	<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>		<span class="hljs-type">int</span> a;<br>		<span class="hljs-type">int</span> b;<br>	&#125;mystruct;<br>	<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">mydisplay</span><span class="hljs-params">(mystruct *s1)</span>&#123;<br>		<span class="hljs-type">int</span> s2;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;C: gets values from SV, s1.a=%d, s1.b=%d\\\\\\\\\\\\\\\\n&quot;</span>,s1-&gt;a,s1-&gt;b);<br>		s1-&gt;a = <span class="hljs-number">100</span>;<br>		s1-&gt;b = <span class="hljs-number">200</span>;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;C: set values,  s1.a=%d, s1.b=%d\\\\\\\\\\\\\\\\n&quot;</span>,s1-&gt;a,s1-&gt;b);<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">program p1;<br>	typedef struct &#123;<br>		int a;<br>		int b;<br>	&#125; mystruct;<br><br>	import &quot;DPI-C&quot; function void mydisplay(inout mystruct s1);<br>	mystruct s1;<br>	initial begin<br>		s1.a =10;<br>		s1.b =20;<br>		$display(&quot;SV: s1.a=%0d,s1.b=%0d&quot;,s1.a,s1.b);<br>	<br>		mydisplay(s1);<br>		$display(&quot;SV after DPI call: s1.a=%0d,s1.b=%0d&quot;,s1.a,s1.b);<br>	end <br><br>endprogram<br></code></pre></td></tr></table></figure>
<p>试着将上面例子中sv端结构体，改为packed类型，试试看C端打印信息会是什么样的？</p>
<p>压缩的结构体是包含packed保留字的结构体。 在结构内，保证了位连续性。
因此，成员也必须是矢量类型。 （不要混合real /
shortreal。）如果混合使用2值或者4值逻辑，它们将在内存布局方面生成4个值，因此不要混用它们。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;svdpi.h&quot;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(svBitVecVal*)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">struct_operation</span><span class="hljs-params">()</span>&#123;<br>   svBitVecVal rgb;<br>   svPutPartselBit(&amp;rgb,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>);<span class="hljs-comment">//b</span><br>   svPutPartselBit(&amp;rgb,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>);<span class="hljs-comment">//g</span><br>   svPutPartselBit(&amp;rgb,<span class="hljs-number">3</span>,<span class="hljs-number">16</span>,<span class="hljs-number">8</span>);<span class="hljs-comment">//r</span><br>   func(&amp;rgb);<br>   svBitVecVal blue=<span class="hljs-number">0</span>;<br>   svBitVecVal red=<span class="hljs-number">0</span>;<br>   svBitVecVal green=<span class="hljs-number">0</span>;<br>   svGetPartselBit(&amp;blue,&amp;rgb,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>);<br>   svGetPartselBit(&amp;green,&amp;rgb,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>);<br>   svGetPartselBit(&amp;red,&amp;rgb,<span class="hljs-number">16</span>,<span class="hljs-number">8</span>);<br><br>   io_printf(<span class="hljs-string">&quot;C: data from SV side. red %3d green %3d blue %3d.\\\\\\\\\\\\\\\\n&quot;</span>,red,green,blue);<br><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs systemverilog">module root_scope;<br>    export &quot;DPI-C&quot; function func;<br>    import &quot;DPI-C&quot; context task struct_operation();<br><br>   typedef struct packed &#123;<br>      byte red;//MSB<br>      byte green;<br>      byte blue;//LSB ↑<br>   &#125; RGB_TYPE;<br><br>   function void func(inout RGB_TYPE A);<br>      $display(&quot;SV: data from C side. red=%3d blue=%3d green=%3d.&quot;,A.red,A.green,A.blue);<br>      A.blue=101;<br>      A.green=102;<br>      A.red=103;<br>      $display(&quot;SV: data change for C side read.&quot;);<br>          <br>   endfunction<br><br>   initial begin<br>      struct_operation();<br>   end<br><br>endmodule<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>基础课程</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
        <tag>DPI-C</tag>
      </tags>
  </entry>
  <entry>
    <title>IC后端</title>
    <url>/2022/11/09/IC%E5%90%8E%E7%AB%AF/</url>
    <content><![CDATA[<h1 id="第一章标准单元库">第一章：标准单元库</h1>
<h2 id="hvtsvtlvt">HVT/SVT/LVT</h2>
<p>High Vt、Standard Vt（也有称为Regular Vt，即RVT)、Low
Vt。Vt阈值电压越低，因为饱和电流变小，所以速度性能越高；但是因为漏电流会变大，因此功耗会变差。</p>
<span id="more"></span>
<h2 id="pvt">PVT</h2>
<p>Process、Voltage、Temperature</p>
<h2 id="multi-channel-library">multi-channel library</h2>
<p>对应不同的gate-length，即沟道长度。例如，UMC28nm的SVTmin 相对
SVTmax，性能增加20%，静态功耗增加80%。</p>
<h2 id="t9t12t">7T/9T/12T</h2>
<p>T，代表track，是单元库的版图规则，作为一个计量单位。</p>
<p>7T/9T/12T分别对应ultra-high-density（for lowest power in SOC
blocks）、high-density（for highest density in GPU
blocks）、high-speed（for highest performance in CPU blocks）。</p>
<p>标准单元库的单元高度，基本都是固定的，方便版图的布局；高度，通常以track作为计量单位
pitch=minSpacing+minWidth。</p>
<p>grid是单元库里，与工艺制造精度相关的名称。一般pin都放置在grid上，工艺在版图上的最小精度。</p>
<figure>
<img src="IC后端.assets/SouthEast.png" alt="这里写图片描述" />
<figcaption aria-hidden="true">这里写图片描述</figcaption>
</figure>
<h2 id="推荐的单元库选择方法">推荐的单元库选择方法</h2>
<p><img src="IC后端.assets/SouthEast-16679659616183.png"
alt="img" /><strong>HLP</strong>，high performance low power；
<strong>HPC</strong>，high performace compact。
28nmHLP的core电压，是1.05V；HPC的core电压，则是0.9V。</p>
<figure>
<img src="IC后端.assets/SouthEast-16679660832146.png" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
]]></content>
      <categories>
        <category>基础课程</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>计算机体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile学习笔记</title>
    <url>/2022/11/19/Makefile/</url>
    <content><![CDATA[<h1 id="makefile学习笔记">Makefile学习笔记</h1>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># Check for sanity to avoid later confusion</span><br><span class="hljs-keyword">ifneq</span> (<span class="hljs-variable">$(words <span class="hljs-variable">$(CURDIR)</span>)</span>,1)<br> <span class="hljs-variable">$(<span class="hljs-built_in">error</span> Unsupported: GNU Make cannot build in directories containing spaces, build elsewhere: &#x27;<span class="hljs-variable">$(CURDIR)</span>&#x27;)</span><br><span class="hljs-keyword">endif</span><br><br><span class="hljs-comment"># This is intended to be a minimal example.  Before copying this to start a</span><br><span class="hljs-comment"># real project, it is better to start with a more complete example,</span><br><span class="hljs-comment"># e.g. examples/make_tracing_c.</span><br><br><span class="hljs-comment"># If $VERILATOR_ROOT isn&#x27;t in the environment, we assume it is part of a</span><br><span class="hljs-comment"># package install, and verilator is in your path. Otherwise find the</span><br><span class="hljs-comment"># binary relative to $VERILATOR_ROOT (such as when inside the git sources).</span><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(VERILATOR_ROOT)</span>,)<br>VERILATOR = verilator<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">export</span> VERILATOR_ROOT<br>VERILATOR = <span class="hljs-variable">$(VERILATOR_ROOT)</span>/bin/verilator<br><span class="hljs-keyword">endif</span><br><br><span class="hljs-section">default:</span><br>	@echo <span class="hljs-string">&quot;-- Verilator hello-world simple example&quot;</span><br>	@echo <span class="hljs-string">&quot;-- VERILATE &amp; BUILD --------&quot;</span><br>	<span class="hljs-variable">$(VERILATOR)</span> -cc --exe --build -j top.v sim_main.cpp<br>	@echo <span class="hljs-string">&quot;-- RUN ---------------------&quot;</span><br>	obj_dir/Vtop<br>	@echo <span class="hljs-string">&quot;-- DONE --------------------&quot;</span><br>	@echo <span class="hljs-string">&quot;Note: Once this example is understood, see examples/make_tracing_c.&quot;</span><br>	@echo <span class="hljs-string">&quot;Note: Also see the EXAMPLE section in the verilator manpage/document.&quot;</span><br><br></code></pre></td></tr></table></figure>
<span id="more"></span>
<p><code>$@</code>目标文件，<code>$^</code>所有的依赖文件，<code>$&lt;</code>第一个依赖文件</p>
<p>这个规则表示所有的 .o文件都是依赖与相应的.c文件的</p>
<h1 id="basename-names">$(basename NAMES…)</h1>
<p>函数名称：取前缀函数—basename。
函数功能：从文件名序列“NAMES…”中取出各个文件名的前缀部分。前缀部分指的是文件名中最后一个点号之前的部分。
返回值：空格分割的文件名序列“NAMES…”中各个文件的前缀序列。如果文件没有前缀，则返回空字串。</p>
<h1 id="notdir-names">$(notdir NAMES…)</h1>
<p>剥离文件的绝对路径，只保留文件名</p>
<h1 id="addprefix-前缀-待加前缀的">$(addprefix 前缀 待加前缀的)。</h1>
<p>函数功能：为“NAMES…”中的每一个文件名添加前缀“PREFIX”。参数“NAMES…”是空格分割的文件名序列，将“SUFFIX”添加到此序列的每一个文件名之前。</p>
<p>返回值：以单空格分割的添加了前缀“PREFIX”的文件名序列。</p>
<p>示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> src/,foo bar)</span><br></code></pre></td></tr></table></figure>
<p>返回值为“src/foo src/bar”</p>
<h1
id="makefile使用-d选项更改宏定义记得要clean">Makefile使用-D选项更改宏定义，记得要clean</h1>
<p>1、Makefile文件，如下</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">CC_OPTS += -DMakefle_D=2<br><br><span class="hljs-section">all:testD</span><br>    echo <span class="hljs-string">&quot;done&quot;</span><br><span class="hljs-section">testD:testD.c</span><br>    gcc testD.c -o testD <span class="hljs-variable">$(CC_OPTS)</span><br></code></pre></td></tr></table></figure>
<p>2、testD.c文件，如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Makefle_D = %d\n&quot;</span>, Makefle_D);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>改动-DMakefle_D=2为-DMakefle_D=3或者-DMakefle_D=4，编译测试.发现改动后，testD.c并不会重新编译。所以在Makefile里面改宏定义，记得要clean</p>
<h1 id="makefile调用函数">Makefile调用函数</h1>
<p>调用GNU make的内置函数：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(function arguments)</span><br></code></pre></td></tr></table></figure>
<p>想调用用户自定义的函数，则只能使用call函数来间接调用：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">PHONY: all</span><br><span class="hljs-keyword">define</span> func    <br>	@echo <span class="hljs-string">&quot;pram1 = $(0)&quot;</span>    <br>	@echo <span class="hljs-string">&quot;pram2 = $(1)&quot;</span><br><span class="hljs-keyword">endef</span><br><span class="hljs-section">all:    </span><br>	<span class="hljs-variable">$(<span class="hljs-built_in">call</span> func, hello zhaixue.cc)</span><br></code></pre></td></tr></table></figure>
<p>给函数传递的参数，在函数内部可以使用<span
class="math inline">\((0)、\)</span>(1)…直接使用。call函数是唯一一个可以用来创建新的参数化的函数。call函数不仅可以用来调用一个用户自定义函数并传参，还可以向一个表达式传参：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">call</span> &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;...)</span><br></code></pre></td></tr></table></figure>
<p>当 make 执行这个函数时，expression表达式中的参数变量，如<span
class="math inline">\((1)，\)</span>(2)，$(3)等，会被参数parm1，parm2，parm3依次取代。而expression的返回值就是
call 函数的返回值。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: all</span><br>param = $(1) $(2)<br>reverse_param = $(2) $(1)<br>str1 = <span class="hljs-variable">$(<span class="hljs-built_in">call</span> param, hello, zhaixue.cc)</span><br>str2 = <span class="hljs-variable">$(<span class="hljs-built_in">call</span> reverse_param, hello, zhaixue.cc)</span><br><span class="hljs-section">all:    </span><br>	@echo <span class="hljs-string">&quot;str1 = <span class="hljs-variable">$(str1)</span>&quot;</span>    <br>	@echo <span class="hljs-string">&quot;str2 = <span class="hljs-variable">$(str2)</span>&quot;</span><br></code></pre></td></tr></table></figure>
<p>执行make命令，运行结果为：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># make</span><br>str1 =  hello  zhaixue.cc<br>str2 =  zhaixue.cc  hello<br></code></pre></td></tr></table></figure>
<h1 id="跟我一起写-makefile"><strong>跟我一起写 Makefile</strong></h1>
<p>https://blog.csdn.net/haoel/article/details/2886</p>
<h2 id="一.基础使用">一.基础使用</h2>
<h3
id="关于程序的编译和链接"><strong>1.关于程序的编译和链接</strong></h3>
<p><strong>编译(compile):</strong>把源文件编译成中间代码文件，在Windows
.obj 文件，UNIX .o 文件，即 Object
File。一般来说，每个源文件都应该对应于一个中间目标文件</p>
<p><strong>编译:</strong>把源文件编译成中间代码文件,Windows是 .obj
文件，UNIX是 .o 文件，即 Object File，每个源文件都对应o文件</p>
<p><strong>链接(link):</strong>把大量的Object File合成执行文件</p>
<p>链接时，主要是链接函数和全局变量，可以使用o文件来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的Object
File，在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，要给o文件打个包，在Windows下这种包叫“库文件”.lib（Library
File) ，在UNIX下，是Archive File， .a 文件</p>
<p>源文件首先生成.o，再由.o生成执行文件</p>
<p>在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object
File。而在链接程序时，链接器会在所有的Object
File中找寻函数的实现，如果找不到，会报链Linker
Error，链接器未能找到函数的实现。你需要指定函数的Object File.</p>
<h3 id="基本目标">2.基本目标</h3>
<p>1）如果这个工程没有编译过，那么所有C文件都要编译并被链接
2）如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序
3）如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">target ... : prerequisites ...<br>    command<br>    ...<br>    ...<br></code></pre></td></tr></table></figure>
<p>target:目标文件，可以是Object
File，也可以是执行文件。还可以是一个标签Label</p>
<p>prerequisites:要生成target所需要的文件或是目标。</p>
<p>command:make需要执行的命令。（任意的Shell命令）</p>
<p>prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行</p>
<h3 id="一个示例">3.一个示例</h3>
<p>执行文件edit</p>
<p>依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。</p>
<p>clean不是一个文件，代表makefile中定义的一个操作，有点像C语言中的lable一样，其冒号后什么也没有，make不会自动去找文件的依赖性，不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字如“make
clean”。我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">edit : main.o kbd.o command.o display.o /<br>    insert.o search.o files.o utils.o<br>    cc -o edit main.o kbd.o command.o display.o /<br>          insert.o search.o files.o utils.o<br>main.o : main.c defs.h<br>    cc -c main.c<br>kbd.o : kbd.c defs.h command.h<br>    cc -c kbd.c<br>command.o : command.c defs.h command.h<br>    cc -c command.c<br>display.o : display.c defs.h buffer.h<br>    cc -c display.c<br>insert.o : insert.c defs.h buffer.h<br>    cc -c insert.c<br>search.o : search.c defs.h buffer.h<br>    cc -c search.c<br>files.o : files.c defs.h buffer.h command.h<br>    cc -c files.c<br>utils.o : utils.c defs.h<br>    cc -c utils.c<br>clean :<br>    rm edit main.o kbd.o command.o display.o /<br>      insert.o search.o files.o utils.o<br></code></pre></td></tr></table></figure>
<h3 id="make是如何工作的">4.make是如何工作的</h3>
<p>1、make会在当前目录下找名字叫“Makefile”或“makefile”的文件。
2、如果找到，它会找文件中的第一个目标文件（target），如“edit”，并把这个文件作为最终的目标文件。
3、如果edit文件不存在，或是edit所依赖的后面的 .o
文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。
4、如果edit所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。</p>
<p>make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。make只管文件的依赖性，如果找了依赖关系之后，冒号后面的文件还是不在，那么对不起，make就不工作啦。</p>
<p>像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——“make
clean”，以此来清除所有的目标文件，以便重编译。</p>
<p>于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如file.c，那么根据我们的依赖性，我们的目标file.o会被重编译（也就是在这个依性关系后面所定义的命令），于是file.o的文件也是最新的啦，于是file.o的文件修改时间要比edit要新，所以edit也会被重新链接了</p>
<p>规则的顺序是很重要的，Makefile中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的，所以一定要让make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。</p>
<p>一般来说，make会以UNIX的标准Shell，也就是/bin/sh来执行命令</p>
<h3 id="makefile中使用变量">5.makefile中使用变量</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">edit : main.o kbd.o command.o display.o insert.o search.o files.o utils.o<br>   cc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o<br></code></pre></td></tr></table></figure>
<p>为了makefile的易维护，在makefile中可以使用变量。makefile的变量也就是一个字符串，理解成C语言中的宏</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o<br>edit : <span class="hljs-variable">$(objects)</span><br>     cc -o edit <span class="hljs-variable">$(objects)</span><br></code></pre></td></tr></table></figure>
<h3 id="让make自动推导">6.让make自动推导</h3>
<p>GNU的make可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。</p>
<p>只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且
cc -c whatever.c 也会被推导出来</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">main.o : defs.h<br>kbd.o : defs.h command.h<br>command.o : defs.h command.h<br>display.o : defs.h buffer.h<br>insert.o : defs.h buffer.h<br>search.o : defs.h buffer.h<br>files.o : defs.h buffer.h command.h<br>utils.o : defs.h<br><br>.PHONY : clean<br>clean :<br>    -rm edit <span class="hljs-variable">$(objects)</span><br></code></pre></td></tr></table></figure>
<p><strong>“.PHONY”表示，clean是个伪目标文件</strong>，在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。</p>
<p>我们并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。</p>
<p>当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。</p>
<p>伪目标一般没有依赖的文件，<strong>但也可以为伪目标指定所依赖的文件</strong>。伪目标同样可以作为“默认目标”，只要将其放在第一个。如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">all : prog1 prog2 prog3<br>.PHONY : all<br><br>prog1 : prog1.o utils.o<br>    cc -o prog1 prog1.o utils.o<br><br>prog2 : prog2.o<br>    cc -o prog2 prog2.o<br><br>prog3 : prog3.o sort.o utils.o<br>    cc -o prog3 prog3.o sort.o utils.o<br></code></pre></td></tr></table></figure>
<p>我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于伪目标的特性是，总是被执行的，所以其依赖的那三个目标就总是不如“all”这个目标新。所以，其它三个目标的规则总是会被决议。</p>
<p>目标也可以成为依赖。所以，<strong>伪目标同样也可成为依赖</strong>。看下面的例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: cleanall cleanobj cleandiff</span><br><br>cleanall : cleanobj cleandiff<br>    rm program<br><br>cleanobj :<br>    rm *.o<br><br>cleandiff :<br>    rm *.diff<br></code></pre></td></tr></table></figure>
<h3 id="另类风格的makefile">7.另类风格的makefile</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o<br>edit : <span class="hljs-variable">$(objects)</span><br>    cc -o edit <span class="hljs-variable">$(objects)</span><br><br><span class="hljs-variable">$(objects)</span> : defs.h<br>kbd.o command.o files.o : command.h<br>display.o insert.o search.o files.o : buffer.h<br><br>.PHONY : clean<br>clean :<br>    rm edit <span class="hljs-variable">$(objects)</span><br></code></pre></td></tr></table></figure>
<p>这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得凌乱了。</p>
<h3 id="makefile里有什么">8.Makefile里有什么？</h3>
<p>Makefile里主要包含了五个东西：<strong>显式规则、隐晦规则、变量定义、文件指示和注释</strong>。</p>
<p>1、显式规则：如何生成一个或多的的目标文件。要生成的文件，文件的依赖文件，生成的命令。</p>
<p>2、隐晦规则：由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书Makefile</p>
<p>3、变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。</p>
<p>4、文件指示：</p>
<ul>
<li><p>在一个Makefile中引用另一个Makefile，<code>include &lt;filename&gt;</code>,被包含的文件会原模原样的放在当前文件的包含位置</p></li>
<li><p>指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if；</p></li>
<li><p>定义一个多行的命令。</p></li>
</ul>
<p>5、注释。Makefile中只有行注释。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“/#”。</p>
<p><strong>在Makefile中的命令，必须要以[Tab]键开始</strong></p>
<p>如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，make还会在下面的几个目录下找：</p>
<p>1、如果make执行时，有<code>-I</code>或<code>--include-dir</code>参数，那么make就会在这个参数所指定的目录下去寻找。
2、如果目录<prefix>/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。</p>
<p>如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：</p>
<p><code>-include &lt;filename&gt;</code></p>
<h3 id="通配符">9.通配符</h3>
<p>定义一系列比较类似的文件，make支持三各通配符：<code>*</code>，<code>?</code>和<code>[...]</code>。这是和Unix的B-Shell是相同的。</p>
<p>通配符代替了一系列的文件，如“*.c”表示所以后缀为c的文件。如果我们的文件名中有通配符，如：<code>*</code>，那么可以用<code>/*</code>来表示真实的<code>*</code>字符，而不是任意长度的字符串。</p>
<p><code>objects = *.o</code>通符同样可以用在变量中。并不是说[*.o]会展开，不！objects的值就是“*.o”。Makefile中的变量其实就是C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有[.o]的文件名的集合，可以这样：<code>objects := $(wildcard *.o)</code></p>
<h2 id="二.文件搜寻">二.文件搜寻</h2>
<p>把源文件分类，并存放在不同的目录中。当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让mak在自动去找。</p>
<p>Makefile文件中的特殊变量<code>VPATH</code>就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当前目录找不到的情况下，到所指定的目录中去找。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">VPATH = src : ../headers<br></code></pre></td></tr></table></figure>
<p><code>src</code>和<code>../headers</code>，make会按照这个顺序进行搜索。目录由“冒号”分隔。</p>
<p>另一个设置文件搜索路径的方法是使用<code>make</code>的<code>vpath</code>关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，它可以指定不同的文件在不同的搜索目录中。</p>
<p>1、<code>vpath &lt;pattern&gt; &lt;directories&gt;</code>
<code>vpath %.h ../headers</code></p>
<p>为符合模式<pattern>的文件指定搜索目录<directories>。</p>
<p>2、<code>vpath &lt;pattern&gt;</code></p>
<p>清除符合模式<pattern>的文件的搜索目录。</p>
<p>3、<code>vpath</code></p>
<p>清除所有已被设置好了的文件搜索目录。</p>
<p>vapth使用方法中的<pattern>需要包含<code>%</code>字符。<code>%</code>的意思是匹配零或若干字符，例如，<code>%.h</code>表示所有以<code>.h</code>结尾的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">vpath %.c foo:bar<br>vpath %  blish<br></code></pre></td></tr></table></figure>
<p>而上面的语句则表示“.c”结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。</p>
<h2 id="三.多目标"><strong>三.多目标</strong></h2>
<p>Makefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令是同一个，可以使用一个自动化变量<code>$@</code>，表示目前规则中所有的目标的集合</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">bigoutput littleoutput : text.g<br>    generate text.g -<span class="hljs-variable">$(<span class="hljs-built_in">subst</span> output,,<span class="hljs-variable">$@</span>)</span> &gt; <span class="hljs-variable">$@</span><br><span class="hljs-comment">#上述规则等价于：</span><br>bigoutput : text.g<br>    generate text.g -big &gt; bigoutput<br>littleoutput : text.g<br>    generate text.g -little &gt; littleoutput<br></code></pre></td></tr></table></figure>
<p>其中，<code>-$(subst  output,,$@)</code>中的<code>$</code>表示执行一个Makefile的函数，函数名为subst，后面的为参数。这里的这个函数是截取字符串的意思，<code>$@</code>表示目标的集合，就像一个数组，<code>$@</code>依次取出目标，并执于命令。</p>
<p><strong>静态模式</strong>可以更加容易地定义多目标的规则</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">&lt;targets ...&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt;<br>    &lt;commands&gt;<br></code></pre></td></tr></table></figure>
<p>targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。</p>
<p>target-parrtern是指明了targets的模式，也就是的目标集模式。</p>
<p>prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。</p>
<p>如果我们的<target-parrtern>定义成<code>%.o</code>，意思是我们的<target>集合中都是以<code>.o</code>结尾的，而如果我们的<prereq-parrterns>定义成<code>%.c</code>，意思是对<target-parrtern>所形成的目标集进行二次定义，其计算方法是，取<target-parrtern>模式中的“%”（也就是去掉了[.o]这个结尾），并为其加上[.c]这个结尾，形成的新集合。</p>
<p>所以，我们的“目标模式”或是“依赖模式”中都应该有“%”这个字符</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">  objects = foo.o bar.o<br>  all: <span class="hljs-variable">$(objects)</span><br>  <span class="hljs-variable">$(objects)</span>: %.o : %.c<br>      <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br><span class="hljs-comment"># 等价于:</span><br>  foo.o : foo.c<br>      <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> foo.c -o foo.o<br>  bar.o : bar.c<br>      <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> bar.c -o bar.o<br></code></pre></td></tr></table></figure>
<p>上面的例子中，指明了我们的目标从<code>$object</code>中获取，<code>%.o</code>表明要所有以“.o”结尾的目标，也就是<code>foo.o bar.o</code>，也就是变量<code>$object</code>集合的模式，而依赖模式<code>%.c</code>则取模式<code>%.o</code>的<code>%</code>，也就是<code>foo  bar</code>，并为其加下<code>.c</code>的后缀，于是，我们的依赖目标就是<code>foo.c  bar.c</code>。而命令中的<code>$&lt;</code>和<code>$@</code>则是<strong>自动化变量</strong>，<code>$&lt;</code>表示所有的依赖目标集（也就是“foo.c
bar.c”），<code>$@</code>表示目标集（也就是“foo.o bar.o”）</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">files = foo.elc bar.o lose.o<br><br><span class="hljs-variable">$(<span class="hljs-built_in">filter</span> %.o,<span class="hljs-variable">$(files)</span>)</span>: %.o: %.c<br>    <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br><span class="hljs-variable">$(<span class="hljs-built_in">filter</span> %.elc,<span class="hljs-variable">$(files)</span>)</span>: %.elc: %.el<br>    emacs -f batch-byte-compile <span class="hljs-variable">$&lt;</span><br></code></pre></td></tr></table></figure>
<p><code>$(filter %.o,$(files))</code>表示调用Makefile的filter函数，过滤<code>$files</code>集，只要其中模式为<code>%.o</code>的内容。</p>
<h2 id="四.自动生成依赖性"><strong>四.自动生成依赖性</strong></h2>
<p>在Makefile中，我们的依赖关系可能会需要包含一系列的头文件</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">main.o : main.c  defs.h<br></code></pre></td></tr></table></figure>
<p>你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个<code>-M</code>的选项，即<strong>自动找寻源文件中包含的头文件</strong>，并生成一个依赖关系。</p>
<p>如果使用GNU的C/C++编译器，用<code>-MM</code>参数，<code>-M”</code>参数会把一些标准库的头文件也包含进来。</p>
<p>gcc -M main.c的输出是：</p>
<p>main.o: main.c defs.h /usr/include/stdio.h /usr/include/features.h /
/usr/include/sys/cdefs.h /usr/include/gnu/stubs.h /
/usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stddef.h /
/usr/include/bits/types.h /usr/include/bits/pthreadtypes.h /
/usr/include/bits/sched.h /usr/include/libio.h /
/usr/include/_G_config.h /usr/include/wchar.h /
/usr/include/bits/wchar.h /usr/include/gconv.h /
/usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stdarg.h /
/usr/include/bits/stdio_lim.h</p>
<p>gcc -MM main.c的输出则是：</p>
<p>main.o: main.c defs.h</p>
<p>GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个<code>name.c</code>的文件都生成一个<code>name.d</code>的Makefile文件，[.d]文件中就存放对应[.c]文件的依赖关系。</p>
<p>我们可以写出[.c]文件和[.d]文件的依赖关系，并让make自动更新或自成[.d]文件，并把其包含在我们的主Makefile中，我们给出了一个模式规则来产生[.d]文件：</p>
<p>%.d: %.c <span class="citation" data-cites="set">@set</span> -e; rm
-f $@; / $(CC) -M $(CPPFLAGS) <span class="math inline">\(&lt; &gt;
[\)</span>@.](mailto:<span class="math inline">\(@.\)</span><span
class="math display">\[$); /
       sed &#39;s,/($*/)/.o[ :]*,/1.o $@ : ,g&#39; &lt;
[$@.](mailto:$@.\]</span><span class="math display">\[) &gt; $@; /
       rm -f [$@.](mailto:$@.\]</span>$$)</p>
<p>这个规则的意思是，所有的[.d]文件依赖于[.c]文件，<code>rm -f  $@</code>的意思是删除所有的目标，也就是[.d]文件，第二行的意思是，为每个依赖文件<code>$&lt;</code>，也就是[.c]文件生成依赖文件，<code>$@</code>表示模式<code>%.d</code>文件，如果有一个C文件是name.c，那么<code>%</code>就是<code>name</code>，意为一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。</p>
<p>总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入[.d]文件的依赖，即把依赖关系：</p>
<p>main.o : main.c defs.h</p>
<p>转成：</p>
<p>main.o main.d : main.c defs.h</p>
<p>于是，我们的[.d]文件也会自动更新了，并会自动生成了，当然，你还可以在这个[.d]文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个[.d]文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。</p>
<p>sources = foo.c bar.c</p>
<p>include $(sources: .c = .d)</p>
<p>上述语句中的<code>$(sources:.c=.d)</code>中的<code>.c=.d</code>的意思是做一个替换，把变量<code>$(sources)</code>所有[.c]的字串都替换成[.d]，关于这个“替换”的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为include是按次来载入文件，最先载入的[.d]文件中的目标会成为默认目标。</p>
<h2 id="五.书写命令">五.书写命令</h2>
<h3 id="显示命令"><strong>显示命令</strong></h3>
<p>通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用<code>@</code>字符在命令行前，<strong>这个命令将不被make显示出来</strong>，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如：</p>
<p><span class="citation" data-cites="echo">@echo</span>
"正在编译XXX模块......"</p>
<p>当make执行时，会输出“正在编译XXX模块......”字串，但不会输出命令</p>
<p>如果make执行时，带入make参数<code>-n</code>或<code>--just-print</code>，那么其<strong>只是显示命令，但不会执行命令</strong>，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。</p>
<p>而make参数<code>-s</code>或<code>--slient</code>则是全面禁止命令的显示。</p>
<h3 id="命令执行"><strong>命令执行</strong></h3>
<p>当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：</p>
<p>示例一： exec: cd /home/hchen pwd</p>
<p>示例二： exec: cd /home/hchen; pwd</p>
<p>当我们执行“make
exec”时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出“/home/hchen”。</p>
<h3 id="命令出错"><strong>命令出错</strong></h3>
<p>每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。</p>
<p>有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。为了做到忽略命令的出错，我们可以在Makefile的命令行前加一个减号<code>-</code>（在Tab键之后），标记为不管命令出不出错都认为是成功的。如：</p>
<p>clean: -rm -f *.o</p>
<p>还有一个全局的办法是，给make加上<code>-i</code>或是<code>--ignore-errors</code>参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以<code>.IGNORE</code>作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。</p>
<p>make的参数<code>-k</code>或是<code>--keep-going</code>，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。</p>
<h3 id="嵌套执行make"><strong>嵌套执行make</strong></h3>
<p>在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。</p>
<p>例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么总控的Makefile可以这样书写：</p>
<p>subsystem: cd subdir &amp;&amp; $(MAKE)</p>
<p>其等价于：</p>
<p>subsystem: $(MAKE) -C subdir</p>
<p>定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行make命令。</p>
<p>总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了<code>-e</code>参数。</p>
<p>传递变量到下级Makefile中</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">export</span> &lt;variable ...&gt;<br><br><span class="hljs-keyword">export</span> variable = value<br><br><span class="hljs-comment"># 其等价于：</span><br><br><span class="hljs-keyword">export</span> variable := value<br><br><span class="hljs-comment"># 不让某些变量传递到下级Makefile中</span><br><br><span class="hljs-keyword">unexport</span> &lt;variable ...&gt;<br></code></pre></td></tr></table></figure>
<p>如果要传递所有的变量，只要一个export就行了。</p>
<p>SHELL和MAKEFLAGS，这两个变量不管你是否export，其总是要传递到下层Makefile中，特别是MAKEFILES变量，其中包含了make的参数信息，如果我们执行“总控Makefile”时有make参数或是在上层Makefile中定义了这个变量</p>
<p>但是make命令中的有几个参数并不往下传递，它们是<code>-C</code>,<code>-f</code>,<code>-h</code>,
<code>-o</code>和<code>-W</code>，如果你不想往下层传递参数，那么，你可以：</p>
<p>subsystem: cd subdir &amp;&amp; $(MAKE) MAKEFLAGS=</p>
<p>如果你定义了环境变量MAKEFLAGS，那么你得确信其中的选项是大家都会用到的，如果其中有“-t”,“-n”,和“-q”参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。</p>
<p>还有一个在“嵌套执行”中比较有用的参数，<code>-w</code>或是<code>--print-directory</code>会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是<code>/home/hchen/gnu/make</code>，如果我们使用<code>make -w</code>来执行，那么当进入该目录时，我们会看到：</p>
<p>make: Entering directory `/home/hchen/gnu/make'.</p>
<p>而在完成下层make后离开目录时，我们会看到：</p>
<p>make: Leaving directory `/home/hchen/gnu/make'</p>
<p>当你使用“-C”参数来指定make下层Makefile时，“-w”会被自动打开的。如果参数中有“-s”（“--slient”）或是“--no-print-directory”，那么，“-w”总是失效的。</p>
<h3 id="定义命令包"><strong>定义命令包</strong></h3>
<p>如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">define</span> run-yacc<br>yacc <span class="hljs-variable">$(<span class="hljs-built_in">firstword</span> <span class="hljs-variable">$^</span>)</span><br>mv y.tab.c <span class="hljs-variable">$@</span><br><span class="hljs-keyword">endef</span><br></code></pre></td></tr></table></figure>
<p>这里，<code>run-yacc</code>是这个命令包的名字，其不要和Makefile中的变量重名。在“define”和“endef”中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">foo.c : foo.y<br>    $(run-yacc)<br></code></pre></td></tr></table></figure>
<p>我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包<code>run-yacc</code>中的<code>$^</code>就是<code>foo.y</code>，<code>$@</code>就是<code>foo.c</code>,
make在执行命令包时，命令包中的每个命令会被依次独立执行。</p>
<h2 id="六.使用变量">六.使用变量</h2>
<p>可以在Makefile中改变变量值。在Makefile中，变量可以使用在“目标”，“依赖目标”，“命令”或是Makefile的其它部分中。</p>
<p>变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有<code>:</code>、<code>#</code>、<code>=</code>或是空字符（空格、回车等）。变量是大小写敏感的，<code>foo</code>、<code>Foo</code>和<code>FOO</code>是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。</p>
<h3 id="变量的基础"><strong>变量的基础</strong></h3>
<p>变量在声明时需要给予初值，在使用时，需要给在变量名前加上<code>$</code>符号，但最好用<code>()</code>或是<code>&#123;&#125;</code>把变量给包括起来。要使用真实的<code>$</code>字符，那么你需要用<code>$$</code>来表示。</p>
<p>变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。</p>
<h3 id="变量中的变量"><strong>变量中的变量</strong></h3>
<p>在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。</p>
<p>先看第一种方式左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">foo = <span class="hljs-variable">$(bar)</span><br>bar = <span class="hljs-variable">$(ugh)</span><br>ugh = Huh?<br><br><span class="hljs-section">all:</span><br>    echo <span class="hljs-variable">$(foo)</span><br></code></pre></td></tr></table></figure>
<p>这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，不好的地方是递归定义</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">CFLAGS = <span class="hljs-variable">$(include_dirs)</span> -O<br>include_dirs = -Ifoo -Ibar<br></code></pre></td></tr></table></figure>
<p>当“CFLAGS”在命令中被展开时，会是“-Ifoo -Ibar -O”</p>
<p>如果在变量中使用函数，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数“wildcard”和“shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。</p>
<p>为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是“:=”操作符，</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">x := foo<br>y := <span class="hljs-variable">$(x)</span> bar<br>x := later<br><span class="hljs-comment"># 其等价于：</span><br>y := foo bar<br>x := later<br></code></pre></td></tr></table></figure>
<p>这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifeq</span> (0,$&#123;MAKELEVEL&#125;)<br>cur-dir  := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span><br>whoami  := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> whoami)</span><br>host-type := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> arch)</span><br>MAKE := $&#123;MAKE&#125; host-type=$&#123;host-type&#125; whoami=$&#123;whoami&#125;<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure>
<p>系统变量“MAKELEVEL”，其意思是，如果我们的make有一个嵌套执行的动作，那么这个变量会记录了我们的当前Makefile的调用层数。</p>
<p>如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：</p>
<p>nullstring := space := $(nullstring) # end of the line</p>
<p>nullstring是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个Empty变量来标明变量的值开始了，而后面<strong>采用“#”注释符来表示变量定义的终止</strong>，这样，我们可以定义出其值是一个空格的变量。请注意这里关于“#”的使用，注释符“#”的这种特性值得我们注意，如果我们这样定义一个变量：</p>
<p><code>dir := /foo/bar  # directory to put the frobs in</code></p>
<p>dir这个变量的值是<code>/foo/bar</code>，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录就完蛋了。还有一个比较有用的操作符是<code>?=</code>，先看示例：</p>
<p><code>FOO ?= bar</code></p>
<p>其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(<span class="hljs-built_in">origin</span> FOO)</span>, undefined)<br> FOO = bar<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure>
<h3 id="变量高级用法"><strong>变量高级用法</strong></h3>
<p>第一种是变量值的替换。</p>
<p>我们可以替换变量中的共有的部分，其格式是<code>$(var:a=b)</code>或是<code>$&#123;var:a=b&#125;</code></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">foo := a.o b.o c.o<br>bar := $(foo: .o=.c)<br></code></pre></td></tr></table></figure>
<p>另外一种变量替换的技术是以“静态模式”定义的，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">foo := a.o b.o c.o<br>bar := $(foo:%.o=%.c)<br></code></pre></td></tr></table></figure>
<p>这依赖于被替换字串中的有相同的模式，模式中必须包含一个“%”字符</p>
<p>第二种高级用法是——“把变量的值再当成变量”。先看一个例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">x = y<br>y = z<br>a := $(<span class="hljs-variable">$(x)</span>)<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<span
class="math inline">\((x)的值是“y”，所以\)</span>(<span
class="math inline">\((x))就是\)</span>(y)，于是$(a)的值就是“z”。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">x = <span class="hljs-variable">$(y)</span><br>y = z<br>z = Hello<br>a := $(<span class="hljs-variable">$(x)</span>)<br></code></pre></td></tr></table></figure>
<p>这里的<span class="math inline">\((\)</span>(x))被替换成了<span
class="math inline">\((\)</span>(y))，因为<span
class="math inline">\((y)值是“z”，所以，最终结果是：a:=\)</span>(z)，也就是“Hello”。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">x = variable1<br>variable2 := Hello<br>y = <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> 1,2,<span class="hljs-variable">$(x)</span>)</span><br>z = y<br>a := $($(<span class="hljs-variable">$(z)</span>))<br></code></pre></td></tr></table></figure>
<p>这个例子中，“<span class="math inline">\((\)</span>(<span
class="math inline">\((z)))”扩展为“\)</span>(<span
class="math inline">\((y))”，而其再次被扩展为“\)</span>(<span
class="math inline">\((subst 1,2,\)</span>(x)))”。<span
class="math inline">\((x)的值是“variable1”，subst函数把“variable1”中的所有“1”字串替换成“2”字串，再取其值，\)</span>(a)的值就是$(variable2)的值——“Hello”。</p>
<p>在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">first_second = Hello<br>a = first<br>b = second<br>all = $($a_$b)<br></code></pre></td></tr></table></figure>
<p>这里的“<span
class="math inline">\(a_\)</span>b”组成了“first_second”，于是，$(all)的值就是“Hello”。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">a_objects := a.o b.o c.o<br>1_objects := 1.o 2.o 3.o<br>sources := $(<span class="hljs-variable">$(a1)</span>_objects:.o=.c)<br></code></pre></td></tr></table></figure>
<p>这个例子中，如果<span
class="math inline">\((a1)的值是“a”的话，那么，\)</span>(sources)的值就是“a.c
b.c c.c”；如果<span
class="math inline">\((a1)的值是“1”，那么\)</span>(sources)的值是“1.c
2.c 3.c”。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifdef</span> do_sort<br>func := sort<br><span class="hljs-keyword">else</span><br>func := strip<br><span class="hljs-keyword">endif</span><br>bar := a d b g q c<br>foo := $(<span class="hljs-variable">$(func)</span> <span class="hljs-variable">$(bar)</span>)<br></code></pre></td></tr></table></figure>
<p>这个示例中，如果定义了“do_sort”，那么：foo := <span
class="math inline">\((sort a d b g q c)，于是\)</span>(foo)的值就是“a b
c d g q”，而如果没有定义“do_sort”，那么：foo := $(sort a d b g q
c)，调用的就是strip函数。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">dir = foo<br><span class="hljs-variable">$(dir)</span>_sources := <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dir)</span>/*.c)</span><br><span class="hljs-keyword">define</span> <span class="hljs-variable">$(dir)</span>_print<br>lpr $(<span class="hljs-variable">$(dir)</span>_sources)<br><span class="hljs-keyword">endef</span><br></code></pre></td></tr></table></figure>
<h3 id="追加变量值"><strong>追加变量值</strong></h3>
<p>使用<code>+=</code>操作符给变量追加值，如：</p>
<p>objects = main.o foo.o bar.o utils.o objects += another.o</p>
<p><code>$(objects)</code>值变成：<code>main.o foo.o bar.o utils.o another.o</code></p>
<p>如果变量之前没有定义过，那么，“+=”会自动变成“=”，如果前面有变量定义，那么“+=”会继承于前次操作的赋值符。如果前一次的是“:=”，那么“+=”会以“:=”作为其赋值符，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">variable := value<br>variable += more<br></code></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">variable := value<br>variable := <span class="hljs-variable">$(variable)</span> more<br></code></pre></td></tr></table></figure>
<p>但如果是这种情况：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">variable = value<br>variable += more<br></code></pre></td></tr></table></figure>
<p>由于前次的赋值符是“=”，所以“+=”也会以“=”来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。</p>
<h3 id="override-指示符"><strong>override 指示符</strong></h3>
<p>如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是：</p>
<p>override <variable> = <value></p>
<p>override <variable> := <value></p>
<p>override <variable> += <more text></p>
<h3 id="多行变量"><strong>多行变量</strong></h3>
<p>使用define关键字设置变量的值可以有换行。define后面跟的是变量的名字，重起一行定义变量的值，以endef关键字结束。</p>
<p>变量的值可以包含<strong>函数、命令、文字，或是其它变量</strong>。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以[Tab]键开头，那么make就不会把其认为是命令。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">define</span> two-lines<br>echo foo<br>echo <span class="hljs-variable">$(bar)</span><br><span class="hljs-keyword">endef</span><br></code></pre></td></tr></table></figure>
<h3 id="环境变量"><strong>环境变量</strong></h3>
<p>make运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）</p>
<p>因此，如果我们在环境变量中设置了<code>CFLAGS</code>环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。<strong>如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量</strong>，如果没有定义则使用系统环境变量的值。</p>
<p>当make嵌套调用时，上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层Makefile传递，则需要使用exprot关键字来声明。</p>
<h3 id="目标变量"><strong>目标变量</strong></h3>
<p>Makefile中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量。“自动化变量”除外，如<code>$&lt;</code>等这种类量的自动化变量就属于“规则型变量”，这种变量的值<strong>依赖于规则的目标和依赖目标的定义</strong>。</p>
<p>当然，同样可以为某个目标设置局部变量，这种变量被称为“Target-specific
Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。</p>
<p>其语法是：</p>
<p>&lt;target ...&gt; : <variable-assignment></p>
<p>&lt;target ...&gt; : overide <variable-assignment></p>
<p><variable-assignment>可以是前面讲过的各种赋值表达式，如<code>=</code>、<code>:=</code>、<code>+=</code>或是<code>？=</code>。第二个语法是针对于make命令行带入的变量，或是系统环境变量。</p>
<p>这个特性非常的有用，当我们设置了这样一个变量，<strong>这个变量会作用到由这个目标所引发的所有的规则中</strong>去。如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">prog : CFLAGS = -g<br>prog : prog.o foo.o bar.o<br>    <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> prog.o foo.o bar.o<br>prog.o : prog.c<br>    <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> prog.c<br>foo.o : foo.c<br>    <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> foo.c<br>bar.o : bar.c<br>    <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> bar.c<br></code></pre></td></tr></table></figure>
<p>在这个示例中，不管全局的<span
class="math inline">\((CFLAGS)的值是什么，在prog目标，以及其所引发的所有规则中（prog.o
foo.o bar.o的规则），\)</span>(CFLAGS)的值都是“-g”</p>
<h3 id="模式变量"><strong>模式变量</strong></h3>
<p>模式变量（Pattern-specific
Variable）。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。</p>
<p>我们知道，make的“模式”一般是至少含有一个“%”的，所以，我们可以以如下方式给所有以[.o]结尾的目标定义目标变量：</p>
<p>%.o : CFLAGS = -O</p>
<p>同样，模式变量的语法和“目标变量”一样：</p>
<p>&lt;pattern ...&gt; : <variable-assignment></p>
<p>&lt;pattern ...&gt; : override <variable-assignment></p>
<p>override同样是针对于系统环境传入的变量，或是make命令行指定的变量。</p>
<h2 id="七.使用条件判断">七.使用条件判断</h2>
<p>使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。</p>
<h3 id="示例"><strong>示例</strong></h3>
<p>下面的例子，判断$(CC)变量是否“gcc”，如果是的话，则使用GNU函数编译目标。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">libs_for_gcc = -lgnu<br>normal_libs =<br><br><span class="hljs-section">foo: <span class="hljs-variable">$(objects)</span></span><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(CC)</span>,gcc)<br>    <span class="hljs-variable">$(CC)</span> -o foo <span class="hljs-variable">$(objects)</span> <span class="hljs-variable">$(libs_for_gcc)</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-variable">$(CC)</span> -o foo <span class="hljs-variable">$(objects)</span> <span class="hljs-variable">$(normal_libs)</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure>
<h3 id="语法"><strong>语法</strong></h3>
<p>条件表达式的语法为：</p>
<p><conditional-directive> <text-if-true> endif</p>
<p>以及：</p>
<p><conditional-directive> <text-if-true> else <text-if-false> endif</p>
<p>其中<conditional-directive>表示条件关键字，如“ifeq”。这个关键字有四个。</p>
<p>第一个是我们前面所见过的“ifeq”</p>
<p>ifeq (<arg1>, <arg2>) ifeq '<arg1>' '<arg2>' ifeq "<arg1>" "<arg2>"
ifeq "<arg1>" '<arg2>' ifeq '<arg1>' "<arg2>"</p>
<p>比较参数“arg1”和“arg2”的值是否相同。当然，参数中我们还可以使用make的函数。如：</p>
<p>ifeq ($(strip $(foo)),) <text-if-empty> endif</p>
<p>这个示例中使用了“strip”函数，如果这个函数的<strong>返回值是空（Empty）</strong>，那么<text-if-empty>就生效。</p>
<p>第二个条件关键字是“ifneq”。语法是：</p>
<p>ifneq (<arg1>, <arg2>) ifneq '<arg1>' '<arg2>' ifneq "<arg1>"
"<arg2>" ifneq "<arg1>" '<arg2>' ifneq '<arg1>' "<arg2>"</p>
<p>其比较参数“arg1”和“arg2”的值是否相同，如果不同，则为真。和“ifeq”类似。</p>
<p>第三个条件关键字是“ifdef”。语法是：</p>
<p>ifdef <variable-name></p>
<h1 id="看到这里了">看到这里了</h1>
<p>如果变量<variable-name>的值<strong>非空</strong>，那到表达式为真。否则，表达式为假。当然，<variable-name>同样可以是一个函数的返回值。注意，ifdef只是测试一个变量是否有值，其并不会把变量扩展到当前位置。</p>
<p>示例一： bar = foo = $(bar) ifdef foo frobozz = yes else frobozz = no
endif</p>
<p>示例二： foo = ifdef foo frobozz = yes else frobozz = no endif</p>
<p>第一个例子中，<code>$(frobozz)</code>值是<code>yes</code>，第二个则是<code>no</code>。</p>
<p>第四个条件关键字是“ifndef”。其语法是：</p>
<p>ifndef <variable-name></p>
<p>特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如<code>$@</code>等）放入条件表达式中，因为自动化变量是在运行时才有的。而且，为了避免混乱，make不允许把整个条件语句分成两部分放在不同的文件中。</p>
<h2 id="八.使用函数">八.使用函数</h2>
<p>在Makefile中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使用。</p>
<h3 id="函数的调用语法"><strong>函数的调用语法</strong></h3>
<p>函数调用，很像变量的使用，也是以“$”来标识的，其语法如下：</p>
<p>$(<function> <arguments>)</p>
<p>或是</p>
<p>${<function> <arguments>}</p>
<p>这里，<function>就是函数名，make支持的函数不多。<arguments>是函数的参数，参数间以逗号“,”分隔，而<strong>函数名和参数之间以“空格”分隔</strong>。函数调用以“$”开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？函数中的参数可以使用变量</p>
<p>comma:= , empty:= space:= $(empty) $(empty) foo:= a b c bar:= $(subst
<span class="math inline">\((space),\)</span>(comma),$(foo))</p>
<p>在这个示例中，<span
class="math inline">\((comma)的值是一个逗号。\)</span>(space)使用了<span
class="math inline">\((empty)定义了一个空格，\)</span>(foo)的值是“a b
c”，<span
class="math inline">\((bar)的定义用，调用了函数“subst”，这是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是把\)</span>(foo)中的空格替换成逗号，所以$(bar)的值是“a,b,c”。</p>
<h3 id="字符串处理函数"><strong>字符串处理函数</strong></h3>
<p><strong>$(subst <from>,<to>,<text>)</strong></p>
<p>名称：字符串替换函数——subst。
功能：把字串<text>中的<from>字符串替换成<to>。
返回：函数返回被替换过后的字符串。</p>
<p>示例： $(subst ee,EE,feet on the street)，</p>
<pre><code>把“feet on the street”中的“ee”替换成“EE”，返回结果是“fEEt on the strEEt”。</code></pre>
<p><strong>$(patsubst <pattern>,<replacement>,<text>)</strong></p>
<p>名称：模式字符串替换函数——patsubst。
功能：查找<text>中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式<pattern>，如果匹配的话，则以<replacement>替换。这里，<pattern>可以包括通配符“%”，表示任意长度的字串。如果<replacement>中也包含“%”，那么，<replacement>中的这个“%”将是<pattern>中的那个“%”所代表的字串。（可以用“/”来转义，以“/%”来表示真实含义的“%”字符）
返回：函数返回被替换过后的字符串。</p>
<p>示例：</p>
<p>​ $(patsubst %.c,%.o,x.c.c bar.c)</p>
<p>​ 把字串“x.c.c bar.c”符合模式[%.c]的单词替换成[%.o]，返回结果是“x.c.o
bar.o”</p>
<p>备注：</p>
<p>​ 这和我们前面“变量章节”说过的相关知识有点相似。如：</p>
<p>​ “<span
class="math inline">\((var:&lt;pattern&gt;=&lt;replacement&gt;)” ​ 相当于
​“\)</span>(patsubst <pattern>,<replacement>,$(var))”，</p>
<p>​ 而“<span class="math inline">\((var:
&lt;suffix&gt;=&lt;replacement&gt;)” ​ 则相当于 ​ “\)</span>(patsubst
%<suffix>,%<replacement>,$(var))”。</p>
<p>​ 例如有：objects = foo.o bar.o baz.o， ​ 那么，“<span
class="math inline">\((objects:.o=.c)”和“\)</span>(patsubst
%.o,%.c,$(objects))”是一样的。</p>
<p><strong>$(strip <string>)</strong></p>
<p>名称：去空格函数——strip。
功能：去掉<string>字串中开头和结尾的空字符。
返回：返回被去掉空格的字符串值。 示例：</p>
<pre><code>$(strip a b c )</code></pre>
<p>​ 把字串“a b c ”去到开头和结尾的空格，结果是“a b c”。</p>
<p><strong>$(findstring <find>,<in>)</strong></p>
<p>名称：查找字符串函数——findstring。 功能：在字串<in>中查找<find>字串。
返回：如果找到，那么返回<find>，否则返回空字符串。 示例：</p>
<p>​ $(findstring a,a b c) ​ $(findstring a,b c)</p>
<p>​ 第一个函数返回“a”字符串，第二个返回“”字符串（空字符串）</p>
<p><strong>$(filter &lt;pattern...&gt;,<text>)</strong></p>
<p>名称：过滤函数——filter。
功能：以<pattern>模式过滤<text>字符串中的单词，保留符合模式<pattern>的单词。可以有多个模式。
返回：返回符合模式<pattern>的字串。 示例：</p>
<p>​ sources := foo.c bar.c baz.s ugh.h ​ foo: $(sources) ​ cc <span
class="math inline">\((filter %.c %.s,\)</span>(sources)) -o foo</p>
<p>​ <span class="math inline">\((filter %.c
%.s,\)</span>(sources))返回的值是“foo.c bar.c baz.s”。</p>
<p><strong>$(filter-out &lt;pattern...&gt;,<text>)</strong></p>
<p>名称：反过滤函数——filter-out。
功能：以<pattern>模式过滤<text>字符串中的单词，去除符合模式<pattern>的单词。可以有多个模式。
返回：返回不符合模式<pattern>的字串。 示例：</p>
<p>​ objects=main1.o foo.o main2.o bar.o ​ mains=main1.o main2.o ​<br />
​$(filter-out <span class="math inline">\((mains),\)</span>(objects))
返回值是“foo.o bar.o”。 ​<br />
<strong>$(sort <list>)</strong></p>
<p>名称：排序函数——sort。 功能：给字符串<list>中的单词排序（升序）。
返回：返回排序后的字符串。 示例：$(sort foo bar lose)返回“bar foo lose”
。 备注：sort函数会去掉<list>中相同的单词。</p>
<p><strong>$(word <n>,<text>)</strong></p>
<p>名称：取单词函数——word。
功能：取字符串<text>中第<n>个单词。（从一开始）
返回：返回字符串<text>中第<n>个单词。如果<n>比<text>中的单词数要大，那么返回空字符串。
示例：$(word 2, foo bar baz)返回值是“bar”。</p>
<p><strong>$(wordlist <s>,<e>,<text>)</strong></p>
<p>名称：取单词串函数——wordlist。
功能：从字符串<text>中取从<s>开始到<e>的单词串。<s>和<e>是一个数字。
返回：返回字符串<text>中从<s>到<e>的单词字串。如果<s>比<text>中的单词数要大，那么返回空字符串。如果<e>大于<text>的单词数，那么返回从<s>开始，到<text>结束的单词串。
示例： $(wordlist 2, 3, foo bar baz)返回值是“bar baz”。</p>
<p><strong>$(words <text>)</strong></p>
<p>名称：单词个数统计函数——words。
功能：统计<text>中字符串中的单词个数。 返回：返回<text>中的单词数。
示例：<span class="math inline">\((words, foo bar
baz)返回值是“3”。  备注：如果我们要取&lt;text&gt;中最后的一个单词，我们可以这样：\)</span>(word
$(words <text>),<text>)。</p>
<p><strong>$(firstword <text>)</strong></p>
<p>名称：首单词函数——firstword。 功能：取字符串<text>中的第一个单词。
返回：返回字符串<text>的第一个单词。 示例：<span
class="math inline">\((firstword foo
bar)返回值是“foo”。  备注：这个函数可以用word函数来实现：\)</span>(word
1,<text>)。</p>
<p>以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，举一个现实中应用的例子。我们知道，make使用“VPATH”变量来指定“依赖文件”的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数CFLAGS，如：</p>
<p>override CFLAGS += <span class="math inline">\((patsubst
%,-I%,\)</span>(subst :, ,$(VPATH)))</p>
<p>如果我们的“<span
class="math inline">\((VPATH)”值是“src:../headers”，那么“\)</span>(patsubst
%,-I%,<span class="math inline">\((subst :,
,\)</span>(VPATH)))”将返回“-Isrc
-I../headers”，这正是cc或gcc搜索头文件路径的参数。</p>
<h3 id="文件名操作函数"><strong>文件名操作函数</strong></h3>
<p>下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是一系列的文件名来对待。</p>
<p><strong>$(dir &lt;names...&gt;)</strong></p>
<p>名称：取目录函数——dir。
功能：从文件名序列<names>中取出目录部分。目录部分是指最后一个反斜杠（“/”）之前的部分。如果没有反斜杠，那么返回“./”。
返回：返回文件名序列<names>的目录部分。 示例： $(dir src/foo.c
hacks)返回值是“src/ ./”。</p>
<p><strong>$(notdir &lt;names...&gt;)</strong></p>
<p>名称：取文件函数——notdir。
功能：从文件名序列<names>中取出非目录部分。非目录部分是指最后一个反斜杠（“/”）之后的部分。
返回：返回文件名序列<names>的非目录部分。 示例： $(notdir src/foo.c
hacks)返回值是“foo.c hacks”。</p>
<p><strong>$(suffix &lt;names...&gt;)</strong></p>
<p>名称：取后缀函数——suffix。
功能：从文件名序列<names>中取出各个文件名的后缀。
返回：返回文件名序列<names>的后缀序列，如果文件没有后缀，则返回空字串。
示例：$(suffix src/foo.c src-1.0/bar.c hacks)返回值是“.c .c”。</p>
<p><strong>$(basename &lt;names...&gt;)</strong></p>
<p>名称：取前缀函数——basename。
功能：从文件名序列<names>中取出各个文件名的前缀部分。
返回：返回文件名序列<names>的前缀序列，如果文件没有前缀，则返回空字串。
示例：$(basename src/foo.c src-1.0/bar.c hacks)返回值是“src/foo
src-1.0/bar hacks”。</p>
<p><strong>$(addsuffix <suffix>,&lt;names...&gt;)</strong></p>
<p>名称：加后缀函数——addsuffix。
功能：把后缀<suffix>加到<names>中的每个单词后面。
返回：返回加过后缀的文件名序列。 示例：$(addsuffix .c,foo
bar)返回值是“foo.c bar.c”。</p>
<p><strong>$(addprefix <prefix>,&lt;names...&gt;)</strong></p>
<p>名称：加前缀函数——addprefix。
功能：把前缀<prefix>加到<names>中的每个单词后面。
返回：返回加过前缀的文件名序列。 示例：$(addprefix src/,foo
bar)返回值是“src/foo src/bar”。</p>
<p><strong>$(join <list1>,<list2>)</strong></p>
<p>名称：连接函数——join。
功能：把<list2>中的单词对应地加到<list1>的单词后面。如果<list1>的单词个数要比<list2>的多，那么，<list1>中的多出来的单词将保持原样。如果<list2>的单词个数要比<list1>多，那么，<list2>多出来的单词将被复制到<list2>中。
返回：返回连接过后的字符串。 示例：$(join aaa bbb , 111 222
333)返回值是“aaa111 bbb222 333”。</p>
<h3 id="foreach-函数">foreach 函数</h3>
<p>foreach函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的foreach函数几乎是仿照于Unix标准Shell（/bin/sh）中的for语句，或是C-Shell（/bin/csh）中的foreach语句而构建的。它的语法是：</p>
<p>​</p>
<p>$(foreach <var>,<list>,<text>)</p>
<p>​</p>
<p>这个函数的意思是，把参数<list>中的单词逐一取出放到参数<var>所指定的变量中，然后再执行<text>所包含的表达式。每一次<text>会返回一个字符串，循环过程中，<text>的所返回的每个字符串会以空格分隔，最后当整个循环结束时，<text>所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。</p>
<p>​</p>
<p>所以，<var>最好是一个变量名，<list>可以是一个表达式，而<text>中一般会使用<var>这个参数来依次枚举<list>中的单词。举个例子：</p>
<p>​</p>
<p>names := a b c d</p>
<p>files := <span class="math inline">\((foreach
n,\)</span>(names),$(n).o)</p>
<p>​</p>
<p>上面的例子中，<span
class="math inline">\((name)中的单词会被挨个取出，并存到变量“n”中，“\)</span>(n).o”每次根据“<span
class="math inline">\((n)”计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以，\)</span>(files)的值是“a.o
b.o c.o d.o”。</p>
<p>​</p>
<p>注意，foreach中的<var>参数是一个临时的局部变量，foreach函数执行完后，参数<var>的变量将不在作用，其作用域只在foreach函数当中。</p>
<p>​</p>
<p>​</p>
<h3 id="if-函数">if 函数</h3>
<p>if函数很像GNU的make所支持的条件语句——ifeq（参见前面所述的章节），if函数的语法是：</p>
<p>$(if <condition>,<then-part>)</p>
<p>$(if <condition>,<then-part>,<else-part>)</p>
<p>可见，if函数可以包含“else”部分，或是不含。即if函数的参数可以是两个，也可以是三个。<condition>参数是if的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，<then-part>会被计算，否则<else-part>会被计算。</p>
<p>而if函数的返回值是，如果<condition>为真（非空字符串），那个<then-part>会是整个函数的返回值，如果<condition>为假（空字符串），那么<else-part>会是整个函数的返回值，此时如果<else-part>没有被定义，那么，整个函数返回空字串。</p>
<p>​</p>
<p>所以，<then-part>和<else-part>只会有一个被计算。</p>
<p>​</p>
<h3 id="call函数">call函数</h3>
<p>​</p>
<p>call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用call函数来向这个表达式传递参数。其语法是：</p>
<p>​</p>
<p>$(call <expression>,<parm1>,<parm2>,<parm3>...)</p>
<p>​</p>
<p>当make执行这个函数时，<expression>参数中的变量，如<span
class="math inline">\((1)，\)</span>(2)，$(3)等，会被参数<parm1>，<parm2>，<parm3>依次取代。而<expression>的返回值就是call函数的返回值。例如：</p>
<p>reverse = $(1) $(2)</p>
<p>foo = $(call reverse,a,b)</p>
<p>那么，foo的值就是“a
b”。当然，参数的次序是可以自定义的，不一定是顺序的，如：</p>
<p>​</p>
<p>reverse = $(2) $(1)</p>
<p>foo = $(call reverse,a,b)</p>
<p>此时的foo的值就是“b a”。</p>
<p>​</p>
<p>​</p>
<h3 id="origin函数">origin函数</h3>
<p>origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是：</p>
<p>​</p>
<p>$(origin <variable>)</p>
<p>​</p>
<p>注意，<variable>是变量的名字，不应该是引用。所以你最好不要在<variable>中使用“$”字符。Origin函数会以其返回值来告诉你这个变量的“出生情况”，下面，是origin函数的返回值:</p>
<p>​</p>
<p>“undefined”</p>
<p>如果<variable>从来没有定义过，origin函数返回这个值“undefined”。</p>
<p>​</p>
<p>“default”</p>
<p>如果<variable>是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。</p>
<p>​</p>
<p>“environment”</p>
<p>如果<variable>是一个环境变量，并且当Makefile被执行时，“-e”参数没有被打开。</p>
<p>​</p>
<p>“file”</p>
<p>如果<variable>这个变量被定义在Makefile中。</p>
<p>​</p>
<p>“command line”</p>
<p>如果<variable>这个变量是被命令行定义的。</p>
<p>​</p>
<p>“override”</p>
<p>如果<variable>是被override指示符重新定义的。</p>
<p>​</p>
<p>“automatic”</p>
<p>如果<variable>是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。</p>
<p>​</p>
<p>这些信息对于我们编写Makefile是非常有用的，例如，假设我们有一个Makefile其包了一个定义文件Make.def，在Make.def中定义了一个变量“bletch”，而我们的环境中也有一个环境变量“bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的Makefile中，我们可以这样写：</p>
<p>​</p>
<p>ifdef bletch</p>
<p>ifeq "$(origin bletch)" "environment"</p>
<p>bletch = barf, gag, etc.</p>
<p>endif</p>
<p>endif</p>
<p>​</p>
<p>当然，你也许会说，使用override关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用override是可以达到这样的效果，可是override过于粗暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的。</p>
<p>​</p>
<p>​</p>
<h3 id="shell函数">shell函数</h3>
<p>​</p>
<p>shell函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号“`”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：</p>
<p>​</p>
<p>contents := $(shell cat foo)</p>
<p>​</p>
<p>files := $(shell echo *.c)</p>
<p>​</p>
<p>注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。</p>
<p>​</p>
<p>​</p>
<h3 id="控制make的函数">控制make的函数</h3>
<p>​</p>
<p>make提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。</p>
<p>​</p>
<p><strong>$(error &lt;text ...&gt;)</strong></p>
<p>​</p>
<p>产生一个致命的错误，&lt;text
...&gt;是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。例如：</p>
<p>​</p>
<p>示例一：</p>
<p>ifdef ERROR_001</p>
<p>$(error error is $(ERROR_001))</p>
<p>endif</p>
<p>​</p>
<p>示例二：</p>
<p>ERR = $(error found an error!)</p>
<p>.PHONY: err</p>
<p>err: ; $(ERR)</p>
<p>​</p>
<p>示例一会在变量ERROR_001定义了后执行时产生error调用，而示例二则在目录err被执行时才发生error调用。</p>
<p>​</p>
<p><strong>$(warning &lt;text ...&gt;)</strong></p>
<p>​</p>
<p>这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。</p>
<h2 id="九.make-的运行">九.make 的运行</h2>
<p>一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的makefile来执行，一切都是自动的。但也有时你也许只想让make重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。本章节就是讲述如何使用make命令的。</p>
<h3 id="make的退出码"><strong>make的退出码</strong></h3>
<p>make命令执行后有三个退出码：</p>
<p>0 —— 表示成功执行。 1 —— 如果make运行时出现任何错误，其返回1。 2 ——
如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。</p>
<p>Make的相关参数我们会在后续章节中讲述。</p>
<h3 id="指定makefile"><strong>指定Makefile</strong></h3>
<p>前面我们说过，GNU
make找寻默认的Makefile的规则是在当前目录下依次找三个文件——“GNUmakefile”、“makefile”和“Makefile”。其按顺序找这三个文件，一旦找到，就开始读取这个文件并执行。</p>
<p>当前，我们也可以给make命令指定一个特殊名字的Makefile。要达到这个功能，我们要使用make的“-f”或是“--file”参数（“--makefile”参数也行）。例如，我们有个makefile的名字是“hchen.mk”，那么，我们可以这样来让make来执行这个文件：</p>
<p>make –f hchen.mk</p>
<p>如果在make的命令行是，你不只一次地使用了“-f”参数，那么，所有指定的makefile将会被连在一起传递给make执行。</p>
<h3 id="指定目标"><strong>指定目标</strong></h3>
<p>一般来说，make的最终目标是makefile中的第一个目标，而其它目标一般是由这个目标连带出来的。这是make的默认行为。当然，一般来说，你的makefile中的第一个目标是由许多个目标组成，你可以指示make，让其完成你所指定的目标。要达到这一目的很简单，需在make命令后直接跟目标的名字就可以完成（如前面提到的“make
clean”形式）</p>
<p>任何在makefile中的目标都可以被指定成终极目标，但是除了以“-”打头，或是包含了“=”的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。甚至没有被我们明确写出来的目标也可以成为make的终极目标，也就是说，只要make可以找到其隐含规则推导规则，那么这个隐含目标同样可以被指定成终极目标。</p>
<p>有一个make的环境变量叫“MAKECMDGOALS”，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子：</p>
<p>sources = foo.c bar.c ifneq ( $(MAKECMDGOALS),clean) include
$(sources:.c=.d) endif</p>
<p>基于上面的这个例子，只要我们输入的命令不是“make
clean”，那么makefile会自动包含“foo.d”和“bar.d”这两个makefile。</p>
<p>使用指定终极目标的方法可以很方便地让我们编译我们的程序，例如下面这个例子：</p>
<p>.PHONY: all all: prog1 prog2 prog3 prog4</p>
<p>从这个例子中，我们可以看到，这个makefile中有四个需要编译的程序——“prog1”，
“prog2”， “prog3”和 “prog4”，我们可以使用“make
all”命令来编译所有的目标（如果把all置成第一个目标，那么只需执行“make”），我们也可以使用“make
prog2”来单独编译目标“prog2”。</p>
<p>即然make可以指定所有makefile中的目标，那么也包括“伪目标”，于是我们可以根据这种性质来让我们的makefile根据指定的不同的目标来完成不同的事。在Unix世界中，软件发布时，特别是GNU这种开源软件的发布时，其makefile都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的makefile中的目标。</p>
<p>“all” 这个伪目标是所有目标的目标，其功能一般是编译所有的目标。
“clean” 这个伪目标功能是删除所有被make创建的文件。 “install”
这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。
“print” 这个伪目标的功能是例出改变过的源文件。 “tar”
这个伪目标功能是把源程序打包备份。也就是一个tar文件。 “dist”
这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。
“TAGS” 这个伪目标功能是更新所有的目标，以备完整地重编译使用。
“check”和“test” 这两个伪目标一般用来测试makefile的流程。</p>
<p>当然一个项目的makefile中也不一定要书写这样的目标，这些东西都是GNU的东西，但是我想，GNU搞出这些东西一定有其可取之处（等你的UNIX下的程序文件一多时你就会发现这些功能很有用了），这里只不过是说明了，如果你要书写这种功能，最好使用这种名字命名你的目标，这样规范一些，规范的好处就是——不用解释，大家都明白。而且如果你的makefile中有这些功能，一是很实用，二是可以显得你的makefile很专业（不是那种初学者的作品）。</p>
<h3 id="检查规则"><strong>检查规则</strong></h3>
<p>有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用make命令的下述参数：</p>
<p>“-n” “--just-print” “--dry-run” “--recon”
不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试makefile很有用处。</p>
<p>“-t” “--touch”
这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。</p>
<p>“-q” “--question”
这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。</p>
<p>“-W <file>” “--what-if=<file>” “--assume-new=<file>”
“--new-file=<file>”
这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令。</p>
<p>另外一个很有意思的用法是结合“-p”和“-v”来输出makefile被执行时的信息（这个将在后面讲述）。</p>
<h3 id="make的参数"><strong>make的参数</strong></h3>
<p>下面列举了所有GNU make
3.80版的参数定义。其它版本和产商的make大同小异，不过其它产商的make的具体参数还是请参考各自的产品文档。</p>
<p>“-b” “-m” 这两个参数的作用是忽略和其它版本make的兼容性。</p>
<p>“-B” “--always-make” 认为所有的目标都需要更新（重编译）。</p>
“-C
<dir>
” “--directory=
<dir>
<p>”
指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make
–C ~hchen/test –C prog”等价于“make –C ~hchen/test/prog”。</p>
<p>“—debug[=<options>]”
输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是<options>的取值：
a —— 也就是all，输出所有的调试信息。（会非常的多） b ——
也就是basic，只输出简单的调试信息。即输出不需要重编译的目标。 v ——
也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等。
i —— 也就是implicit，输出所以的隐含规则。 j ——
也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等。 m ——
也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息。</p>
<p>“-d” 相当于“--debug=a”。</p>
<p>“-e” “--environment-overrides”
指明环境变量的值覆盖makefile中定义的变量的值。</p>
<p>“-f=<file>” “--file=<file>” “--makefile=<file>”
指定需要执行的makefile。</p>
<p>“-h” “--help” 显示帮助信息。</p>
<p>“-i” “--ignore-errors” 在执行时忽略所有的错误。</p>
“-I
<dir>
” “--include-dir=
<dir>
<p>”
指定一个被包含makefile的搜索目标。可以使用多个“-I”参数来指定多个目录。</p>
<p>“-j [<jobsnum>]” “--jobs[=<jobsnum>]”
指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的“-j”参数，那么仅最后一个“-j”才是有效的。（注意这个参数在MS-DOS中是无用的）</p>
<p>“-k” “--keep-going”
出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。</p>
<p>“-l <load>” “--load-average[=&lt;load]” “—max-load[=<load>]”
指定make运行命令的负载。</p>
<p>“-n” “--just-print” “--dry-run” “--recon”
仅输出执行过程中的命令序列，但并不执行。</p>
<p>“-o <file>” “--old-file=<file>” “--assume-old=<file>”
不重新生成的指定的<file>，即使这个目标的依赖文件新于它。</p>
<p>“-p” “--print-data-base”
输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。如果你只是想输出信息而不想执行makefile，你可以使用“make
-qp”命令。如果你想查看执行makefile前的预设变量和规则，你可以使用“make –p
–f
/dev/null”。这个参数输出的信息会包含着你的makefile文件的文件名和行号，所以，用这个参数来调试你的makefile会是很有用的，特别是当你的环境变量很复杂的时候。</p>
<p>“-q” “--question”
不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说明有错误发生。</p>
<p>“-r” “--no-builtin-rules” 禁止make使用任何隐含规则。</p>
<p>“-R” “--no-builtin-variabes”
禁止make使用任何作用于变量上的隐含规则。</p>
<p>“-s” “--silent” “--quiet” 在命令运行时不输出命令的输出。</p>
<p>“-S” “--no-keep-going” “--stop”
取消“-k”选项的作用。因为有些时候，make的选项是从环境变量“MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效。</p>
<p>“-t” “--touch”
相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。</p>
<p>“-v” “--version” 输出make程序的版本、版权等关于make的信息。</p>
<p>“-w” “--print-directory”
输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。</p>
<p>“--no-print-directory” 禁止“-w”选项。</p>
<p>“-W <file>” “--what-if=<file>” “--new-file=<file>”
“--assume-file=<file>”
假定目标<file>需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得<file>的修改时间为当前时间。</p>
<p>“--warn-undefined-variables”
只要make发现有未定义的变量，那么就输出警告信息。</p>
<h2 id="十.隐含规则">十.隐含规则</h2>
<p>在我们使用Makefile时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译C/C++的源程序为中间目标文件（Unix下是[.o]文件，Windows下是[.obj]文件）。本章讲述的就是一些在Makefile中的“隐含的”，早先约定了的，不需要我们再写出来的规则。</p>
<p>“隐含规则”也就是一种惯例，make会按照这种“惯例”心照不喧地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把[.c]文件编译成[.o]文件这一规则，你根本就不用写出来，make会自动推导出这种规则，并生成我们需要的[.o]文件。</p>
<p>“隐含规则”会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量“CFLAGS”可以控制编译时的编译器参数。</p>
<p>我们还可以通过“模式规则”的方式写下自己的隐含规则。用“后缀规则”来定义隐含规则会有许多的限制。使用“模式规则”会更回得智能和清楚，但“后缀规则”可以用来保证我们Makefile的兼容性。
我们了解了“隐含规则”，可以让其为我们更好的服务，也会让我们知道一些“约定俗成”了的东西，而不至于使得我们在运行Makefile时出现一些我们觉得莫名其妙的东西。当然，任何事物都是矛盾的，水能载舟，亦可覆舟，所以，有时候“隐含规则”也会给我们造成不小的麻烦。只有了解了它，我们才能更好地使用它。</p>
<h3 id="使用隐含规则">使用隐含规则</h3>
<p>如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是make事先约定好的一些东西。例如，我们有下面的一个Makefile：</p>
<p>foo : foo.o bar.o cc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)</p>
<p>我们可以注意到，这个Makefile中并没有写下如何生成foo.o和bar.o这两目标的规则和命令。因为make的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。</p>
<p>make会在自己的“隐含规则”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make调用的隐含规则是，把[.o]的目标的依赖文件置成[.c]，并使用C的编译命令“cc
–c $(CFLAGS)
[.c]”来生成[.o]的目标。也就是说，我们完全没有必要写下下面的两条规则：</p>
<p>foo.o : foo.c cc –c foo.c $(CFLAGS) bar.o : bar.c cc –c bar.c
$(CFLAGS)</p>
<p>因为，这已经是“约定”好了的事了，make和我们约定好了用C编译器“cc”生成[.o]文件的规则，这就是隐含规则。</p>
<p>当然，如果我们为[.o]文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。</p>
<p>还有，在make的“隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则（没有命令）：</p>
<p>foo.o : foo.p</p>
<p>依赖文件“foo.p”（Pascal程序的源文件）有可能变得没有意义。如果目录下存在了“foo.c”文件，那么我们的隐含规则一样会生效，并会通过“foo.c”调用C的编译器生成foo.o文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后，所以，make找到可以生成foo.o的C的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出“依赖规则”，而不写命令。</p>
<h3 id="隐含规则一览">隐含规则一览</h3>
<p>这里我们将讲述所有预先设置（也就是make内建）的隐含规则，如果我们不明确地写下规则，那么，make就会在这些规则中寻找所需要规则和命令。当然，我们也可以使用make的参数“-r”或“--no-builtin-rules”选项来取消所有的预设置的隐含规则。</p>
<p>当然，即使是我们指定了“-r”参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了“后缀规则”来定义的，所以，只要隐含规则中有“后缀列表”（也就一系统定义在目标.SUFFIXES的依赖目标），那么隐含规则就会生效。默认的后缀列表是：.out,
.a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym,
.def, .h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web,
.sh, .elc, .el。具体的细节，我们会在后面讲述。</p>
<p>还是先来看一看常用的隐含规则吧。</p>
<p><strong>1、编译C程序的隐含规则。</strong>
“<n>.o”的目标的依赖目标会自动推导为“<n>.c”，并且其生成命令是“$(CC) –c
$(CPPFLAGS) $(CFLAGS)”</p>
<p><strong>2、编译C++程序的隐含规则。</strong>
“<n>.o”的目标的依赖目标会自动推导为“<n>.cc”或是“<n>.C”，并且其生成命令是“$(CXX)
–c $(CPPFLAGS)
$(CFLAGS)”。（建议使用“.cc”作为C++源文件的后缀，而不是“.C”）</p>
<p><strong>3、编译Pascal程序的隐含规则。
</strong>“<n>.o”的目标的依赖目标会自动推导为“<n>.p”，并且其生成命令是“$(PC)
–c $(PFLAGS)”。</p>
<p><strong>4、编译Fortran/Ratfor程序的隐含规则。
</strong>“<n>.o”的目标的依赖目标会自动推导为“<n>.r”或“<n>.F”或“<n>.f”，并且其生成命令是:
“.f” “$(FC) –c <span class="math inline">\((FFLAGS)”  “.F”
“\)</span>(FC) –c $(FFLAGS) <span
class="math inline">\((CPPFLAGS)”  “.f” “\)</span>(FC) –c $(FFLAGS)
$(RFLAGS)”</p>
<p><strong>5、预处理Fortran/Ratfor程序的隐含规则。</strong>
“<n>.f”的目标的依赖目标会自动推导为“<n>.r”或“<n>.F”。这个规则只是转换Ratfor或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：
“.F” “$(FC) –F $(CPPFLAGS) <span class="math inline">\((FFLAGS)”  “.r”
“\)</span>(FC) –F $(FFLAGS) $(RFLAGS)”</p>
<p><strong>6、编译Modula-2程序的隐含规则。
</strong>“<n>.sym”的目标的依赖目标会自动推导为“<n>.def”，并且其生成命令是：“$(M2C)
$(M2FLAGS) <span class="math inline">\((DEFFLAGS)”。“&lt;n.o&gt;”
的目标的依赖目标会自动推导为“&lt;n&gt;.mod”，并且其生成命令是：“\)</span>(M2C)
$(M2FLAGS) $(MODFLAGS)”。</p>
<p><strong>7、汇编和汇编预处理的隐含规则。 </strong>“<n>.o”
的目标的依赖目标会自动推导为“<n>.s”，默认使用编译品“as”，并且其生成命令是：“$(AS)
<span class="math inline">\((ASFLAGS)”。“&lt;n&gt;.s”
的目标的依赖目标会自动推导为“&lt;n&gt;.S”，默认使用C预编译器“cpp”，并且其生成命令是：“\)</span>(AS)
$(ASFLAGS)”。</p>
<p><strong>8、链接Object文件的隐含规则。</strong>
“<n>”目标依赖于“<n>.o”，通过运行C的编译器来运行链接程序生成（一般是“ld”），其生成命令是：“$(CC)
$(LDFLAGS) <n>.o $(LOADLIBES)
$(LDLIBS)”。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则：</p>
<p>x : y.o z.o</p>
<p>并且“x.c”、“y.c”和“z.c”都存在时，隐含规则将执行如下命令：</p>
<p>cc -c x.c -o x.o cc -c y.c -o y.o cc -c z.c -o z.o cc x.o y.o z.o -o
x rm -f x.o rm -f y.o rm -f z.o</p>
<p>如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。</p>
<p><strong>9、Yacc C程序时的隐含规则。
</strong>“<n>.c”的依赖文件被自动推导为“n.y”（Yacc生成的文件），其生成命令是：“$(YACC)
$(YFALGS)”。（“Yacc”是一个语法分析器，关于其细节请查看相关资料）</p>
<p><strong>10、Lex C程序时的隐含规则。</strong>
“<n>.c”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX)
$(LFALGS)”。（关于“Lex”的细节请查看相关资料）</p>
<p><strong>11、Lex Ratfor程序时的隐含规则。</strong>
“<n>.r”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX)
$(LFALGS)”。</p>
<p><strong>12、从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。</strong>
“<n>.ln”
（lint生成的文件）的依赖文件被自动推导为“n.c”，其生成命令是：“$(LINT)
$(LINTFALGS) $(CPPFLAGS) -i”。对于“<n>.y”和“<n>.l”也是同样的规则。</p>
<h3 id="隐含规则使用的变量">隐含规则使用的变量</h3>
<p>在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的“-R”或“--no–builtin-variables”参数来取消你所定义的变量对隐含规则的作用。</p>
<p>例如，第一条隐含规则——编译C程序的隐含规则的命令是“$(CC) –c $(CFLAGS)
<span
class="math inline">\((CPPFLAGS)”。Make默认的编译命令是“cc”，如果你把变量“\)</span>(CC)”重定义成“gcc”，把变量“$(CFLAGS)”重定义成“-g”，那么，隐含规则中的命令全部会以“gcc
–c -g $(CPPFLAGS)”的样子来执行了。</p>
<p>我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如“CC”；一种是参数相的关，如“CFLAGS”。下面是所有隐含规则中会用到的变量：</p>
<p><strong>1、关于命令的变量。</strong></p>
<p>AR 函数库打包程序。默认命令是“ar”。 AS
汇编语言编译程序。默认命令是“as”。 CC C语言编译程序。默认命令是“cc”。
CXX C++语言编译程序。默认命令是“g++”。 CO 从
RCS文件中扩展文件程序。默认命令是“co”。 CPP
C程序的预处理器（输出是标准输出设备）。默认命令是“$(CC) –E”。 FC Fortran
和 Ratfor 的编译器和预处理程序。默认命令是“f77”。 GET
从SCCS文件中扩展文件的程序。默认命令是“get”。 LEX
Lex方法分析器程序（针对于C或Ratfor）。默认命令是“lex”。 PC
Pascal语言编译程序。默认命令是“pc”。 YACC
Yacc文法分析器（针对于C程序）。默认命令是“yacc”。 YACCR
Yacc文法分析器（针对于Ratfor程序）。默认命令是“yacc –r”。 MAKEINFO
转换Texinfo源文件（.texi）到Info文件程序。默认命令是“makeinfo”。 TEX
从TeX源文件创建TeX DVI文件的程序。默认命令是“tex”。 TEXI2DVI
从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是“texi2dvi”。 WEAVE
转换Web到TeX的程序。默认命令是“weave”。 CWEAVE 转换C Web 到
TeX的程序。默认命令是“cweave”。 TANGLE
转换Web到Pascal语言的程序。默认命令是“tangle”。 CTANGLE 转换C Web 到
C。默认命令是“ctangle”。 RM 删除文件命令。默认命令是“rm –f”。</p>
<p><strong>2、关于命令参数的变量 </strong>
下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。</p>
<p>ARFLAGS 函数库打包程序AR命令的参数。默认值是“rv”。 ASFLAGS
汇编语言编译器参数。（当明显地调用“.s”或“.S”文件时）。 CFLAGS
C语言编译器参数。 CXXFLAGS C++语言编译器参数。 COFLAGS RCS命令参数。
CPPFLAGS C预处理器参数。（ C 和 Fortran 编译器也会用到）。 FFLAGS
Fortran语言编译器参数。 GFLAGS SCCS “get”程序参数。 LDFLAGS
链接器参数。（如：“ld”） LFLAGS Lex文法分析器参数。 PFLAGS
Pascal语言编译器参数。 RFLAGS Ratfor 程序的Fortran 编译器参数。 YFLAGS
Yacc文法分析器参数。</p>
<h3 id="隐含规则链">隐含规则链</h3>
<p>有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个[.o]的文件生成，可能会是先被Yacc的[.y]文件先成[.c]，然后再被C的编译器生成。我们把这一系列的隐含规则叫做“隐含规则链”。</p>
<p>在上面的例子中，如果文件[.c]存在，那么就直接调用C的编译器的隐含规则，如果没有[.c]文件，但有一个[.y]文件，那么Yacc的隐含规则会被调用，生成[.c]文件，然后，再调用C编译的隐含规则最终由[.c]生成[.o]文件，达到目标。</p>
<p>我们把这种[.c]的文件（或是目标），叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少，其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成？怎么我的makefile发疯了？</p>
<p>在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以“rm
-f”删除。</p>
<p>通常，一个被makefile指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标“.INTERMEDIATE”来强制声明。（如：.INTERMEDIATE
： mid ）</p>
<p>你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标“.SECONDARY”来强制声明（如：.SECONDARY
:
sec）。你还可以把你的目标，以模式的方式来指定（如：%.o）成伪目标“.PRECIOUS”的依赖目标，以保存被隐含规则所生成的中间文件。</p>
<p>在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。</p>
<p>Make会优化一些特殊的隐含规则，而不生成中间文件。如，从文件“foo.c”生成目标程序“foo”，按道理，make会编译生成中间文件“foo.o”，然后链接成“foo”，但在实际情况下，这一动作可以被一条“cc”的命令完成（cc
–o foo foo.c），于是优化过的规则就不会生成中间文件。</p>
<h3 id="定义模式规则">定义模式规则</h3>
<p>你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有<code>%</code>字符。<code>%</code>的意思是表示一个或多个任意字符。在依赖目标中同样可以使用<code>%</code>，只是依赖目标中的<code>%</code>的取值，取决于其目标。</p>
<p>有一点需要注意的是，<code>%</code>的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入Makefile时，而模式规则中的<code>%</code>则发生在运行时。</p>
<p><strong>1、模式规则介绍</strong></p>
<p>模式规则中，至少在规则的目标定义中要包含<code>%</code>，否则，就是一般的规则。目标中的<code>%</code>定义表示对文件名的匹配，<code>%</code>表示长度任意的非空字符串。例如：<code>%.c</code>表示以<code>.c</code>结尾的文件名（文件名的长度至少为3），而<code>s.%.c</code>则表示以<code>s.</code>开头，<code>.c</code>结尾的文件名（文件名的长度至少为5）。</p>
<p>如果<code>%</code>定义在目标中，那么，目标中的<code>%</code>的值决定了依赖目标中的<code>%</code>的值，也就是说，目标中的模式的<code>%</code>决定了依赖目标中<code>%</code>的样子。例如有一个模式规则如下：</p>
<p>%.o : %.c ; &lt;command ......&gt;</p>
<p>其含义是，指出了怎么从所有的[.c]文件生成相应的[.o]文件的规则。如果要生成的目标是<code>a.o b.o</code>，那么<code>%c</code>就是<code>a.c b.c</code>。</p>
<p>一旦依赖目标中的<code>%</code>模式被确定，那么，make会被要求去匹配当前目录下所有的文件名，一旦找到，make就会规则下的命令，所以，在模式规则中，目标可能会是多个的，如果有模式匹配出多个目标，make就会产生所有的模式目标，此时，make关心的是依赖的文件名和生成目标的命令这两件事。</p>
<p><strong>2、模式规则示例</strong></p>
<p>下面这个例子表示了,把所有的[.c]文件都编译成[.o]文件.</p>
<p>%.o : %.c $(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@</p>
<p>其中，<code>$@</code>表示所有的目标的挨个值，<code>$&lt;</code>表示了所有依赖目标的挨个值。这些奇怪的变量我们叫<code>自动化变量</code>，后面会详细讲述。</p>
<p>下面的这个例子中有两个目标是模式的：</p>
<p>%.tab.c %.tab.h: %.y bison -d $&lt;</p>
<p>这条规则告诉make把所有的[.y]文件都以<code>bison -d  &lt;n&gt;.y</code>执行，然后生成<code>&lt;n&gt;.tab.c</code>和<code>&lt;n&gt;.tab.h</code>文件。（其中，<code>&lt;n&gt;</code>表示一个任意字符串）。如果我们的执行程序<code>foo</code>依赖于文件<code>parse.tab.o</code>和<code>scan.o</code>，并且文件<code>scan.o</code>依赖于文件<code>parse.tab.h</code>，如果<code>parse.y</code>文件被更新了，那么根据上述的规则，<code>bison -d  parse.y</code>就会被执行一次，于是，<code>parse.tab.o</code>和<code>scan.o</code>的依赖文件就齐了。（假设，<code>parse.tab.o</code>由<code>parse.tab.c</code>生成，和<code>scan.o</code>由<code>scan.c</code>生成，而<code>foo</code>由<code>parse.tab.o</code>和<code>scan.o</code>链接生成，而且foo和其[.o]文件的依赖关系也写好，那么，所有的目标都会得到满足）</p>
<p><strong>3、自动化变量</strong></p>
<p>在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。</p>
<p>自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。</p>
<p>下面是所有的自动化变量及其说明：</p>
<p>**<span
class="math inline">\(@**  表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，`\)</span>@`就是匹配于目标中模式定义的集合。</p>
<p>**<span
class="math inline">\(%**  仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是`foo.a(bar.o)`，那么，`\)</span>%<code>就是</code>bar.o<code>，</code>$@<code>就是</code>foo.a`。如果目标不是函数库文件（Unix下是[.a]，Windows下是[.lib]），那么，其值为空。</p>
<p>**<span
class="math inline">\(&lt;**  依赖目标中的第一个目标名字。如果依赖目标是以模式（即`%`）定义的，那么`\)</span>&lt;`将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</p>
<p><strong>$?</strong> 所有比目标新的依赖目标的集合。以空格分隔。</p>
<p><strong>$^</strong>
所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。</p>
<p>**<span
class="math inline">\(+**  这个变量很像`\)</span>^`，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</p>
<p>**<span
class="math inline">\(\***  这个变量表示目标模式中`%`及其之前的部分。如果目标是`dir/a.foo.b`，并且目标的模式是`a.%.b`，那么，`\)</span><em><code>的值就是</code>dir/a.foo<code>。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么</code><span
class="math inline">\(*`也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么`\)</span></em><code>就是除了后缀的那一部分。例如：如果目标是</code>foo.c<code>，因为</code>.c<code>是make所能识别的后缀名，所以，</code><span
class="math inline">\(*`的值就是`foo`。这个特性是GNU
make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用`\)</span><em><code>，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么</code>$</em>`就是空值。</p>
<p>当你希望只对更新过的依赖文件进行操作时，<code>$?</code>在显式规则中很有用，例如，假设有一个函数库文件叫<code>lib</code>，其由其它几个object文件更新。那么把object文件打包的比较有效率的Makefile规则是：</p>
<p>lib : foo.o bar.o lose.o win.o ar r lib $?</p>
<p>在上述所列出来的自动量变量中。四个变量（<span
class="math inline">\(@、\)</span>&lt;、<span
class="math inline">\(%、\)</span>*）在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上<code>D</code>或<code>F</code>字样。这是GNU
make中老版本的特性，在新版本中，我们使用函数<code>dir</code>或<code>notdir</code>就可以做到了。<code>D</code>的含义就是Directory，就是目录，<code>F</code>的含义就是File，就是文件。</p>
<p>下面是对于上面的七个变量分别加上<code>D</code>或是<code>F</code>的含义：</p>
<p>**<span
class="math inline">\((@D)**  表示`\)</span>@<code>的目录部分（不以斜杠作为结尾），如果</code><span
class="math inline">\(@`值是`dir/foo.o`，那么`\)</span>(<span
class="citation"
data-cites="D">@D</span>)<code>就是</code>dir<code>，而如果</code>$@<code>中没有包含斜杠的话，其值就是</code>.`（当前目录）。</p>
<p>**<span
class="math inline">\((@F)**  表示`\)</span>@<code>的文件部分，如果</code><span
class="math inline">\(@`值是`dir/foo.o`，那么`\)</span>(<span
class="citation"
data-cites="F">@F</span>)<code>就是</code>foo.o<code>，</code><span
class="math inline">\((@F)`相当于函数`\)</span>(notdir $@)`。</p>
<p><strong><code>$(\*D)</code> <code>$(\*F)</code></strong>
和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子，<code>$(*D)</code>返回<code>dir</code>，而<code>$(*F)</code>返回<code>foo</code></p>
<p><strong><code>$(%D)</code> <code>$(%F)</code></strong>
分别表示了函数包文件成员的目录部分和文件部分。这对于形同<code>archive(member)</code>形式的目标中的<code>member</code>中包含了不同的目录很有用。</p>
<p><strong><code>$(&lt;D)</code> <code>$(&lt;F)</code></strong>
分别表示依赖文件的目录部分和文件部分。</p>
<p><strong><code>$(^D)</code> <code>$(^F)</code></strong>
分别表示所有依赖文件的目录部分和文件部分。（无相同的）</p>
<p><strong><code>$(+D)</code> <code>$(+F)</code></strong>
分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）</p>
<p><strong><code>$(?D)</code> <code>$(?F)</code></strong>
分别表示被更新的依赖文件的目录部分和文件部分。</p>
<p>最后想提醒一下的是，对于<code>$&lt;</code>，为了避免产生不必要的麻烦，我们最好给<span
class="math inline">\(后面的那个特定字符都加上圆括号，比如，`\)</span>(&lt;)<code>就要比</code>$&lt;`要好一些。</p>
<p>还得要注意的是，这些变量只使用在规则的命令中，而且一般都是<code>显式规则</code>和<code>静态模式规则</code>（参见前面<code>书写规则</code>一章）。其在隐含规则中并没有意义。</p>
<p><strong>4、模式的匹配</strong></p>
<p>一般来说，一个目标的模式有一个有前缀或是后缀的<code>%</code>，或是没有前后缀，直接就是一个<code>%</code>。因为<code>%</code>代表一个或多个字符，所以在定义好了的模式中，我们把<code>%</code>所匹配的内容叫做<code>茎</code>，例如<code>%.c</code>所匹配的文件<code>test.c</code>中<code>test</code>就是<code>茎</code>。因为在目标和依赖目标中同时有<code>%</code>时，依赖目标的<code>茎</code>会传给目标，当做目标中的<code>茎</code>。</p>
<p>当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行<code>茎</code>的传递时，我们需要知道这个步骤。例如有一个模式<code>e%t</code>，文件<code>src/eat</code>匹配于该模式，于是<code>src/a</code>就是其<code>茎</code>，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式<code>c%r</code>，那么，目标就是<code>src/car</code>。（<code>茎</code>被传递）</p>
<p><strong>5、重载内建隐含规则</strong></p>
<p>你可以重载内建的隐含规则（或是定义一个全新的），例如你可以重新构造和内建隐含规则不同的命令，如：</p>
<p>%.o : %.c $(CC) -c $(CPPFLAGS) <span class="math inline">\((CFLAGS)
-D\)</span>(date)</p>
<p>你可以取消内建的隐含规则，只要不在后面写命令就行。如：</p>
<p>%.o : %.s</p>
<p>同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。</p>
<h3 id="老式风格的后缀规则">老式风格的后缀规则</h3>
<p>后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规则更强更清晰。为了和老版本的Makefile兼容，GNU
make同样兼容于这些东西。后缀规则有两种方式：<code>双后缀</code>和<code>单后缀</code>。</p>
<p>双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如<code>.c.o</code>相当于<code>%o : %c</code>。单后缀规则只定义一个后缀，也就是源文件的后缀。如<code>.c</code>相当于<code>% : %.c</code>。</p>
<p>后缀规则中所定义的后缀应该是make所认识的，如果一个后缀是make所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被make所认识，那就是双后缀规则。例如：<code>.c</code>和<code>.o</code>都是make所知道。因而，如果你定义了一个规则是<code>.c.o</code>那么其就是双后缀规则，意义就是<code>.c</code>是源文件的后缀，<code>.o</code>是目标文件的后缀。如下示例：</p>
<p>.c.o: $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;</p>
<p>后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如：</p>
<p>.c.o: foo.h $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;</p>
<p>这个例子，就是说，文件<code>.c.o</code>依赖于文件<code>foo.h</code>，而不是我们想要的这样：</p>
<p>%.o: %.c foo.h $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;</p>
<p>后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。</p>
<p>而要让make知道一些特定的后缀，我们可以使用伪目标<code>.SUFFIXES</code>来定义或是删除，如：</p>
<p>.SUFFIXES: .hack .win</p>
<p>把后缀.hack和.win加入后缀列表中的末尾。</p>
<p>.SUFFIXES: # 删除默认的后缀 .SUFFIXES: .c .o .h # 定义自己的后缀</p>
<p>先清楚默认后缀，后定义自己的后缀列表。</p>
<p>make的参数<code>-r</code>或<code>-no-builtin-rules</code>也会使用得默认的后缀列表为空。而变量<code>SUFFIXE</code>被用来定义默认的后缀列表，你可以用<code>.SUFFIXES</code>来改变后缀列表，但请不要改变变量<code>SUFFIXE</code>的值。</p>
<h3 id="隐含规则搜索算法">隐含规则搜索算法</h3>
<p>比如我们有一个目标叫
T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是<code>archive(member)</code>的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把<code>member</code>当作T来搜索。</p>
<p>1、把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是<code>src/foo.o</code>，那么，D就是<code>src/</code>，N就是<code>foo.o</code>）</p>
<p>2、创建所有匹配于T或是N的模式规则列表。</p>
<p>3、如果在模式规则列表中有匹配所有文件的模式，如<code>%</code>，那么从列表中移除其它的模式。</p>
<p>4、移除列表中没有命令的规则。</p>
<p>5、对于第一个在列表中的模式规则：
1）推导其<code>茎</code>S，S应该是T或是N匹配于模式中<code>%</code>非空的部分。
2）计算依赖文件。把依赖文件中的<code>%</code>都替换成<code>茎</code>S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。
3）测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫<code>理当存在</code>）
4）如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。</p>
<p>6、如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：
1）如果规则是终止规则，那就忽略它，继续下一条模式规则。
2）计算依赖文件。（同第5步） 3）测试所有的依赖文件是否存在或是理当存在。
4）对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。
5）如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。</p>
<p>7、如果没有隐含规则可以使用，查看<code>.DEFAULT</code>规则，如果有，采用，把<code>.DEFAULT</code>的命令给T使用。</p>
<p>一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。</p>
<h2 id="十一.使用make更新函数库文件">十一.使用make更新函数库文件</h2>
<p>函数库文件也就是对Object文件（程序编译的中间文件）的打包文件。在Unix下，一般是由命令<code>ar</code>来完成打包工作。</p>
<h3 id="函数库文件的成员"><strong>函数库文件的成员</strong></h3>
<p>一个函数库文件由多个文件组成。你可以以如下格式指定函数库文件及其组成：</p>
<p>archive(member)</p>
<p>这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了<code>ar</code>命令来服务的。如：</p>
<p>foolib(hack.o) : hack.o ar cr foolib hack.o</p>
<p>如果要指定多个member，那就以空格分开，如：</p>
<p>foolib(hack.o kludge.o)</p>
<p>其等价于：</p>
<p>foolib(hack.o) foolib(kludge.o)</p>
<p>你还可以使用Shell的文件通配符来定义，如：</p>
<p>foolib(*.o)</p>
<h3 id="函数库成员的隐含规则"><strong>函数库成员的隐含规则</strong></h3>
<p>当make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是<code>a(m)</code>形式的，其会把目标变成<code>(m)</code>。于是，如果我们的成员是<code>%.o</code>的模式定义，并且如果我们使用<code>make  foo.a(bar.o)</code>的形式调用Makefile时，隐含规则会去找<code>bar.o</code>的规则，如果没有定义bar.o的规则，那么内建隐含规则生效，make会去找bar.c文件来生成bar.o，如果找得到的话，make执行的命令大致如下：</p>
<p>cc -c bar.c -o bar.o ar r foo.a bar.o rm -f bar.o</p>
<p>还有一个变量要注意的是<code>$%</code>，这是专属函数库文件的自动化变量，有关其说明请参见<code>自动化变量</code>一节。</p>
<h3 id="函数库文件的后缀规则"><strong>函数库文件的后缀规则</strong></h3>
<p>你可以使用<code>后缀规则</code>和<code>隐含规则</code>来生成函数库打包文件，如：</p>
<p>.c.a: $(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $<em>.o $(AR) r $@
$</em>.o $(RM) $*.o</p>
<p>其等效于：</p>
<p>(%.o) : %.c $(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $<em>.o $(AR) r
$@ $</em>.o $(RM) $*.o</p>
<h3 id="注意事项"><strong>注意事项</strong></h3>
<p>在进行函数库打包文件生成时，请小心使用make的并行机制（<code>-j</code>参数）。如果多个ar命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。所以，在make未来的版本中，应该提供一种机制来避免并行操作发生在函数打包文件上。</p>
<p>但就目前而言，你还是应该不要尽量不要使用<code>-j</code>参数。</p>
<p>WORK_DIR = /home/lzm/ysyx-workbench/nemu</p>
<p>BUILD_DIR = $(WORK_DIR)/build</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>Skew Number System</title>
    <url>/2022/11/27/Skew%20Number%20System/</url>
    <content><![CDATA[<h1 id="偏斜二进制系统">偏斜二进制系统</h1>
<p><span class="math inline">\(N=(a_{n-1}…a_1 a_0
)_{skew}=∑_(i=0)^(n-1)▒〖(2^(i+1)-1)∗a_i 〗\)</span></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Skew Number</tag>
      </tags>
  </entry>
  <entry>
    <title>SRAM设计</title>
    <url>/2022/12/12/SRAM%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="第一章概述">第一章：概述</h1>
<p>静态随机存取存储器（Static Random-Access
Memory，SRAM）是随机存取存储器的一种。静态是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。相对之下，动态随机存取存储器（DRAM）里面所储存的数据就需要周期性地更新。然而，当电力供应停止时，SRAM储存的数据还是会丢失（被称为volatile
memory）。</p>
<p>SRAM具有较高的性能，但是SRAM的集成度较低，功耗较DRAM大
，相同容量的DRAM内存可以设计为较小的体积，但是SRAM却需要很大的体积。同样面积的硅片可以做出更大容量的DRAM，因此SRAM显得更贵。SRAM的速度和功耗主要由外围电路决定,因此设计出速度快、功耗低的译码器至关重要。</p>
<h1 id="第二章译码器设计">第二章：译码器设计</h1>
<figure>
<img src="SRAM设计.assets/640.jpeg" alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>上图为字线驱动能力的说明。译码器最后一级应该都是以2输入与门组成，因为<strong>多输入逻辑电路驱动能力同尺寸下驱动能力下降</strong>，由于最后一级译码器输出要作为驱动字线的信号源，字线负载比较大，要尽量减少插入buffer来合理驱动字线，所以2输入组成的逻辑为最优。如图可以看出译码器的地址为<strong>最小位负载最大，因为它不是关键路径，高位的地址译码速度远慢于低位的。</strong></p>
<figure>
<img src="SRAM设计.assets/640-16709157046853.jpeg" alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<h1 id="第二章存储单元设计">第二章：存储单元设计</h1>
<p>存储单元应该具有良好的可读写性及一定的驱动能力。存储单元尺寸应当越小越好，以达到较高的密度，同时让字线和位线的负载降低到最低。</p>
<h2 id="传统6管单元结构">传统6管单元结构</h2>
<p>一对交叉耦合的反相器组成，写操作采用互拉方式的6管单元。对于大规模的存储器部件，单个的位线结构可有效减小系统的面积与功耗，所以<strong>写操作采用单端输入，局部反向对偶写入方式</strong>，如下图所示</p>
<figure>
<img src="SRAM设计.assets/640-16709161472316.png" alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>如下图a所示为读操作，字线WL有效为1，此时保存在里面的值为Q＝1，M1、M4管导通，Q的值通过M6出现在位线BL上。对读操作，一般取<span
class="math inline">\(W1&gt;1.2×W5\)</span>。</p>
<p>如下图b所示为写操作，假设Q＝1，WL有效为1，要写入0值，即BL＝0，强制Q、Q非实现电平翻转。对写操作,一般取<span
class="math inline">\(W4&lt;1.8×W6\)</span>。</p>
<figure>
<img src="SRAM设计.assets/640-16709161753489.png" alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>存储体位单元用来保存存储器部件的数据或状态信息，对存储部件的读/写归根结底是对存储体位单元的读/写。存储部件的存储单元应该具有良好的可读写性及一定的驱动能力。存储体位单元版图如下图所示</p>
<figure>
<img src="SRAM设计.assets/640-167091654628112.jpeg" alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<h2
id="基于sram的改进型三态存体"><strong>基于SRAM的改进型三态存体</strong></h2>
<p>基于SRAM的改进型三态存体（加入了N23管），如下图所示。</p>
<figure>
<img src="SRAM设计.assets/640-167091668263415.png" alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>在数据写入时，读写信号为0，关断存储体，在需要写入的数据稳定后，读写信号受控变为1，存储体存值。比如，若存储体数据原端存值为0，在进行写入操作的时候，存储体被关断，这样存储的这个0也就没有任何竞争力了，这就消除了写入弱1时可能产生的竞争，而且在写入弱1时，P8、P9和N18三个管子，还起到了对这个弱1的反馈加强作用；若存储体数据原端存值为1（DaIn=1），在进行写入操作的时候，存储体被关断，虽然此时P管和N三个管子对这个1有保持作用，但是写入的是强0，可以很容易的通过增大写入管尺寸增大0的竞争力，把0写入存储体。</p>
<p><strong>GR存储单元</strong></p>
<p>下图所示为一种存储单元CMOS电路图（GR存储单元），采用单端读写技术，并由一个方向信号WR非通过一个NMOS传输管N3对存储元的读写进行三态控制。这里所谓单端读写指的是读操作和写操作都只在D端进行，单元的读/写方向由WR非进行三态控制。</p>
<figure>
<img src="SRAM设计.assets/640-167091670822518.png" alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>在对存储单元进行写操作时，
WR非为0，N3关断，反馈维持电路P2、N2失效；进行读操作时，WR非为1，N3打开，反馈管P2、N2起作用，驱动数据输出。与传统的6T、4TSRAM双端读写结构相比，这种存储单元结构采用的这种单端读写技术显着减少了位线数目，而且对应的读写端口逻辑也大大减少，有利于大规模寄存器文件设计面积的优化及功耗的降低。而且通过对读写进行三态控制，在对存储单元进行写操作时就不必克服反馈保持电路的影响，可以比较容易的将数据写入，而且写操作驱动电路的尺寸也可因此做的相对较小，有利于提高集成度，降低电路面积和功耗；另外，存储元中的反馈管P2、N2并没有按照传统设计思想设计为弱管，而是将其设计为正常尺寸，十分有利于提高存储单元的抗干扰能力及输出驱动能力，加快数据的读出速度。电路中的晶体管尺寸的设计结合读写控制逻辑进行，以保证良好的可读写性。</p>
<h1 id="第三章读写逻辑设计">第三章：读写逻辑设计</h1>
<h2 id="读出逻辑电路"><strong>读出逻辑电路</strong></h2>
<p>在大型存储器部件中，<strong>译码逻辑的延迟对整体存储器部件的读写延迟有重要的影响</strong>。随着存储器部件规模的增大，译码逻辑产生的字线的负载越来越大，而字线本身的走线负载也很大，这在超深亚微米设计下更为明显。为有效减小译码字线的延时，最直接的方法就是<strong>减少字线的负载单元以及自身走线长度</strong>，分开字线结构（Divided
Word-Line
Structure，DWL）就采用了这一思想。在大型存储器部件设计中，将存储体阵列分为左右两半，<strong>把行译码器及其驱动放置在阵列的中间，字线产生后向左右两侧驱动</strong>，从而大大减小了走线长度，减小了字线延迟。减小走线延迟的另一个方法是采用低电阻/电容率的金属走线，即提高字线的走线层数。</p>
<p>在存储器部件的读数据通路设计时通常采用<strong>低摆幅差分信号技术</strong>，但由于大规模存储器部件的存储单元晶体管尺寸一般很小，走线负载也比较大，再加上各种噪声干扰，位线上的数据信号通常都比较弱，为了确保读出数据的正确性并提高读出速度，需要对读位线进行放大，设计中通常<strong>采用大增益的差分敏感放大器对读出数据进行驱动</strong>。具体设计时需要仔细设计位线的长度和负载以保证存在足够的电压差来获得可靠的敏感放大，在两个位线上建立起有效电压差的时间对阵列的读出速度有重要的影响；除总的位线负载外，设计实现时还必须提防非常规噪声源，它们也会减小敏感放大器上的电压差。位线上的最大的非常规噪声之一是与相邻位线之间的电容耦合，在设计时通常采用<strong>“螺旋”位线结构</strong>，在位线的传输方向上阶段性的交换两者的位置，可有效平衡相邻位线的电平变化对本单元造成的耦合影响。</p>
<h3 id="预充电路">预充电路</h3>
<p>为提高存储器部件存储单元的读出速度，在读操作之前两个位线上的电压应平衡，防止内建偏压。原则上，<strong>应使两个位线在足够高的电压上平衡以防止读干扰</strong>，因为当字线有效时，如果两个位线同时为0，会造成破坏性读出，所以<strong>通常把两位线都预充到VDD以达到平衡</strong>。</p>
<figure>
<img src="SRAM设计.assets/640-167091697426221.png" alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>如上图所示，预充可通过静态上拉和时钟电路两种方式实现。对于静态上拉预充，不必设立重负载的预充时钟信号，但预充管一直处于开启状态，所以设计时上拉管的尺寸不能太大，否则会影响正常的读出操作。而对于<strong>时钟控制预充</strong>，则可以把上拉管设计得比较大以使位线电压快速达到平衡，而且在两位线间增加一个传输管，进一步加快平衡速度，但这种方案会显著的加大时钟信号的负载和功耗，很难建立精确的预充时序关系。</p>
<h3 id="敏感放大器">敏感放大器</h3>
<p>由于阵列单元的尺寸很小，而且微处理器的时钟周期很短，在读访问时位线可能仅仅泻放了100～200mv的电压，将这一很小的电压差可靠有效的放大是存储部件设计中的一个关键技术。目前已提出了多种电路结构解决这一问题，包括电流差分放大、电流镜以及上面的电压差分放大等，所有这些方法的前提就是必须保证产生一个精确的电压偏差，以确保最终敏感放大电路的正确操作。在大型微处理器设计中，密集的电源及地栅格间的电平转换噪音使得产生并保证一个精确的参考电压非常困难。</p>
<figure>
<img src="SRAM设计.assets/640-167091716062524.png" alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>如上图图所示是结合了时钟预充的位线差分放大电路。在大型存储器部件设计中，结合多体结构，读出位线也要进行层次化设计，采用级联分开位线策略实现，每一级都有各自的敏感放大电路。</p>
<p>存储器部件的读出逻辑对于整个存储器部件的性能起着重要的作用，它是外部读出端口与内部存储单元之间的桥梁，这一部分电路的设计性能将直接关系到系统的性能。</p>
<p>大规模存储器部件的存储单元晶体管尺寸一般很小，走线负载也比较大，再加上各种噪声干扰，位线上的数据信号通常都比较弱，为了确保读出数据的正确性并提高读出速度，需要对读位线进行放大，设计中通常采用大增益的差分敏感放大器对读出数据进行驱动，如下图所示。</p>
<figure>
<img src="SRAM设计.assets/640-167091720695327.png" alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>使用灵敏放大电路实现读出的过程有2步，首先是预充，然后是求值。</p>
<figure>
<img src="SRAM设计.assets/640-167091724717830.png" alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>如上图所示中(a)和(b)分别表示预充电路和灵敏放大电路，预充可通过静态上拉和时钟电路控制两种方式实现。</p>
<p>但是要使差分敏感放大器工作良好需要仔细设计位线的长度和负载以保证存在足够的电压差来获得可靠的敏感放大，在两个位线上建立起有效电压差的时间对阵列的读出速度有重要的影响；除了总的位线负载外，设计实现时还必须提防非常规噪声源，它们也会减小敏感放大器上的电压差。</p>
<p>​
寄存器文件设计中可以使用另一种方式来实现读出结构，该结构没有常规的差分敏感放大器。如果不使用传统的灵敏放大技术实现又要提高读出电路的性能，首先想到的就是使用动态电路来实现读出电路。由于在数据读取过程中，存储阵列只有一个单元的数据是可以输出的，其他单元的输出端口是关闭的，这也是灵敏放大技术中通过该单元使能位线，通过电压差灵敏放大求值。如果不使用灵敏放大技术，那就只能通过逻辑表达式的方法求出这个输出的值来。</p>
<p>该结构在存储单元数据输出时需要进行与后级相关的预处理，该预处理电路是设计读出逻辑的必需部分，通过该电路完成一些必要的信号控制和转换功能。基于求值逻辑的读出电路，必须具有一定的逻辑特性才能进行求值读出。</p>
<h2 id="写入逻辑电路"><strong>写入逻辑电路</strong></h2>
<p>写通路电路的功能是将写位线数据写入阵列存储单元，更新存储单元的数据。</p>
<p>最简单的写放大电路可以是一个<strong>反相器</strong>，要能够在指定时钟内将选定位线拉低至VSS，更新存储单元，完成写操作。写入逻辑设计的复杂性在于：写操作完成后，被拉低到VSS的位线必须能够在下次读之前恢复到VDD，这一操作的复杂性因所采用的预充方案的不同而有所区别：如果采用时钟信号预充，这一点可以自动完成；而如果采用静态预充，设计者必须根据阵列存储元的下拉管和传输管的尺寸来选择预充管的尺寸才能确保读操作的正确性。静态预充电路可能无法在下次读操作前将位线全摆幅恢复到VDD，这种情况下就可能需要写放大电路将选定位线恢复到VDD。</p>
<p><a
href="https://blog.csdn.net/Cherish1ove/article/details/117718180">(6条消息)
版图基本知识_江南小作坊的博客-CSDN博客_版图基础知识</a></p>
]]></content>
      <categories>
        <category>IC</category>
      </categories>
      <tags>
        <tag>SRAM</tag>
        <tag>存储器</tag>
      </tags>
  </entry>
  <entry>
    <title>SynopsysEDA</title>
    <url>/2022/11/10/SynopsysEDA/</url>
    <content><![CDATA[<ul>
<li><p><strong>Design Compiler</strong> for the synthesis,</p></li>
<li><p><strong>ICC Compiler</strong> for the layout</p></li>
<li><p><strong>PrimeTime</strong> for static timing analysis</p></li>
</ul>
<p>新思安装指南：<a
href="https://link.zhihu.com/?target=http%3A//www.synopsys.com/install">http://www.synopsys.com/install</a></p>
<p>新思license快速入门指南： <a
href="https://link.zhihu.com/?target=http%3A//www.synopsys.com/licensing">http://www.synopsys.com/licensing</a></p>
<span id="more"></span>
<h1 id="第一章design-compiler使用">第一章：Design Compiler使用</h1>
<h2 id="综合">1.1综合</h2>
<p>Systhesis = Translation(转换) + G ate M apping(映射) + Logic O ptim
ization(优化)</p>
<ul>
<li>Tranlation：把电路转换为ED A 内部数据</li>
<li>Mapping：将门级网表映射到晶圆厂给定的工艺库上，形成对应的门级网表</li>
<li>Optimization：
根据工作频率、面积、功耗来对电路进行优化，推断出满足要求的门级网表</li>
</ul>
<h2 id="逻辑综合流程">1.2逻辑综合流程</h2>
<p>1.读取库和设计：包括目标库、链接库、符号库等</p>
<p>2.添加时序约束和设计规则约束：包括环境约束、面积约束、时序约束等</p>
<p>3.综合RTL设计：将RTL代码转换为用标准单元表示的门级网表</p>
<p>4.分析结果</p>
<p>5.输出设计数据</p>
<h2 id="标准单元库">1.3标准单元库</h2>
<p>绝大多数的数字设计流程都是基于标准单元的半定制设计流程。标准单元库包含了反相器、缓冲器、NAND门、NOR门、与或非门、锁存器、触发器等逻辑单元综合模型的物理信息。标准单元是完成通用功能的逻辑，具有同等的高度（宽度可以不同），这样方便数字后端的自动布局布线。</p>
<p>Synopsys的工艺库是一个.lib文件，经过<strong>Library
Compiler</strong>软件编译后，产生.db文件。工艺库文件主要包括如下信息:
（1）单元（cell）（的信息）：（主要有）功能、时间（包括时序器件的约束，如建立和保持）、面积（面积的单位不在里面定义，可按照规律理解，一般询问半导体厂商）、功耗、测试等。
（2）<strong>连线负载模型</strong>（wire load
models）：电阻、电容、面积。 （3）工作环境/条件（Operating
conditions）：制程（process）（电压和温度的比例因数k，表示不同的环境之间，各参数缩放的比例）
（4）设计规则约束（Design
）:最大最小电容、最大最小转换时间、最大最小扇出。</p>
<h3 id="verilog与dc对象的对应关系">Verilog与DC对象的对应关系</h3>
<p><img src="SynopsysEDA.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21lbmcxNTA2Nzg5,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述" style="zoom:67%;" /></p>
<p>DC读入设计时候，可以通过以下命令查看这些对象：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><code class="hljs tcl">get_ports,_pins,_designs,_cells,_nets,_clocks<br>all_inputs,_outputs,_clocks,_registers<br><br><span class="hljs-keyword">set</span> pci_ports [get_ports “Y??M Z*”]<br>echo <span class="hljs-variable">$pci_ports</span><br><br>query_objects <span class="hljs-variable">$pci_ports</span><br>sizeof_collection <span class="hljs-variable">$pci_ports</span><br><br><span class="hljs-keyword">set</span> pci_ports [add_to_collection <span class="hljs-variable">$pci_ports</span> [get_ports CTRL*]]<br><span class="hljs-keyword">set</span> all_input_except_clk [remove_from _collection [all_inputs] [get_ports CLK]]<br><br>filter_collection [get_cells *] “ref_name=~AN*”<br>get_cells * -filter “don’t_touch == true”<br><br>list_attributes -application -class &lt;object_type&gt;<br></code></pre></td></tr></table></figure>
<p>Query：访问某一个对象， Sizeof:查某一个（对象）集合的大小。</p>
<p>对象具有某些属性，比如：
　　端口（port）的属性有：方向、驱动单元、负载、最大电容约束等
　　单元（cell）的属性有：层次化、不触碰 等 　　时钟的属性有：周期、抖动
等</p>
<p>写约束，就是对设计对象的属性进行约束。</p>
<h2 id="designware库">1.4DesignWare库</h2>
<p>DesignWare是Synopsys提供的知识产权（Intellectual
Property，简称IP）库。IP库分成可综合IP库（Synthesizable
IP，SIP），验证IP库（Verification IP，VIP）和生产厂家库（Foundry
Libraries）。</p>
<p>DesignWare所有的IP都是事先验证过的、可重复使用的、参数化的、可综合的，并且不受工艺的约束。使用该IP库我们可以设计得更快，设计的质量更高，增加设计的生产力和设计的可重复使用性，减少设计的风险和技术的风险。对于每个运算符号，一般地说DesignWare库中会有多个结构（算法）来完成该运算。这样就允许DC在优化过程中评估速度/面积的折衷，选择最好的实现结果。对于一个给定的功能，如果有多个DesignWare的电路可以实现它，Design
Compiler将会选择能最好满足设计约束的电路。此外使用DesignWare中的DW
Foundation库是需要许可证(license)的，DW
Foundation库提供了更好的设计质量（Quality of Result）。</p>
<p>Design
Compile<strong>自动选择和优化算术器件</strong>。对于算术运算，我们并不需要在DC中指定标准的（基本的）综合库standard.sldb。标准的综合库standard.sldb包含内置的HDL运算符号，综合时DC会自动使用这个库。如果我们要使用性能更高的额外的IP库，例如DW_
foundation.sldb，我们就必须指定这些库，如下所示：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><code class="hljs tcl"><span class="hljs-comment">#Specify for use during optimization</span><br><span class="hljs-keyword">set</span> synthetic_library dw_foundation.sldb<br><br><span class="hljs-comment">#Specify for cell resolution during link</span><br><span class="hljs-keyword">lappend</span> link_library <span class="hljs-variable">$synthetic_library</span><br></code></pre></td></tr></table></figure>
<h2
id="线负载模式wire-load-mode和拓扑模式topographical-mode">1.4线负载模式(wire
load mode)和拓扑模式(topographical mode)</h2>
<p>基本所有深亚微米项目都使用拓扑模式而不是wire load mode</p>
<h3 id="什么是wire-load-model">什么是wire load model？</h3>
<p>wire load model是十分经典基础的线负载模型，
由半导体厂商根据自身工艺特点开发的，该模型包含<strong>单位长度面积因子</strong>、<strong>电容</strong>、<strong>电阻</strong>和<strong>扇出与线长查找表</strong>。在RTL代码综合阶段进行静态时序分析时，工艺库里面提供了标准单元的延时和功耗信息，但是互联线仍没有物理信息，这时就通过线负载模型来估算物理实现后的线负载大小，这种模型简单来说就是根据扇出预估连线长度，再根据连线长度来进行线上电阻、电容和面积等参数预估。下图为工艺库中截选的两个wire
loadmodel，名字分别为w120，和w140。</p>
<figure>
<img src="SynopsysEDA.assets/kxcokn_thumb.png" alt="kxcokn_thumb" />
<figcaption aria-hidden="true">kxcokn_thumb</figcaption>
</figure>
<p>一条扇出为n的互联线，使用w120模型计算：</p>
<ul>
<li><p>互联线长度 = 扇出1对应的互联线长度+（n-1）x slope = 133.334
+（3-1）x 133.334</p></li>
<li><p>互联线电容 = 互联线长度 x 互联线单位电容值= 1.5e-4
x互联线长度</p></li>
<li><p>互联线电阻 = 互联线长度 x 互联线单位电阻值= 8.5e-4 x
互联线长度</p></li>
<li><p>互联线面积 = 互联线长度 x 互联线单位长度面积值= 0.7 x
互联线长度</p></li>
</ul>
<p>​ wire load
mode是为跨层次互联线选择线负载模型的方法。对于多层次设计，不同层次的子设计可以与父设计有不同线负载模型，这时除了需要决定某一层次采用何种wire
load model，还需要确定对跨越不同层次的net采用何种wire load model。</p>
<p>Wire load
mode共有三种：<strong>TOP</strong>、<strong>enclosed</strong>
和<strong>segmented</strong>，例如design A和design
B间的互联线，在top模式下，选用50x50 model；在enclosed模式下，选用40x40
model；在segmented模式下，分段选用model。</p>
<p>使用set_wire_load_mode 命令明确声明使用何种模式；</p>
<p>使用set_wire_load_model命令明确声明了综合过程使用的线性负载模型。如果综合人员没有声明，那么DC会到逻辑库中寻找，如果该逻辑库支持自动根据面积来选择线性负载模型，那么DC采用这种自动匹配方式
(可以通过设置变量auto_wire_load_selecon值为false来关闭模型的自动选择功能），如果逻辑库不支持该方式，那么DC根据逻辑库中的默认参数default_wire_load_model和
default_wire_load_mode来设置。</p>
<h3 id="wire-load-model的局限性">wire load model的局限性</h3>
<p>wire load
model是通过扇出来估算线上参数的方法，只要连接数目确定，那么预估的互联线上的物理参数就确定了。<strong>可能线1和线2
扇出相同，但线长其实差距很大</strong>，这样线上延时和功耗差距其实很大，但是wire
load model给出的结果却是相同的。</p>
<p>精确性要求高的时序收敛，不再采用wire load mode，采用拓扑模式；</p>
<p>精确度要求不那么严格的、辅助性的分析工具，则可采用反推wire load
model的方法。比如Synopsys公司的SpyGlass
Power，一款用来预估功耗和分析功耗的工具，就是从.v网表和.spef
(后端给出的包含物理参数的文件)中，反推wire load
model，然后再采用上文提到的第三种模式segment
mode来对跨层互联应用wireload model，以此达到校准效果，提升精确性。</p>
<h2 id="command">1.5Command</h2>
<p><strong>所有命令均可以使用man进行查询</strong></p>
<h3 id="启动-dc">启动 DC</h3>
<p>DC在启动时会自动在启动目录下创建“command.log”和“view_command.log”两个文件，用于记录用户在使用DC时所执行的命令及设置的参数。还会创建“filenames.log”，用于记录DC访问过的目录，包括库、源文件等，退出DC时会被自动删除。启动dc_shell只产生“command.log”日志文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">dc_shell   <span class="hljs-comment">#命令行</span><br>dc_shell -f syn.tcl | <span class="hljs-built_in">tee</span> -i syn.log <span class="hljs-comment">#批量模式(batch mode)</span><br>design_analyzer <span class="hljs-comment">#图形，基于dc_shell</span><br>dc_shell_t <span class="hljs-comment">#命令行</span><br>  <span class="hljs-comment"># 以tcl为基础；</span><br>  <span class="hljs-comment"># 在该脚本语言上扩展了实现DC的命令；</span><br>  <span class="hljs-comment"># 也可直接调用tcl脚本“dc_shell_t -f script”来执行。 `推荐`</span><br>design_vision <span class="hljs-comment">#图形，基于tcl</span><br><span class="hljs-built_in">source</span> dc.tcl  <span class="hljs-comment">#启动后可以运行tcl脚本</span><br></code></pre></td></tr></table></figure>
<h3
id="读取verilog设置顶层设置路径">读取verilog，设置顶层，设置路径</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">read_verilog xxx.v<br>current_design TOP <span class="hljs-comment">#设置最顶层的模块</span><br>set_app_var search_path <span class="hljs-string">&quot;<span class="hljs-variable">$search_path</span> ./rtl&quot;</span><br></code></pre></td></tr></table></figure>
<p><strong>Search Path</strong>: 当在Link
Library中无法找到某些模块时，DC会在Search
Path下的库中自动找对应的模块。比如Synopsis的DesignWare中的库就缺省包含在了Search
Path下，这也就是为什么一般不需要手动设置Synthetic
Library的原因。在Verilog源文件中，如果找不到include的文件，也会在Search
Path下寻找。<strong>DC在search_path指定的目录底下寻找设计代码和库文件。</strong></p>
<h3 id="建立库">建立库</h3>
<ul>
<li><p><strong>Target Library</strong>：
由厂商提供，后缀一般为".db"，Verilog文件映射为门级网表的时候，就在里面查找标准单元。</p></li>
<li><p><strong>Link
Library</strong>：并非所有Verilog代码都可以转化为Target
Library中的标准单元（比如PLL，编译好的RAM），这就需要告诉DC这些东西在那些库里。</p></li>
</ul>
<p><code>dw_foundation.sldb</code>是在你的设计中使用了Synopsys
DesignWare提供的IP时，方便DC找到相应的IP，否则link会报错</p>
<ul>
<li><strong>Symbol
Library</strong>：标准单元在电脑上显示的“图标”，一般后缀为“.sdb”。</li>
<li><strong>Synthetic
Library</strong>：Synopsis内部集成了很多可以复用的逻辑，比如+, -, *,
&lt;, &gt;, &lt;=,
&gt;=这些运算，并且可以根据不同的要求来选择不同的实现，比如选择Booth乘法器或者Wallace
Tree乘法器等等，一般这个库不用载入，DC会自动载入Synopsis的DesignWare。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#target library(工艺库) </span><br>set_app_var target_library xxx.db<br><span class="hljs-built_in">set</span> target_library  xxx.db<br><br><span class="hljs-comment">#link library(链接库) </span><br>set_app_var link_library xxx.db<br>set_app_var link_library <span class="hljs-string">&quot;<span class="hljs-variable">$target_library</span>&quot;</span><br><span class="hljs-built_in">set</span> link_library   [ list * xxx.db Lib/dw_foundation.sldb]<br>	<span class="hljs-comment"># “*”号表示如果设计中某个模块找不到对应的库，那么就现在DC内存中搜索</span><br><span class="hljs-built_in">set</span> symbol_library  <span class="hljs-string">&quot;xxx/xxx.sdb&quot;</span><br></code></pre></td></tr></table></figure>
<p>gtech.db和standard.db是synopsys提供的默认库，分别包含了GTECH逻辑单元和基本的DesignWare
IP模块。在使用read命令时，这些库都被自动地加载。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">elaborate design_name<br>      [-library library_name | -work library_name]<br>      [-architecture arch_name]<br>      [-parameters param_list]<br>      [-file_parameters file_list]<br>      [-update]<br>      [-ref]<br></code></pre></td></tr></table></figure>
<h3 id="时钟约束">时钟约束</h3>
<h4 id="creat_clock">creat_clock</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">create_clock -period 2 [get_ports CLK] <span class="hljs-comment">#clock period 2ns</span><br>creat_clock	-period	period_value		<span class="hljs-comment">#定义时钟周期，如-period 10</span><br>			[source_objects]			<span class="hljs-comment">#标识时钟源，如[get_ports A]</span><br>			[-name clock_name]			<span class="hljs-comment">#命名时钟，如-name CLK</span><br>			[-waveform edge_list]		<span class="hljs-comment">#指定占空比，如-waveform &#123;0 5&#125;</span><br>			[-add]						<span class="hljs-comment">#多源时钟，加此开关且各源时钟不同名</span><br>			[-comment comment_string]	<span class="hljs-comment">#注释时钟，字符串纪录时钟信号文档信息</span><br></code></pre></td></tr></table></figure>
<h4
id="creat_generated_clock时钟分频或倍频">creat_generated_clock（时钟分频或倍频）</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">creat_generated_clock	<br>  <span class="hljs-comment">#定义生成时钟的源对象，即生成时钟的引脚，如[get_pins FF1/Q]</span><br>  [source_objects]		<br><br>  <span class="hljs-comment">#定义生成时钟的源时钟的引脚，如-source [get_ports CLK]</span><br>  -<span class="hljs-built_in">source</span> clock_source_pin		<br><br>  <span class="hljs-comment">#多源时钟复用于一个源时钟的引脚CLK，需指明当前源时钟	</span><br>  <span class="hljs-comment">#如源时钟C1与C2复用得到生成时钟GC1与GC2，需分别定义GC1与GC2</span><br>  <span class="hljs-comment">#其中定义GC1加入开关-master_clock C1，定义GC2加入开关-master_clock C2</span><br>  [-master_clock master_clock_name]	<br><br>  <span class="hljs-comment">#生成时钟命名，如-name GCLK1</span><br>  [-name generated_clock_name]		<br><br>  <span class="hljs-comment">#生成时钟特性，生成时钟的上升-下降-上升沿对应的源时钟边沿序号，为奇数个整数</span><br>  <span class="hljs-comment">#如-edges &#123;1 3 5&#125;，表示二分频的时钟特性</span><br>  <span class="hljs-comment">#即生成时钟在源时钟第1个边沿处上升，第3个边沿处下降，第5个边沿处上升</span><br>  [-edges edge_list]			<br><br>  <span class="hljs-comment">#生成时钟特性，时钟分频因子，如二分频-divide_by 2	</span><br>  [-divide_by <span class="hljs-built_in">factor</span>]				<br><br>  <span class="hljs-comment">#生成时钟特性，时钟倍频因子，如二倍频-multiply_by 2	</span><br>  [-multiply_by <span class="hljs-built_in">factor</span>]			<br><br>  <span class="hljs-comment">#使用分频或倍频时，生成时钟相位取反，用于定义D触发器的反向输出端时钟</span><br>  [-invert]	<br><br>  <span class="hljs-comment">#时钟沿位移，与-edges有相同数量的浮点数</span><br>  <span class="hljs-comment">#表明-edges中每个边沿的超前或滞后情况</span><br>  <span class="hljs-comment">#如-edge_shift &#123;0 2 0&#125;，其中的单位为ns</span><br>  <span class="hljs-comment">#表示生成时钟的第1个与第2个上升沿无位移，第1个下降沿滞后2ns				</span><br>  [-edge_shift shift_list]<br><br>  <span class="hljs-comment">#配合倍频使用，确定占空比，50表示占空比50%，如-duty_cycle 50</span><br>  [duty_cycle percent]		<br><br>  <span class="hljs-comment">#使能组合电路路径，源时钟引脚到生成时钟引脚的路径是纯组合电路时使用</span><br>  <span class="hljs-comment">#可以阻隔路径中的时序电路，组合电路始终有效</span><br>  [-combinational]<br><br>  <span class="hljs-comment">#多源时钟，除第一个源时钟外，其他源时钟需加此开关，否则会被最后一个源时钟覆盖</span><br>  <span class="hljs-comment">#各源时钟-name不同名</span><br>  [-add]<br><br>  <span class="hljs-comment">#注释时钟，字符串纪录时钟信号文档信息</span><br>  [-comment comment_string]<br></code></pre></td></tr></table></figure>
<h4 id="set_clock_group异步时钟域">set_clock_group（异步时钟域）</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">creat_clock_groups	<br>  <span class="hljs-comment">#定义时钟组的名称</span><br>  [-name group_name]<br><br>  <span class="hljs-comment">#将不同的时钟分组，如将异步时钟C1与C2分入不同组为-group C1 -group C2</span><br>  [-group clock_list]<br><br>  <span class="hljs-comment">#各组之间的关系有以下三种：</span><br>  <span class="hljs-comment">#(1)逻辑独立，时钟组中各组互斥但具有耦合关系时，即各组时钟同时存在时使用</span><br>  <span class="hljs-comment">#与物理独立，异步互斥</span><br>  [-logically_exclusive]<br><br>  <span class="hljs-comment">#(2)物理独立，时钟组中各组时钟以多路复用实现，并不同时共存于电路网络中时使用</span><br>  <span class="hljs-comment">#与逻辑独立，异步互斥</span><br>  [-physically_exclusive]<br><br>  <span class="hljs-comment">#(3)异步，时钟不共享相位关系时使用</span><br>  <span class="hljs-comment">#与逻辑独立，物理独立互斥</span><br>  [-asynchronous]<br><br>  <span class="hljs-comment">#异步且希望执行串扰分析而不禁用时钟之间的时序电路路径时使用</span><br>  <span class="hljs-comment">#仅可与-asynchronous一起使用，用于信号完整性检查</span><br>  [-allow_paths]<br><br>  <span class="hljs-comment">#注释时钟组，字符串纪录时钟组信号文档信息</span><br>  [-comments comment_string]<br></code></pre></td></tr></table></figure>
<p>时钟分组建议：</p>
<ul>
<li>如果设计中共存多个时钟，却没有相位关系，则应在set_clock_group中设定-asynchronous</li>
<li>如果设计中共存多个时钟，并且电路仅选择其中一个，则应在set_clock_group中设定-logically_exclusive</li>
<li>如果设计中不能共存多个时钟，则应在set_clock_group中设定-physically_exclusive</li>
</ul>
<h4 id="set_clock_transition">set_clock_transition</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">set_clock_transition -max 0.15 [get_ports CLK] <span class="hljs-comment">#CLK跳转最大时间为0.15ns</span><br>set_clock_transition<br>	[-rise]				<span class="hljs-comment">#上升沿过渡时间</span><br>	[-fall]				<span class="hljs-comment">#下降沿过渡时间</span><br>	[-max]				<span class="hljs-comment">#最大过渡时间</span><br>	[-min]				<span class="hljs-comment">#最小过渡时间</span><br>	clock_list			<span class="hljs-comment">#应用的时钟，如[get_clocks CLK]</span><br>	transition_time		<span class="hljs-comment">#过渡时间的数值，单位为ns</span><br>set_max_transition 0.5 sync_FIFO  <br></code></pre></td></tr></table></figure>
<h4
id="set_clock_uncertaintyskewjitter">set_clock_uncertainty（skew+jitter）</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">set_clock_uncertainty -setup 0.3 [get_ports CLK] <span class="hljs-comment">#clock skew</span><br>set_clock_uncertainty<br>  <span class="hljs-comment">#两个异步时钟之间的不确定度</span><br>  [-from|-rise_from|-fall_from from_clock]<span class="hljs-comment">#交互时钟的起始边沿，如-from C1</span><br>  [-to|-rise_to|-fall_to to_clock]		<span class="hljs-comment">#交互时钟的结束边沿，如-to C2</span><br>  <span class="hljs-comment">#单个时钟内部时钟的不确定度</span><br>  [-setup]	<span class="hljs-comment">#建立时间不确定度</span><br>  [-hold]		<span class="hljs-comment">#保持时间不确定度</span><br>  [-rise]		<span class="hljs-comment">#上升沿时间不确定度</span><br>  [-fall]		<span class="hljs-comment">#下降沿时间不确定度</span><br>  [object_list]		<span class="hljs-comment">#时钟的源对象，如[get_clocks CLK]</span><br>  Uncertainty_value	<span class="hljs-comment">#不确定度的数值，单位ns</span><br></code></pre></td></tr></table></figure>
<h4
id="set_clock_latencysource-latencynetwork-latency">set_clock_latency（source
latency+network latency）</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">set_clock_latency -max 0.7 [get_ports CLK] <span class="hljs-comment">#晶振到CLK端口所需最大时间为0.7ns</span><br>set_clock_latency<br>	[-rise]		<span class="hljs-comment">#上升沿的延迟</span><br>	[-fall]		<span class="hljs-comment">#下降沿的延迟</span><br>	[-min]		<span class="hljs-comment">#最小延迟</span><br>	[-max]		<span class="hljs-comment">#最大延迟</span><br>	[-<span class="hljs-built_in">source</span>]	<span class="hljs-comment">#片外时钟源至模块时钟端口间的延迟，如-source 0.5</span><br>				<span class="hljs-comment">#若关闭此开关，则表示模块时钟端口至触发器件之间的延时</span><br>	[-late]		<span class="hljs-comment">#片内时钟源至模块时钟端口的最长路径延迟，如-source -late 1.0</span><br>	[-early]	<span class="hljs-comment">#片内时钟源至模块时钟端口的最短路径延迟，如-source -early 0.5</span><br>	[-clock clock_list]	<span class="hljs-comment">#多个时钟通过一个模块端口的延迟，如-clock &#123;C1 C2&#125;</span><br>	delay		<span class="hljs-comment">#延迟的数值，单位为ns</span><br>	object_list	<span class="hljs-comment">#对引脚设定延迟，如[get_ports A]</span><br></code></pre></td></tr></table></figure>
<h4
id="set_clock_sense时钟敏感性非单边">set_clock_sense（时钟敏感性：非单边）</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">set_clock_sense<br>  <span class="hljs-comment">#三个开关互斥</span><br>  <span class="hljs-comment">#-positive指示正单边</span><br>  <span class="hljs-comment">#-negative指示负单边</span><br>  <span class="hljs-comment">#-stop_propagation指示禁用部分时钟的传递</span><br>  [-positive|-negative|-stop_propagation]<br><br>  <span class="hljs-comment">#创建时钟脉冲，可选项为</span><br>  <span class="hljs-comment">#rise_triggered_high_pulse</span><br>  <span class="hljs-comment">#rise_triggered_low_pulse</span><br>  <span class="hljs-comment">#fall_triggered_high_pulse</span><br>  <span class="hljs-comment">#high_triggered_low_pulse</span><br>  <span class="hljs-comment">#如-pulse rise_triggered_high_pulse，表示时钟上升沿产生一个高电平的脉冲</span><br>  <span class="hljs-comment">#脉冲的宽度为|rise_latency - fall_latency|</span><br>  [-pulse pulse]		<br><br>  [-clock clock_list]	<span class="hljs-comment">#定义影响指定敏感性引脚的时钟源</span><br>  pin_list			<span class="hljs-comment">#需要指定敏感性的引脚，如[get_pins XOR/Z]</span><br></code></pre></td></tr></table></figure>
<h3 id="信号约束">信号约束</h3>
<h4 id="set_input_delay">set_input_delay</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">set_input_delay<br>  [-clock clock_name]	<span class="hljs-comment">#指定参考时钟，如-clock CLK</span><br>  [-clock_fall]		<span class="hljs-comment">#参考时钟是下降沿触发时打开</span><br>  [-level_sensitive]	<span class="hljs-comment">#启动元器件为锁存器时使用，一般不用</span><br><br>  <span class="hljs-comment">#当模块输入端口信号上升沿和下降沿的输入到达时间不同</span><br>  <span class="hljs-comment">#使用-rise与-fall分别限定，但一般路径延迟相似，不会经常使用</span><br>  [-rise]				<br>  [-fall]<br>  [-max]			<span class="hljs-comment">#限定延迟值最大值，实现建立检查</span><br>  [-min]			<span class="hljs-comment">#限定延迟值最小值，实现保持检查</span><br>  [-add_delay]	<span class="hljs-comment">#同一个端口额外的延迟约束，则需使用，否则会被覆盖</span><br>  [-network_latency_included]	<span class="hljs-comment">#额外指定时钟network延迟，不常使用</span><br>  [-source_latency_included]	<span class="hljs-comment">#额外指定时钟source延迟，不常使用</span><br>  delay_value port_pin_list	<span class="hljs-comment">#延迟的数值，单位ns；定义输入的端口</span><br>set_input_delay -max 0.6 -clock CLK [get_ports A] //A端口数据到寄存器输入时延<br></code></pre></td></tr></table></figure>
<h4 id="set_output_delay">set_output_delay</h4>
<figure>
<img src="SynopsysEDA.assets/webp.webp" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img src="SynopsysEDA.assets/webp-16681351791993.webp" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img src="SynopsysEDA.assets/webp-16681352041766.webp" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">set_output_delay -max 0.8 -clock CLK [get_ports B] <span class="hljs-comment">#寄存器输出到B端口的时延  </span><br>set_output_delay<br>  [-clock clock_name]	<span class="hljs-comment">#指定参考时钟，如-clock CLK</span><br>  [-clock_fall]		<span class="hljs-comment">#参考时钟是下降沿触发时打开</span><br>  [-level_sensitive]	<span class="hljs-comment">#启动元器件为锁存器时使用，一般不用</span><br><br>  <span class="hljs-comment">#当模块输入端口信号上升沿和下降沿的输入到达时间不同</span><br>  <span class="hljs-comment">#使用-rise与-fall分别限定，但一般路径延迟相似，不会经常使用</span><br>  [-rise]<br>  [-fall]<br><br>  [-max]			<span class="hljs-comment">#限定延迟值最大值，实现建立检查		</span><br>  [-min]			<span class="hljs-comment">#限定延迟值最小值，实现保持检查</span><br>  [-add_delay]	<span class="hljs-comment">#同一个端口额外的延迟约束，则需使用，否则会被覆盖</span><br>  [-network_latency_included]	<span class="hljs-comment">#额外指定时钟network延迟，不常使用</span><br>  [-source_latency_included]	<span class="hljs-comment">#额外指定时钟source延迟，不常使用</span><br>  delay_value port_pin_list	<span class="hljs-comment">#延迟的数值，单位ns；定义输出的端口</span><br></code></pre></td></tr></table></figure>
<h4 id="set_drive驱动电阻">set_drive（驱动电阻）</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">set_drive	<br>	[-rise][-fall]		<span class="hljs-comment">#指定驱动信号的上升或下降沿</span><br>	[-min][-max]		<span class="hljs-comment">#指定驱动电阻的最小或最大值，小电阻驱动能力大，过渡快</span><br>	resistance_value	<span class="hljs-comment">#指定驱动电阻的数值</span><br>	port_list			<span class="hljs-comment">#指定驱动目标的输入端口</span><br></code></pre></td></tr></table></figure>
<h4 id="set_driving_cell驱动单元">set_driving_cell（驱动单元）</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">set_driving_cell	<br>	[-lib_cell lib_cell_name]		<span class="hljs-comment">#指定模块的驱动单元，如-lib_cell FA</span><br>	[-rise][-fall]		<span class="hljs-comment">#指定驱动信号的上升或下降沿</span><br>	[-min][-max]		<span class="hljs-comment">#指定最强或最弱驱动单元合集</span><br>	[-library lib_name]		 <span class="hljs-comment">#指定驱动单元所在的库</span><br>	[-pin pin_name]			 <span class="hljs-comment">#指定驱动单元用于驱动的输出引脚</span><br>	[-from_pin from_pin_name]<span class="hljs-comment">#指定驱动单元输入引脚,不同输入,输出过渡时间不同</span><br>	[-multiply_by <span class="hljs-built_in">factor</span>]			<span class="hljs-comment">#过渡时间的倍乘因子，多驱动目标时驱动下降</span><br>	[-dout_scale]					<span class="hljs-comment">#电气特性扩展与降额，不使用时需使能此开关</span><br>	[-no_design_rule]				<span class="hljs-comment">#防止驱动引脚设计规则转移到目标输入端口</span><br>	[-clock clock_name]				<span class="hljs-comment">#指定驱动单元目标端口的时钟</span><br>	[-clock_fall]					<span class="hljs-comment">#表示时钟下降沿驱动</span><br>	[-input_transition_rise rise_time]	<span class="hljs-comment">#输入上升过渡时间</span><br>	[-input_transition_fall fall_time]	<span class="hljs-comment">#输入下降过渡时间</span><br>	port_list						<span class="hljs-comment">#被驱动的输入端口</span><br></code></pre></td></tr></table></figure>
<p>常用选项是指定驱动单元的名称和驱动单元的端口，其他不常用。通过<code>set_drive</code>和<code>set_driving_cell</code>可以计算出过渡时间，但也可以通过<code>set_input_transition</code>指定过渡时间。</p>
<h4
id="set_input_transition输入过渡">set_input_transition（输入过渡）</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">set_input_transition 0.12 [get_ports A] //输入端口A的电平跳变时间0.12ns<br>set_input_transition<br>	[-rise][-fall]			<span class="hljs-comment">#指定驱动信号的上升或下降沿</span><br>	[-min][-max]			<span class="hljs-comment">#指定最小或最大过渡时间</span><br>	[-clock clock_name]		<span class="hljs-comment">#指定时钟</span><br>	[-clock_fall]			<span class="hljs-comment">#表示时钟下降沿驱动</span><br>	transition port_list	<span class="hljs-comment">#指定约束的端口</span><br></code></pre></td></tr></table></figure>
<h4
id="set_port_fanout_number扇出数">set_port_fanout_number（扇出数）</h4>
<figure class="highlight tcl"><table><tr><td class="code"><pre><code class="hljs tcl">set_port_fanout_number<br>	value 			#指定扇出数<br>	port_list		#指定约束的端口<br>set_max_fanout <span class="hljs-number">4</span> sync_FIFO   #约束cell的最大扇出,扇出过大会使cell delay变慢<br></code></pre></td></tr></table></figure>
<h4 id="set_load负载">set_load（负载）</h4>
<p><code>set_load</code>指定负载的实际电容负载</p>
<p><code>set_fanout_load</code>是根据标准负载指定负载值</p>
<p>电容负载=标准负载×单个标准负载的电容负载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">set_load [<span class="hljs-built_in">expr</span>&#123;30.0/1000&#125;] [get_ports B]<br>set_load<br>	[-min][-max]			<span class="hljs-comment">#指定最小或最大负载</span><br>	[-subtract_pin_load]	<span class="hljs-comment">#标注净电容负载时，需要打开避免与后端输入负载重复</span><br>	[-pin_load]				<span class="hljs-comment">#指定引脚负载</span><br>	[-wire_load]			<span class="hljs-comment">#指定线路负载</span><br>	value 					  <span class="hljs-comment">#指定负载值</span><br>	objects					  <span class="hljs-comment">#指定约束的端口</span><br></code></pre></td></tr></table></figure>
<h3 id="其他约束">其他约束</h3>
<h4
id="set_operating_conditions指定工作条件">set_operating_conditions（指定工作条件）</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">set_operating_conditions<br>	[-library lib_name]		<span class="hljs-comment">#指定工艺库</span><br>	[-analysis_type]		<span class="hljs-comment">#应执行的分析类型，最慢，最快，基于芯片变异性的延迟</span><br>	[-max max_condition]	<span class="hljs-comment">#该工作点应考虑执行最慢的分析，如-max WCMIL</span><br>	[-min min_condition]	<span class="hljs-comment">#该工作点应考虑执行最快的分析，如-min BCIND</span><br>	[-max_library max_lib]	<span class="hljs-comment">#指定最慢的库</span><br>	[-min_library min_lib]	<span class="hljs-comment">#指定最快的库</span><br>	[-object_list objects]	<span class="hljs-comment">#设计对象，通常为整个设计，故很少使用</span><br>	[condition]				<span class="hljs-comment">#工作条件</span><br></code></pre></td></tr></table></figure>
<h4 id="set_units指定单位标识">set_units（指定单位标识）</h4>
<p>该命令仅作为表示用户意图的文档，工具会检查正在使用的库中单位，并标记库中单位与命令指定单位是否存在不匹配。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">set_units<br>	-capacitance cap_unit<br>	-resistance res_unit<br>	-time time_unit<br>	-voltage voltage_unit<br>	-current current_unit<br>	-power power_unit<br></code></pre></td></tr></table></figure>
<h4
id="current_instance指定当前设计或实例">current_instance（指定当前设计或实例）</h4>
<p>设计范围更改为current_design中的实例，但返回名称是相对于current_design的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">current_instance [instance]<br></code></pre></td></tr></table></figure>
<h4
id="set_wire_load_model指定线负载模型">set_wire_load_model（指定线负载模型）</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">set_wire_load_model<br>	-name model_name	<span class="hljs-comment">#指定库中的模型，如WIRE_LOAD_70×70</span><br>	[-library lib_name]	<span class="hljs-comment">#指定库名称</span><br>	[-min][-max]		<span class="hljs-comment">#指定模型运用的条件，一般不用</span><br>	[object_list]		<span class="hljs-comment">#一般不用，而用current_design指定范围</span><br></code></pre></td></tr></table></figure>
<h4 id="set_max_area指定面积约束">set_max_area（指定面积约束）</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">set_max_area area_value<br>set_max_area 0  <span class="hljs-comment"># 让综合后的面积越小越好</span><br></code></pre></td></tr></table></figure>
<h4 id="set_voltage指定电压约束">set_voltage（指定电压约束）</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">set_voltage<br>	[-min min_case_value]				<span class="hljs-comment">#指定最小延迟对应的最大电压</span><br>	[-object_list list_of_power_nets]	<span class="hljs-comment">#指定电压下的电源网表</span><br>	max_case_voltage					<span class="hljs-comment">#指定最大延迟对应的最小电压</span><br></code></pre></td></tr></table></figure>
<h4
id="creat_voltage_area指定电压岛">creat_voltage_area（指定电压岛）</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">creat_voltage_area<br>	-name name							<span class="hljs-comment">#电压岛名称</span><br>	[-coordinates coordinate_list]		<span class="hljs-comment">#指定保持电压岛的矩形区域</span><br>	[-guard_band_x <span class="hljs-built_in">float</span>]				<span class="hljs-comment">#沿x轴距离，电压岛间缓冲区，不放单元</span><br>	[-guard_band_y <span class="hljs-built_in">float</span>]				<span class="hljs-comment">#沿y轴距离，电压岛间缓冲区，不放单元</span><br>	cell_list							<span class="hljs-comment">#电压岛中单元列表</span><br></code></pre></td></tr></table></figure>
<h4
id="set_level_shifter_strategythreshold指定电平移位器">set_level_shifter_strategy/threshold（指定电平移位器）</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#指定何时插入电平移位器的策略</span><br>set_level_shifter_strategy [-rule rule_type]<br><span class="hljs-comment">#指定插入电平移位器的最小电压差阈值</span><br>set_level_shifter_threshold [-voltage <span class="hljs-built_in">float</span>][-percent <span class="hljs-built_in">float</span>]<br></code></pre></td></tr></table></figure>
<h4
id="set_max_dynamicleakage_power指定动态静态功耗">set_max_dynamic/leakage_power（指定动态、静态功耗）</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#指定动态功耗最大值</span><br>set_max_dynamic_power power [unit]<br><br><span class="hljs-comment">#指定泄露功耗最大值</span><br>set_max_leakage_power power [unit]<br></code></pre></td></tr></table></figure>
<h3 id="编译">编译</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">compile<br>compile_utra<br>compile -exact_map //综合优化<br></code></pre></td></tr></table></figure>
<h3 id="输出信息">输出信息</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">report_clock<br>report_timing &gt; ./timing.rpt<br>report_area &gt; ./area.rpt<br>report_constraint -all_violators &gt; ./constraint.rpt<br>report_qor<br>write_sdc xxx.sdc <span class="hljs-comment">#输出约束条件</span><br>write_sdf xxx.sdf <span class="hljs-comment">#输出时延信息</span><br>write_file -format verilog -output xxx_netlist.v <span class="hljs-comment">#输出网表文件</span><br>write -format verilog -hierarchy -output xxx_netlist.v<br>write_parasitics <span class="hljs-comment">#save parasitics in SPEF format or as a Tcl that contains set_load and set_resistance commands.</span><br></code></pre></td></tr></table></figure>
<p>​</p>
<p>SYNTAX status write_parasitics [-output file_name] [-format reduced]
[-min] [-ratio ratio_number] [-script]</p>
<p>Data Types file_name string ratio_number float</p>
<p>ARGUMENTS -output file_name Specifies the name of the output file to
which parasitics for the current design are written.</p>
<pre><code>          If you do not specify this option, the parasitics are written to
          a file named design_name.format_name, where design_name  is  the
          name of the current design.

   -format reduced
          Specifies to write the parasitics in reduced SPEF format.

   -min   Writes  parasitics  for  the  minimum  operating  condition.  By
          default, the parasitics are written for  the  maximum  operating
          conditions.

   -ratio ratio_number
          Specifies  the ratio used when writing the pie model description
          for every driver in the net.  The ratio specified by  this  com-
          mand  must  be  in the range 0.0 - 1.0.  By default, the nets in
          reduced format are generated with a ratio  equal  to  0.5.   The
          capacitor  closest  to the driver is 0.5 (the ratio value) times
          the total net capacitance in the pie model description.

   -script
          Writes out set_load and set_resistance commands  instead  of  an
          SPEF file.</code></pre>
<p>DESCRIPTION This command writes parasitics for the current design to
a disk file.</p>
<p>Multicorner-Multimode Support This command uses information from all
active scenarios.</p>
<p>在面积报告里面没有线网所消耗的面积，这是因为我们之前没有规定综合使用的线网模型，如果我们设置了wire_load那么最后的area报告里面也会有布线所花的面积。</p>
<h3 id="demo">demo</h3>
<p>link是Design Compiler ”resolve”设计中例化模块的过程。Design
Compiler通过变量“link_library”指定例化模块库的位置，和target_library一样，默认为your_library.db。建议显式地使用link命令，否则工具可能带着“unresolved
references”进行综合，产生没有意义的结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#############################读入并分析设计##################################</span><br>remove_design -all <span class="hljs-comment">#首先清理系统</span><br><br><span class="hljs-comment">#读入并分析Verilog文件，autoread会自动按照文件的依赖顺序逐个分析源文件，</span><br><span class="hljs-comment">#如果有错误analyze命令会报错，如果没有错误会生成中间文件。</span><br>analyze -format verilog  ../src/TMO_System.v -autoread &gt; ./log/analyze.rpt<br><br><span class="hljs-comment">#将analyze生成的中间文件转为technology-independent design (GTECH)</span><br><span class="hljs-comment">#要将顶层转化为最后的网表，就要将所有的模块都组合起来，这一过程即是Link</span><br><span class="hljs-comment">#elaborate命令会自动执行Link命令，如果再次执行Link命令，我看可以看到关于Link的报告</span><br>elaborate TMO_System<br><span class="hljs-built_in">link</span> &gt; ./log/link.rpt<br>current_design TMO_System <span class="hljs-comment">#确认在DC内存中，正在处理的是顶层TMO_System</span><br><br><span class="hljs-comment"># 如果设计中多次使用了同一个instance，那么在DC的内存中多个instance均指向一个模块</span><br><span class="hljs-comment"># 但是在电路中他们应该是多个独立的实体，uniquify命令的目的就是为这些instance都创造一个</span><br><span class="hljs-comment"># 新的模块使其指向它，这样，即使在Verilog源文件中，多个instance源自同一个module，</span><br><span class="hljs-comment"># 在DC中他们也会指向不同的module（内容一样，名字不一样）</span><br>uniquify &gt; ./log/uniquify.rpt<br>check_design &gt; ./log/check_RTL.rpt <span class="hljs-comment">#检查设计是否一致，要消除report中所有error</span><br>replace_synthetic &gt; ./log/replace_synthetic.rpt <span class="hljs-comment">#将设计中的运算符替换为DesignWare中的IP</span><br><br><span class="hljs-comment">#############################环境约束###################################</span><br>set_operating_conditions -min_library wcells -min BEST -max_library wcells -max WORST<br><span class="hljs-built_in">set</span> auto_wire_load_selection <span class="hljs-literal">true</span> <br>set_wire_load_mode enclosed<br><span class="hljs-comment"># 从库中找一个标准单元来驱动所有输入</span><br>set_driving_cell -lib_cell winv_1 -pin op [all_inputs]<br>set_load 3 [all_outputs]<br><br><span class="hljs-comment">#############################优化约束##################################</span><br><span class="hljs-comment">#### 时钟约束 ####</span><br>create_clock -name <span class="hljs-string">&quot;clock&quot;</span> -period 10 -waveform &#123;0 5&#125; [get_ports clk]<br>set_clock_latency            1    [get_clocks clock]<br>set_clock_transition         0.3  [get_clocks clock]<br>set_clock_uncertainty -setup 0.8  [get_clocks clock]<br>set_clock_uncertainty -hold  0.4  [get_clocks clock]<br>set_drive 0  [get_ports clock] <span class="hljs-comment">#默认时钟驱动能力无穷大</span><br><span class="hljs-comment">#为了防止在时钟路径上插入Buffer而恶化时序，所以对时钟网络设置Dont_touch_network属性</span><br><span class="hljs-built_in">set</span> dont_touch_network [ list clock ]<br><span class="hljs-built_in">set</span> all_inputs_in_domain [get_ports [list Pi_Value hsync vsync configure_addr configure_value write <span class="hljs-built_in">read</span>]]<br><span class="hljs-built_in">set</span> all_outputs_in_domain [get_ports [list configured_value toned_pixel TValid]]<br>set_input_delay  -max       2.5 -clock <span class="hljs-string">&quot;clock&quot;</span> <span class="hljs-variable">$all_inputs_in_domain</span>    <br>set_input_delay  -min       0.4 -clock <span class="hljs-string">&quot;clock&quot;</span> <span class="hljs-variable">$all_inputs_in_domain</span><br>set_output_delay -max       2.5 -clock <span class="hljs-string">&quot;clock&quot;</span> <span class="hljs-variable">$all_outputs_in_domain</span><br>set_output_delay -min       0.4 -clock <span class="hljs-string">&quot;clock&quot;</span> <span class="hljs-variable">$all_outputs_in_domain</span><br><br><br><span class="hljs-comment">#############################DRC约束##################################</span><br><span class="hljs-comment">#0.35先使用库中的默认值</span><br><span class="hljs-comment">#set_max_transition</span><br><span class="hljs-comment">#set_max_capacitance</span><br><span class="hljs-comment">#set_max_fanout</span><br><span class="hljs-comment">#set_max_delay</span><br><span class="hljs-comment">#set_min_delay</span><br><br><span class="hljs-comment">#############################生成Netlist###############################</span><br><span class="hljs-comment">#### One Pass Compilation ####</span><br>current_design TMO_System<br>compile_ultra -timing_high_effort_script  &gt; ./log/compile_pass1.rpt<br>set_auto_disable_drc_nets  -clock  <span class="hljs-literal">true</span>  -constant  <span class="hljs-literal">true</span><br><span class="hljs-built_in">set</span>  bus_inference_descending_sort   <span class="hljs-literal">true</span><br><span class="hljs-built_in">set</span>  bus_inference_style     %s\[%d\]<br><span class="hljs-built_in">set</span>  bus_naming_style        %s\[%d\]<br><span class="hljs-built_in">set</span>  verilogout_no_tri <span class="hljs-literal">true</span><br><span class="hljs-built_in">set</span>  verilogout_show_unconnected_pins <span class="hljs-literal">true</span><br>set_fix_multiple_port_nets  -all -buffer_constants<br>remove_unconnected_ports [get_cells -hier &#123;*&#125;]<br><span class="hljs-built_in">set</span>  change_names_dont_change_bus_members   <span class="hljs-literal">true</span><br>change_names  -hier   -rules   verilog<br><span class="hljs-comment">#change_names  -hier   -rules   lab_vlog</span><br><br><span class="hljs-comment">#### Two Pass Compilation ####</span><br>current_design TMO_System <br>compile_ultra -incremental  &gt; ./log/compile_incr.rpt<br><span class="hljs-built_in">set</span>  bus_inference_descending_sort   <span class="hljs-literal">true</span><br><span class="hljs-built_in">set</span>  bus_inference_style     %s\[%d\]<br><span class="hljs-built_in">set</span>  bus_naming_style        %s\[%d\]<br><span class="hljs-built_in">set</span>  verilogout_no_tri <span class="hljs-literal">true</span><br><span class="hljs-built_in">set</span>  verilogout_show_unconnected_pins <span class="hljs-literal">true</span><br>set_fix_multiple_port_nets  -all -buffer_constants<br>remove_unconnected_ports [get_cells -hier &#123;*&#125;]<br><span class="hljs-built_in">set</span>  change_names_dont_change_bus_members   <span class="hljs-literal">true</span><br>change_names  -hier   -rules   verilog<br><span class="hljs-comment">#Check Netlist</span><br>check_design &gt; ./log/check_netlist.rpt<br>current_design TMO_System<br>write -f verilog -h -output ./netlist/TMO_System_syn.v<br>write -f ddc -h -output ./unmapped/TMO_System.ddc<br>write_sdc  ./unmapped/TMO_System.sdc  -version 1.4<br><br><span class="hljs-comment">#get reports</span><br>report_timing -to [all_outputs]  -max_paths 5000 -nworst 5000 &gt; ./log/timing_max_output.rpt<br>report_timing -to [all_registers -data_pins]    -max_paths 5000 -nworst 5000 &gt; ./log/timing_max_register.rpt       <br>report_timing -to [all_outputs]                 -max_paths 5000 -nworst 5000  -delay min \<br>                                                &gt; ./log/timing_min_output.rpt<br>report_timing -to [all_registers -data_pins]  -max_paths 5000 -nworst 5000  -delay min \<br>                                              &gt; ./log/timing_min_register.rpt<br>report_area   &gt; ./log/area.rpt<br>report_power  &gt; ./log/power.rpt<br></code></pre></td></tr></table></figure>
<h1 id="第二章vcs">第二章：VCS</h1>
<h1 id="第三章primetime">第三章：PrimeTime</h1>
<ul>
<li><strong>PrimeTime PX</strong> for estimating the power
consumption</li>
</ul>
<h2 id="时序分析">3.1时序分析</h2>
<ul>
<li><p>动态时序分许：基于动态仿真的方法，既能够验证设计的功能，也能够验证设计的时序。</p></li>
<li><p>静态时序分许：通过提取整个电路的所有时序路径，检查建立时间和保持时间是否满足要求。分析执行速度快，不需要测试向量，适合进行大规模集成电路的验证，可节约大量时间。</p></li>
</ul>
<p>随着设计尺寸和复杂性的增加，动态仿真所需时间及工作量都难以承受，在设计流程中成为一个严重的瓶颈，促使时序分析技术从动态向静态迁移。并由此诞生了静态时序分析工具。</p>
<h2 id="pt命令">3.2PT命令</h2>
<p>PT的输入可以使db、Verilog、VHDL或EDIF格式的文件。</p>
<p>read_ db -netlist_ _only <design name> .db <figure class="highlight tcl"><table><tr><td class="code"><pre><code class="hljs tcl">read_db -netlist_only &lt;design name&gt;.db  #db <span class="hljs-keyword">format</span><br>read_verilog &lt;design name&gt;.sv   #verilog <span class="hljs-keyword">format</span><br>read_vhdl &lt;design name&gt;.svhd    #vhdl <span class="hljs-keyword">format</span><br>read_edif &lt;design name&gt;.edf     #edif <span class="hljs-keyword">format</span><br><br><br>create_clock -period <span class="hljs-number">20</span> -waveform &#123;<span class="hljs-number">0</span> <span class="hljs-number">10</span>&#125; [<span class="hljs-keyword">list</span> CLK]  # 创建时钟<br>set_clock_latency <span class="hljs-number">2.5</span> [get_clocks CLK]<br>set_clock_transition <span class="hljs-number">0.2</span> [get_clocks CLK]<br><br><span class="hljs-comment">#插入时钟树之后布图工具通常接着要进行传播时钟，网表被带回PT进行STA</span><br><span class="hljs-comment">#时钟通过网表中的整个时钟树网络传播以确定时钟延迟。换言之，对通过时钟树中每个单元的延迟和单元间的互连线延迟都要加以考虑</span><br>set_propagated_clock [get_clocks CLK]<br>set_clock_uncertainty <span class="hljs-number">0.5</span> -from [get_clocks CLK1] -to [get_clocks CLK2]<br><br><span class="hljs-comment">#定义生成时钟与源时钟间的关系</span><br><span class="hljs-comment">#在布图后时序分析中，插入了时钟树并通过时钟树缓冲器传播时钟信号来计算时钟延迟。用户选择定义独立于时钟源的分频时钟（通过在分频逻辑子模块的输出引脚上定义时钟）。然而，这个方法迫使设计人员从时钟源到分频逻辑模块的时钟延迟手动添加从分频模块到设计的其余部分的时钟树延迟。通过下述命令建立分频时钟，则这两个时钟在布图前和布图后阶段都保持同步。</span><br>create_generated_clock -name &lt;divided <span class="hljs-keyword">clock</span> name&gt;<br>										 -<span class="hljs-keyword">source</span> &lt;primary <span class="hljs-keyword">clock</span> name&gt;<br>                       -divide_by &lt;value&gt;<br>                       &lt;pin name&gt;<br>                       <br><span class="hljs-comment"># PT允许对门控时钟指定建立/保持要求</span><br>set_clock_gating_check -setup &lt;value&gt;<br>										 -hold &lt;value&gt;<br>								     &lt;object <span class="hljs-keyword">list</span>&gt;<br><br></code></pre></td></tr></table></figure></p>
<h2 id="primetime-px">3.3PrimeTime PX</h2>
<p>PT如果进行功耗分析需要额外的PTPX的licence，可以通过命令打开：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><code class="hljs tcl">set_app_var power_enable_analysis true #默认为false<br></code></pre></td></tr></table></figure>
<p><strong>在EDA工具的安装目录底下有Lab教程和相关设计文件</strong></p>
<figure>
<img src="SynopsysEDA.assets/Power%20Analysis%20Flow.png"
alt="Power Analysis Flow" />
<figcaption aria-hidden="true">Power Analysis Flow</figcaption>
</figure>
<p><strong>Power = Leakage Power + Dynamic Power(internal power and
switching power)</strong></p>
<p><strong>动态功耗</strong>：电容充放电引起的功耗、短路功耗。</p>
<p><strong>静态功耗</strong>：主要为泄露电流和亚阈值电流引起的功耗。</p>
<p>PTPX支持两种功耗分析模式： <strong>averaged
mode</strong>和<strong>time-based mode</strong>。</p>
<h3 id="命令">命令</h3>
<p><strong>Setting the Concurrent Multirail Power Analysis
Mode</strong></p>
<p>PTPX supports concurrent power analysis on multiple power rails. This
feature improves the performance because, a single run of the
update_power command analyzes multiplepower rails or power supply nets
in the UPF mode, simultaneously. The concurrent multirail power analysis
is supported in both averaged and time-based power analysis modes. When
you run the update_power command with this variable set to true, the
tool simultaneously updates all the valid power rails in the design.</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">set</span> power_enable_multi_rail_analysis true<br></code></pre></td></tr></table></figure>
<p><strong>Estimating Clock Network Power Consumption</strong></p>
<p>You can estimate the additional power incurred by a clock network
prior to its insertion. You enable this feature with the
estimate_clock_network_power command, which provides a more accurate
analysis of the total design power when clock network synthesis has not
yet been performed. Before issuing the estimate_clock_network_power
command, you must identify the design clocks.</p>
<p>If you want PrimeTime PX to consider clock-gating cells to be part of
the clock network, set the</p>
<p>power_clock_network_include_clock_gating_network</p>
<p>variable to true. The default value of this variable is false.</p>
<p>The estimate_clock_network_power command is supported only in the
averaged power analysis mode.</p>
<h3 id="averaged-power-analysis"><strong>Averaged Power
Analysis</strong></h3>
<p>For purely averaged power analysis, PrimeTime PX supports propagation
of switching activity based on <strong>defaults</strong>,
<strong>user-defined switching</strong>, or switching derived from an
<strong>HDL simulation</strong> (either RTL or gate level).</p>
<p>（1）有波形文件：最理想的情况是能提供后仿产生的VCD/SAIF文件，通过<strong>read_vcd</strong>/<strong>read_saif</strong>将真实的翻转率反标到Net上，然后通过<strong>report_switching_activity</strong>检查反标率，最后<strong>report_power</strong>报功耗值。</p>
<p>（2）人为设置翻转率：根据以往项目的经验值，通过<strong>set_switching_activity/set_case_analysis</strong>来设置register，clock
gate以及memory/blackbox的翻转率</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><code class="hljs tcl">reset_switching_activity # 重置之前设置的翻转率<br><br><span class="hljs-comment"># 设置register翻转率</span><br>set_switching_activity [get_pins -of_object [all_registers]] -toggle_rate <span class="hljs-number">0.5</span> -static_probability <span class="hljs-number">0.5</span> -base_clock * <br><span class="hljs-comment"># 设置blockboxs上的翻转率</span><br>set_switching_activity -type black_boxes -toggle_rate <span class="hljs-number">0.1</span> -static_probability <span class="hljs-number">0.5</span> -base_clock * -hierarchy <br>set_switching_activity -toggle_rate <span class="hljs-number">0.5</span> -static_probability <span class="hljs-number">0.5</span> -base_clock * [remove_from_collection [all_inputs] [get_port -filter <span class="hljs-string">&quot;is_clock_used_as_clock == true&quot;</span>]] # 设置Input上的翻转率<br>set_switching_activity [get_pins -of_object [get_cells -hierarchical * -filter <span class="hljs-string">&quot;ref_name =~ *ICG*&quot;</span>]] -toggle_rate <span class="hljs-number">0.5</span> -static_probability <span class="hljs-number">0.5</span> -base_clock * （设置<span class="hljs-keyword">clock</span> gate上的翻转率）<br>set_case_analysis <span class="hljs-number">1</span> [get_ports *reset*] # 使reset信号不翻转，准静态信号<br>set_switching_activity -toggle_rate <span class="hljs-number">0</span> -static_probability <span class="hljs-number">1</span> -base_clock * [get_port *reset*]<br></code></pre></td></tr></table></figure>
<p>（3）<strong>Vector-Free Power Analysis：</strong>使用默认翻转率</p>
<p>The default value of the static probability and toggle rate are 0.5
and 0.1. If required, you can change thedefault toggle rate. This usage
model is useful for quick power estimation.</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><code class="hljs tcl">set_app_var power_default_toggle_rate <span class="hljs-number">0.5</span> # 默认值为 <span class="hljs-number">0.1</span><br>set_app_var power_default_static_probability <span class="hljs-number">0.5</span> # 默认值为<span class="hljs-number">0.5</span><br>set_app_var power_default_toggle_rate_reference_clock fastest # 默认值related<br></code></pre></td></tr></table></figure>
<p>The following commands and variables affect the default togglerates
used by the tool:</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><code class="hljs tcl">create_clock<br><span class="hljs-keyword">set</span> power_default_toggle_rate<br><span class="hljs-keyword">set</span> power_default_static_probability<br><span class="hljs-keyword">set</span> power_default_toggle_rate_reference_clock<br>set_switching_activity<br>reset_switching_activity<br>set_case_analysis<br></code></pre></td></tr></table></figure>
<p>在PT中report_switching_activity会报出所有Nets的switching
activity来源的统计数据：</p>
<p><strong>From Activity File：</strong> The switching activity value is
from a SAIF or VCD file，
在read_vcd或者read_saif时要注意通过<strong>-stripe_path</strong>选项指定合适的hierarchical层次，否则activity反标不上。</p>
<p><strong>From SSA： </strong>The switching activity value set by using
the <strong>set_switching_activity</strong> command.</p>
<p><strong>From SCA ：</strong>The switching activity set by using the
<strong>set_case_analysis</strong> command.</p>
<p><strong>From clock ：</strong>The switching activity set by using the
create_clock command.</p>
<p><strong>Default：</strong>对于用户没有指定的翻转率的Net，使用默认的翻转率</p>
<p><strong>Propagated：</strong>The switching activity from
<strong>propagation engine</strong></p>
<p><strong>Implied：</strong>Switching activity from simple automatic
propagation of activity <strong>through buffers and
inverters</strong></p>
<p><strong>Not
Annotated：</strong>没有反标翻转率的Net，需要特别注意，一般要求在update_power或者report_power之后，这部分占比应该很低甚至为0，如果有大量没有翻转的Net，会影响report_power的准确率，可以通过以下命令打印出来分析：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><code class="hljs tcl">report_switching_activity -list_not_annotated    <br>get_switching_activity ...<br></code></pre></td></tr></table></figure>
<h3 id="averaged-power-analysis-script">Averaged Power Analysis
Script</h3>
<figure class="highlight tcl"><table><tr><td class="code"><pre><code class="hljs tcl"><span class="hljs-comment"># Set the Power Analysis Mode</span><br><span class="hljs-keyword">set</span> power_enable_analysis TRUE<br><span class="hljs-keyword">set</span> power_analysis_mode averaged<br><br><span class="hljs-comment"># Read and link the Gate Level Netlist</span><br><span class="hljs-keyword">set</span> search_path <span class="hljs-string">&quot;../src/hdl/gate ../src/lib/snps . &quot;</span><br><span class="hljs-keyword">set</span> link_library <span class="hljs-string">&quot; * core_typ.db&quot;</span><br>read_verilog mac.vg<br>current_design mac<br>link<br><br><span class="hljs-comment"># Read SDC and set transition time or annotate parasitics</span><br>read_sdc ../src/hdl/gate/mac.sdc<br>set_disable_timing [get_lib_pins ssc_core_typ/*/G]<br>read_parasitics ../src/annotate/mac.spef.gz<br><br><span class="hljs-comment"># check, update, or report the timing</span><br>check_timing<br>update_timing<br>report_timing<br><br><span class="hljs-comment"># read switching activity file</span><br>read_vcd -strip_path tb/macinst ../sim/vcd.dump.gz<br>report_switching_activity -list_not_annotated<br><br><span class="hljs-comment"># check or update or report power</span><br>check_power<br>update_power<br>report_power -hierarchy<br></code></pre></td></tr></table></figure>
<h3 id="time-based-power-analysis"><strong>Time-based power
analysis</strong></h3>
<p>For extremely accurate analysis of power with respect to time,
PrimeTime PX supports analysis <strong>based on the RTL or gate-level
simulation activity over time</strong>.</p>
<p>PrimeTime PX uses an event-driven algorithm to calculate the
powerconsumption for each event. Detailed time-based power waveforms are
generatedto provide both average and peak power results. The tool can
produce an average and peak power report.</p>
<p>通过以下选项开启，在该模式下，需要提供VCD（<strong>注：SAIF文件不行</strong>）</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">set</span> power_enable_analysis TRUE<br><span class="hljs-keyword">set</span> power_analysis_mode time_based<br>set_app_var power_analysis_mode time_based # 默认为averaged<br></code></pre></td></tr></table></figure>
<p>time
based模式下工具会分析峰值功耗，生成功耗波形等图，执行完功耗分析之后，会在当前工作目录底下保存.fsdb波形文件</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><code class="hljs tcl">set_power_analysis_options -waveform_format fsdb -waveform_output [name]<br>nWave &amp;       # 使用nWave波形查看器查看波形文件<br></code></pre></td></tr></table></figure>
<h3 id="time-based-power-analysis-script">Time-based power analysis
Script</h3>
<figure class="highlight tcl"><table><tr><td class="code"><pre><code class="hljs tcl"><span class="hljs-comment"># Set the Power Analysis Mode</span><br><span class="hljs-keyword">set</span> power_enable_analysis TRUE<br><span class="hljs-keyword">set</span> power_analysis_mode time_based<br><span class="hljs-comment">#set_power_analysis_options # 为功耗分析设置选项</span><br><span class="hljs-comment">#set_app_var power_limit_extrapolation_range true # 超过功耗查找表时，可以外推，默认是false</span><br><span class="hljs-comment">#set_app_var power_use_ccsp_pin_capacitance true；# 考虑弥勒效应，默认是false</span><br><br><span class="hljs-comment"># link design</span><br><span class="hljs-keyword">set</span> search_path <span class="hljs-string">&quot;../src/hdl/gate ../src/lib/snps . &quot;</span><br><span class="hljs-keyword">set</span> link_library <span class="hljs-string">&quot; *core_typ.db&quot;</span><br>read_verilog mac.vg<br>current_design mac<br>link<br><br><span class="hljs-comment"># set transition time/annotate parasitics</span><br>read_sdc ../src//hdl/gate/mac.sdc<br>set_disable_timing [get_lib_pins ssc_core_typ/*/G]<br>read_parasitics ../src/annotate/mac.spef.gz<br><br><span class="hljs-comment"># analyze timing</span><br>check_timing<br>update_timing # 更新时序关系<br>report_timing<br><br><span class="hljs-comment"># read switching activityfile</span><br>read_vcd ../sim/vcd.dump.gz \<br>  -strip_path tb/macinst<br><span class="hljs-comment"># read_vpd</span><br><span class="hljs-comment"># read_fsdb</span><br><span class="hljs-comment"># read_saif 用在平均功耗分析上</span><br><span class="hljs-comment"># set_switching_activity </span><br><span class="hljs-comment"># set_case_analysis </span><br><br><span class="hljs-comment"># analyze power</span><br>check_power # 检查会影响功耗准确性的错误，默认的检查内容由power_check_defaults定义<br>set_power_analysis_options \<br>  -waveform_format out \<br>  -waveform_output vcd<br>update_power # 进行功耗分析<br>report_power<br></code></pre></td></tr></table></figure>
<h3 id="required-files-descriptions"><strong>Required Files
descriptions</strong></h3>
<p><strong>逻辑库</strong>：单元库，包含所有单元的时序和功耗特性，db文件；</p>
<p><strong>spef文件</strong>：寄生参数文件；</p>
<ul>
<li><p><strong>Gate-Level
Netlist：</strong>verilog、vhdl，db、ddc、Milkyway格式的网表均可</p></li>
<li><p><strong>Technology Library</strong></p></li>
</ul>
<p>PTPX supports either CCS (composite current source) or NLPM
(nonlinear power model).</p>
<p>You use the power_model_preference nlpm | ccs variable to specify
your power model preference when the library contains both NLPM and CCS
data. The default is ccs.</p>
<ul>
<li><strong>SDC File</strong></li>
</ul>
<p>The SDC file contains the <strong>design constraints</strong>. The
driver cellinformation is used to calculate the transition time on the
primary inputs.</p>
<ul>
<li><p><strong>Parasitic File</strong></p></li>
<li><p><strong>Switching
Activity：</strong>vcd、vpd、fsdb、saif文件，或者命令设置</p></li>
</ul>
<p>In the averaged power analysis, you use either SAIF or VCD file
formats to read the switching activity. If you do not specify switching
activity information, the tool assumes certain default values for the
switching activity.</p>
<p>In time-based power analysis, you use VCD file formats to read the
switching activity.</p>
<p>When you read a SAIF file or an RTL VCD file for power estimation,
use the set_rtl_to_gate_name command to map the RTL and gate-level
object names. This command is especially necessary if you have performed
only the RTL simulation for generating the backward SAIF file. Because
the RTL object names can change after synthesis, the read_saif or
read_vcd command is not able to map the names present in the RTL SAIF or
VCD fileto the gate-level objects, which can result in inaccurate
results. You can avoid this by using the set_rtl_to_gate_name
command.</p>
<h2 id="vcdsaiffsdb的区别">3.4VCD，SAIF，FSDB的区别</h2>
<h4 id="vcdvaluevariable-change-dump">VCD：Value/Variable Change
Dump</h4>
<ul>
<li>It is an event-based format that contains every value change for the
signals in the design and the time at which they occurred.</li>
<li>VCD is supported in both the averaged and time-based analysis
modes，是国际标准格式</li>
<li>Gate-Level VCD和RTL-Level VCD都可以，但是使用RTL-Level
VCD时，需要进行name mapping (set_rtl_to_gate_name)。</li>
<li>VCD文件示例：http://en.wikipedia.org/wiki/Value_change_dump</li>
</ul>
<h4 id="saifswitching-activity-interface-format">SAIF：Switching
Activity Interface Format</h4>
<ul>
<li>It captures signal transitions and the time spent at each logic
level. The SAIF file contains the toggle counts and static probabilities
for the nets in the design.</li>
<li>SAIF is supported only in the averaged power analysis mode.</li>
<li>有些工具，比如ICC/ICC2，只支持SAIF文件，需要将VCD转换成SAIF文件，在PT安装目录下有一个utility：</li>
<li>vcd2saif -input vcd_file -output saif_file ...</li>
</ul>
<h4 id="fsdbfast-signal-databbase">FSDB：Fast Signal DataBbase</h4>
<ul>
<li>类似于VCD的波形文件，去除了VCD中的冗余信息，数据量小很多，提高了仿真的速度，Synopsys的仿真工具支持较多。</li>
</ul>
<h1 id="第四章icc-compiler">第四章：ICC Compiler</h1>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>EDA</tag>
        <tag>数字IC</tag>
      </tags>
  </entry>
  <entry>
    <title>Transformer</title>
    <url>/2023/03/02/Transformer/</url>
    <content><![CDATA[<h1 id="self-attention自注意力机制">Self-Attention自注意力机制</h1>
<figure>
<img src="Transformer.assets/self-attention.png" alt="self-attention" />
<figcaption aria-hidden="true">self-attention</figcaption>
</figure>
<span id="more"></span>
<p>​
为了将单词融入到语境中，可以用权重来描述某个单词与其他单词之间的关系</p>
<h2 id="权重如何计算">权重如何计算？</h2>
<figure>
<img src="Transformer.assets/微信截图_20230302134556.png"
alt="微信截图_20230302134556" />
<figcaption aria-hidden="true">微信截图_20230302134556</figcaption>
</figure>
<figure>
<img src="Transformer.assets/1.png" alt="1" />
<figcaption aria-hidden="true">1</figcaption>
</figure>
<p>每个词都有一个编码后的词向量，以及用来<strong>询问</strong>其他词的Q向量，和用来回答的K向量。<span
class="math inline">\(X_i\)</span>与<span
class="math inline">\(X_j\)</span>的关系可以通过<span
class="math inline">\(Q_i·K_j\)</span>得到，内积值即score，再经过<strong>softmax</strong>就是权值，权值用于对value进行加权求和，得到当前词的特征表达。</p>
<figure>
<img src="Transformer.assets/微信截图_20230302143353.png"
alt="微信截图_20230302143353" />
<figcaption aria-hidden="true">微信截图_20230302143353</figcaption>
</figure>
<h2 id="multi-headed机制">Multi-Headed机制</h2>
<figure>
<img src="Transformer.assets/微信截图_20230302152054.png"
alt="微信截图_20230302152054" />
<figcaption aria-hidden="true">微信截图_20230302152054</figcaption>
</figure>
<figure>
<img src="Transformer.assets/微信截图_20230302152255.png"
alt="微信截图_20230302152255" />
<figcaption aria-hidden="true">微信截图_20230302152255</figcaption>
</figure>
<figure>
<img src="Transformer.assets/微信截图_20230302152505.png"
alt="微信截图_20230302152505" />
<figcaption aria-hidden="true">微信截图_20230302152505</figcaption>
</figure>
<p>一般用8个head</p>
<ul>
<li>不同的注意力结果</li>
<li>得到的特征向量表达也不相同</li>
</ul>
<figure>
<img src="Transformer.assets/微信截图_20230302155945.png"
alt="微信截图_20230302155945" />
<figcaption aria-hidden="true">微信截图_20230302155945</figcaption>
</figure>
<h2 id="位置信息表达">位置信息表达</h2>
<figure>
<img src="Transformer.assets/微信截图_20230302160219.png"
alt="微信截图_20230302160219" />
<figcaption aria-hidden="true">微信截图_20230302160219</figcaption>
</figure>
<h2 id="连接与层归一化">连接与层归一化</h2>
<figure>
<img src="Transformer.assets/微信截图_20230302164104.png"
alt="微信截图_20230302164104" />
<figcaption aria-hidden="true">微信截图_20230302164104</figcaption>
</figure>
<h2 id="decoder">Decoder</h2>
<figure>
<img src="Transformer.assets/微信截图_20230302164316.png"
alt="微信截图_20230302164316" />
<figcaption aria-hidden="true">微信截图_20230302164316</figcaption>
</figure>
<h2 id="整体架构">整体架构</h2>
<figure>
<img src="Transformer.assets/微信截图_20230302205235.png"
alt="微信截图_20230302205235" />
<figcaption aria-hidden="true">微信截图_20230302205235</figcaption>
</figure>
<h1 id="梅森螺旋">梅森螺旋</h1>
<p><a
href="http://www.math.sci.hiroshima-u.ac.jp/m-mat/MT/emt.html">Mersenne
Twister: A random number generator (since 1997/10)</a></p>
<p>Mersenne
Twister这个名字来自周期长度通常取Mersenne素数这样一个事实。常见的有两个变种Mersenne
Twister MT19937和Mersenne Twister MT19937-64。</p>
<p>Mersenne Twister算法的原理：Mersenne
Twister算法是利用线性反馈移位寄存器(LFSR)产生随机数的，LFSR的反馈函数是寄存器中某些位的简单异或。</p>
<p>一个n位的LFSR在重复之前最多产生<span
class="math inline">\(2^n-1\)</span>位的伪随机序列。只有具有一定抽头序列的LFSR才能产生<span
class="math inline">\(2^n-1\)</span>位长的伪随机序列。为了使LFSR成为最大周期的LFSR，由抽头序列加上常数1形成的多项式必须是本原多项式。例如(32,7,5,3,2,1,0)是指本原多项式<span
class="math inline">\(x^{32}+x^7+x^5+x^3+x^2+x+1\)</span>，把它转化为最大周期LFSR就是在LFSR的第32，7，5，2，1位抽头。利用上述两种方法产生周期为m的伪随机序列后，只需要将产生的伪随机序列除以序列的周期，就可以得到(0，1)上均匀分布的伪随机序列了。</p>
<p>Mersenne
Twister优点：随机性好，在计算机上容易实现，占用内存较少(MT19937的C代码执行仅需624个字的工作区域)，与其它已使用的伪随机数发生器相比，产生随机数的速度快、周期长，可达到2^19937-1，且具有623维均匀分布的性质，序列关联比较小，能通过很多随机性测试。</p>
<p><strong>其他随机数产生器性能对比</strong></p>
<h1 id="verilog实现">Verilog实现</h1>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>3D堆叠</title>
    <url>/2023/03/04/User%20Guide/</url>
    <content><![CDATA[<h1 id="front-matter">Front-matter</h1>
<p>Front-matter 是 markdown 文件最上方以 ---
分隔的区域，用於指定個別檔案的變數。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">Page Front-matter 用于页面配置<br>Post Front-matter 用于文章页配置<br></code></pre></td></tr></table></figure>
<h2 id="page-front-matter">Page Front-matter</h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">---<br>title:<br>date:<br>updated:<br>type:<br>comments:<br>description:<br>keywords:<br>top<span class="hljs-emphasis">_img:</span><br><span class="hljs-emphasis">mathjax:</span><br><span class="hljs-emphasis">katex:</span><br><span class="hljs-emphasis">aside:</span><br><span class="hljs-emphasis">aplayer:</span><br><span class="hljs-emphasis">highlight_</span>shrink:<br>---<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://typora-picture-lzm.oss-cn-beijing.aliyuncs.com/img/typora/home.webp"
alt="home" />
<figcaption aria-hidden="true">home</figcaption>
</figure>
]]></content>
      <categories>
        <category>微电子工艺</category>
      </categories>
      <tags>
        <tag>3D堆叠</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记</title>
    <url>/2022/11/02/linux/</url>
    <content><![CDATA[<h2 id="添加环境变量"><strong>1.添加环境变量</strong></h2>
<p>https://www.cnblogs.com/youyoui/p/10680329.html</p>
<p>1、Linux的环境变量是保存在变量PATH中</p>
<ul>
<li><strong>export</strong>命令显示当前系统定义的所有环境变量</li>
<li><strong>echo $PATH</strong>命令输出当前的PATH环境变量的值</li>
</ul>
<p>2、Linux环境变量值之间是通过冒号分隔的( : )</p>
<p><strong>临时添加环境变量PATH：</strong>可通过export命令，如将/usr/local/nginx/sbin/目录临时添加到环境变量中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=/usr/local/nginx/sbin/:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="常用命令">2.常用命令</h2>
<h3 id="开启全部权限解锁文件">开启全部权限：解锁文件</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chmod</span> -R 777 xx/xx/xx<br></code></pre></td></tr></table></figure>
<h3 id="tar命令">tar命令</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">解压命令:tar -xzvf xxx.tar.gz <br>压缩命令:tar zcvf 文件名.tar.gz 待压缩的文件名<br>//-x 表示 extract， 提取，因为是解压所以使用。<br>//-c 表示压缩，compress<br>//-z 表示先使用 gzip支持压缩或解压缩。其他的压缩或解压缩方式，比如-j表示bzip2的方式<br>//-v 表示 verbose，在压缩或解压缩过程中显示正在处理的文件名<br>//-f 表示 file，指定要处理的 tar 包<br>//-C 可以指定输出目录,默认是解压到当前目录<br>*.tar用tar -xvf解压<br>*.gz 用gzip -d或者gunzip解压<br>*.tar.gz和*.tgz用tar -xzf解压<br>*.bz2 用bzip2 -d或者用bunzip2解压<br>*.tar.bz2用tar -xjf解压<br>*.Z 用uncompress解压<br>*.tar.Z用tar -xZf解压<br>*.rar 用unrar e解压<br>*.zip用unzip解压<br></code></pre></td></tr></table></figure>
<h2 id="git">3.git</h2>
<p>When you want to commit the change, type</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git add .<br>git commit --allow-empty -am <span class="hljs-string">&quot;提交备注&quot;</span><br></code></pre></td></tr></table></figure>
<p>The <code>--allow-empty</code> option is necessary, because usually
the change is already committed by development tracing system. Without
this option, <code>git</code> will reject no-change commits</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">// 删除本地分支<br>git branch -d localBranchName<br><br>// 删除远程分支<br>git push origin --delete remoteBranchName<br></code></pre></td></tr></table></figure>
<h2 id="make">4.make</h2>
<p>通过<code>lscpu</code>命令来查询有多少个CPU.
在<code>make</code>时候添加<code>-j?</code>的参数,
其中<code>?</code>为你查询到的CPU数量.</p>
<p>为了查看编译加速的效果, 在编译的命令前面添加<code>time</code>命令,
它将会对紧跟在其后的命令的执行时间进行统计。可以通过<code>make clean</code>清除所有的编译结果,
然后重新编译并统计时间,</p>
<h2 id="gdb">5.GDB</h2>
<h3 id="常用命令-1">常用命令</h3>
<blockquote>
<ul>
<li>start #开始调试,停在第一行代码处,(gdb)start</li>
<li>finish #执行到函数retun返回</li>
<li>bt（backtrace） #列出调用栈</li>
<li>info locals #列出当前函数的局部变量</li>
<li>l #list的缩写查看源代码,(gdb) l [number/function]</li>
<li>watch var_name #追踪变量</li>
<li>b <lines> #b: Breakpoint的简写，<strong>设置断点</strong>。(gdb) b
10</li>
<li>b <func> #b: Breakpoint的简写，设置断点。(gdb) b main</li>
<li>b filename:[line/function]
#b:在文件filename的某行或某个函数处设置断点</li>
<li>i breakpoints #i:info 的简写。(gdb)i breakpoints</li>
<li>d [bpNO] #d: Delete
breakpoint，删除指定编号的某个断点，或删除所有断点。(gdb)d 1</li>
<li>s #s:
step执行一行源程序代码，如果此行代码中有函数调用，<strong>则进入该函数</strong>；(gdb)
s</li>
<li>n #n:
next执行一行源程序代码，此行<strong>代码中的函数调用也一并执行</strong>。(gdb)
n</li>
<li>r
#run，运行被调试程序。如果没有下断点，则执行完；如果有断点，则程序暂停在第一个断点处。</li>
<li>c
#continue的简写，继续执行被调试程序，直至下一个断点或程序结束。</li>
<li>p [var]
#Print的简写，<strong>显示指定变量</strong>（临时变量或全局变量 例如 int
a）<strong>的值</strong>。(gdb) p a</li>
<li>display [var] #display，设置想要跟踪的变量(例如 int a)。(gdb)
display a</li>
<li>undisplay [varnum]
#undisplay取消对变量的跟踪，被跟踪变量用整型数标识。(gdb) undisplay
1</li>
<li>set args #可指定运行时参数。(gdb)set args 10 20</li>
<li>show args #查看运行时参数。</li>
<li>q #Quit的简写，退出GDB调试环境。(gdb) q</li>
<li>help [cmd]
#GDB帮助命令。如果指定“命令名称”参数，则显示该命令的详细说明；如果没有指定参数，则分类显示所有GDB命令(gdb)help</li>
<li>回车 #重复前面的命令，(gdb)回车</li>
</ul>
</blockquote>
<hr />
<h3 id="man命令">man命令</h3>
<table>
<colgroup>
<col style="width: 4%" />
<col style="width: 54%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="header">
<th>编号</th>
<th>说明</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Executable programs or shell commands</td>
<td><strong>标准Linux命令</strong></td>
</tr>
<tr class="even">
<td>2</td>
<td>System calls(functions provided by the kernel)</td>
<td><strong>系统调用（内核）</strong></td>
</tr>
<tr class="odd">
<td>3</td>
<td>Library functions(functions within program 1 ibraries)</td>
<td><strong>库函数</strong></td>
</tr>
<tr class="even">
<td>4</td>
<td>Special devices(usually found in /dev</td>
<td><strong>设备说明</strong>（通常在/dev下可以找到）</td>
</tr>
<tr class="odd">
<td>5</td>
<td>File formats and conventions eg /etc/ passwd</td>
<td><strong>文件格式</strong></td>
</tr>
<tr class="even">
<td>6</td>
<td>Games</td>
<td>游戏娱乐等</td>
</tr>
<tr class="odd">
<td>7</td>
<td>Miscellaneous</td>
<td>杂乱项</td>
</tr>
<tr class="even">
<td>8</td>
<td>System administration commands</td>
<td><strong>系统管理员命令</strong>（通常针对<strong>root</strong>用户）</td>
</tr>
<tr class="odd">
<td>9</td>
<td>Kernel routines</td>
<td>常规<strong>内核</strong>文件</td>
</tr>
</tbody>
</table>
<p>编号 说明 解释 1 Executable programs or shell commands 标准Linux命令
2 System calls 系统调用（内核） 3 Library functions 库函数 4 Special
devices 设备说明（通常在/dev下可以找到） 5 File formats 文件格式 6 Games
游戏娱乐等 7 Miscellaneous 杂乱项 8 System administration commands
系统管理员命令（通常针对root用户） 9 Kernel routines 常规内核文件</p>
<h3 id="list命令">list命令</h3>
<blockquote>
<p>list，显示当前行后面的源程序。</p>
<p>list - ，显示当前行前面的源程序</p>
<p>list <linenum> ，显示程序第linenum行周围的源程序</p>
<p>list <function> ，显示函数名为function的函数的源程序</p>
</blockquote>
<h3 id="break命令">break命令</h3>
<ul>
<li><p>break <function>在进入指定函数时停住</p></li>
<li><p>break <linenum>在指定行号停住</p></li>
<li><p>break +offset / break
-offset在当前行号的前面或后面的offset行停住</p></li>
<li><p>break filename:linenum在源文件filename的linenum行处停住</p></li>
<li><p>break
filename:function在源文件filename的function函数的入口处停住</p></li>
<li><p>break *address在程序运行的内存地址处停住</p></li>
<li><p>break表示在下一条指令处停住</p></li>
<li><p>break ... if <condition>“...”可以是上述的break <linenum>、break
+offset / break –offset中的参数，在循环体中，可以设置break if
i=100，表示当i为100时停住程序</p></li>
<li><p>查看断点时，可使用info命令，如info breakpoints n、info break
n（n表示断点号）</p></li>
</ul>
<h3 id="单步命令">单步命令</h3>
<p>next(n)的单步不会进入函数的内部，</p>
<p>step(s)命令则在单步执行一个函数时，会进入其内部</p>
<ul>
<li>step <count></li>
</ul>
<p>单步跟踪，如果有函数调用，则进入该函数（进入函数的前提是，此函数被编译有debug信息）。step后面不加count表示一条条地执行，加表示执行后面的count条指令，然后再停住。</p>
<ul>
<li>next <count></li>
</ul>
<p>单步跟踪，如果有函数调用，它不会进入该函数。同样地，next后面不加count表示一条条地执行，加表示执行后面的count条指令，然后再停住。</p>
<ul>
<li>set step-mode</li>
</ul>
<p>set step-mode
on用于打开step-mode模式，这样，在进行单步跟踪时，程序不会因为没有debug信息而不停住，这个参数的设置可便于查看机器码。set
step-mod off用于关闭step-mode模式。</p>
<ul>
<li>finish</li>
</ul>
<p>运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。</p>
<ul>
<li>until （缩写u）</li>
</ul>
<p>一直在循环体内执行单步，退不出来是一件令人烦恼的事情，until命令可以运行程序直到退出循环体。</p>
<ul>
<li>stepi（缩写si）和nexti（缩写ni）</li>
</ul>
<p>stepi和nexti用于单步跟踪一条机器指令，一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步执行机器指令。
另外，运行“display/i
$pc”命令后，单步跟踪会在打出程序代码的同时打出机器指令，即汇编代码。</p>
<h3 id="continue命令">continue命令</h3>
<p>当程序被停住后，可以使用continue命令（缩写c，fg命令同continue命令）恢复程序的运行直到程序结束，或到达下一个断点，命令格式为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">continue</span> [ignore-count]<br>c [ignore-count]<br>fg [ignore-count]<br></code></pre></td></tr></table></figure>
<p>ignore-count表示忽略其后多少次断点。
假设我们设置了函数断点add()，并watch
i，则在continue过程中，每次遇到add()函数或i发生变化，程序就会停住，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">(gdb) <span class="hljs-keyword">continue</span><br>Continuing.<br>Hardware watchpoint <span class="hljs-number">3</span>: i<br><br>Old value = <span class="hljs-number">2</span><br>New value = <span class="hljs-number">3</span><br><span class="hljs-number">0x0804838d</span> in <span class="hljs-built_in">main</span> () at gdb_example.c:<span class="hljs-number">23</span><br><span class="hljs-number">23</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>(gdb) <span class="hljs-keyword">continue</span><br>Continuing.<br><br>Breakpoint <span class="hljs-number">1</span>, <span class="hljs-built_in">main</span> () at gdb_example.c:<span class="hljs-number">25</span><br><span class="hljs-number">25</span>          sum[i] = <span class="hljs-built_in">add</span>(array1[i], array2[i]);<br>(gdb) <span class="hljs-keyword">continue</span><br>Continuing.<br>Hardware watchpoint <span class="hljs-number">3</span>: i<br><br>Old value = <span class="hljs-number">3</span><br>New value = <span class="hljs-number">4</span><br><span class="hljs-number">0x0804838d</span> in <span class="hljs-built_in">main</span> () at gdb_example.c:<span class="hljs-number">23</span><br><span class="hljs-number">23</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br></code></pre></td></tr></table></figure>
<h3 id="print命令">print命令</h3>
<p>在调试程序时，当程序被停住时，可以使用print命令（缩写为p），或是同义命令inspect来查看当前程序的运行数据。print命令的格式是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">print &lt;expr&gt;<br>print /&lt;f&gt; &lt;expr&gt;<br></code></pre></td></tr></table></figure>
<p><expr>是<a
href="https://so.csdn.net/so/search?q=表达式&amp;spm=1001.2101.3001.7020">表达式</a>，是被调试的程序中的表达式，<f>是输出的格式，比如，如果要把表达式按16进制的格式输出，那么就是/x。在表达式中，有几种GDB所支持的操作符，它们可以用在任何一种语言中，“@”是一个和数组有关的操作符，“::”指定一个在文件或是函数中的变量，“{<type>}
<addr>”表示一个指向内存地址<addr>的类型为type的一个对象。</p>
<p>下面演示了查看sum[]数组的值的过程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">(gdb) print sum<br>$<span class="hljs-number">2</span> = &#123;<span class="hljs-number">133</span>, <span class="hljs-number">155</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;<br>(gdb) next<br><br>Breakpoint <span class="hljs-number">1</span>, <span class="hljs-built_in">main</span> () at gdb_example.c:<span class="hljs-number">25</span><br><span class="hljs-number">25</span>          sum[i] = <span class="hljs-built_in">add</span>(array1[i], array2[i]);<br>(gdb) next<br><span class="hljs-number">23</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>(gdb) print sum<br>$<span class="hljs-number">3</span> = &#123;<span class="hljs-number">133</span>, <span class="hljs-number">155</span>, <span class="hljs-number">143</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;<br></code></pre></td></tr></table></figure>
<p>当需要查看一段连续内存空间的值的时间，可以使用GDB的“@”操作符，“@”的左边是第一个内存地址，“@”的右边则是想查看内存的长度。例如如下动态申请的内存：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs prettyprint">int *array = (int *) malloc (len * sizeof (int)); *array = (int *) malloc (len * sizeof (int));<br></code></pre></td></tr></table></figure>
<p>在GDB调试过程中这样显示出这个动态数组的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs prettyprint">p *array@len*array@len<br></code></pre></td></tr></table></figure>
<p>print的输出格式包括：</p>
<ul>
<li>x 按十六进制格式显示变量。</li>
<li>d 按十进制格式显示变量。</li>
<li>u 按十六进制格式显示无符号整型。</li>
<li>o 按八进制格式显示变量。</li>
<li>t 按二进制格式显示变量。</li>
<li>a 按十六进制格式显示变量。</li>
<li>c 按字符格式显示变量。</li>
<li>f 按浮点数格式显示变量。</li>
</ul>
<p>我们可用display命令设置一些自动显示的变量，当程序停住时，或是单步跟踪时，这些变量会自动显示。
如果要修改变量，如x的值，可使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs prettyprint">print x=4 x=4<br></code></pre></td></tr></table></figure>
<p>当用GDB的print查看程序运行时的数据时，每一个print都会被GDB记录下来。GDB会以$1，$2，$3
…这样的方式为每一个print命令编号。我们可以使用这个编号访问以前的表达式，如$1。</p>
<h3 id="watch命令">watch命令</h3>
<p>watch一般来观察某个表达式（变量也是一种表达式）的值是否有变化了，如果有变化，马上停住程序。我们有下面的几种方法来设置观察点：
watch
<expr>：为表达式（变量）expr设置一个观察点。一量表达式值有变化时，马上停住程序。rwatch
<expr>：当表达式（变量）expr被读时，停住程序。awatch
<expr>：当表达式（变量）的值被读或被写时，停住程序。info
watchpoints：列出当前所设置了的所有观察点。
下面演示了观察i并在连续运行next时一旦发现i变化，i值就会显示出来的过程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">(gdb) watch i<br>Hardware watchpoint <span class="hljs-number">3</span>: <span class="hljs-built_in">i</span><br>(gdb) next<br><span class="hljs-number">23</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>(gdb) next<br>Hardware watchpoint <span class="hljs-number">3</span>: i<br><br>Old value = <span class="hljs-number">0</span><br>New value = <span class="hljs-number">1</span><br><span class="hljs-number">0x0804838d</span> in <span class="hljs-built_in">main</span> () at gdb_example.c:<span class="hljs-number">23</span><br><span class="hljs-number">23</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>(gdb) next<br><br>Breakpoint <span class="hljs-number">1</span>, <span class="hljs-built_in">main</span> () at gdb_example.c:<span class="hljs-number">25</span><br><span class="hljs-number">25</span>          sum[i] = <span class="hljs-built_in">add</span>(array1[i], array2[i]);<br>(gdb) next<br><span class="hljs-number">23</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>(gdb) next<br>Hardware watchpoint <span class="hljs-number">3</span>: i<br><br>Old value = <span class="hljs-number">1</span><br>New value = <span class="hljs-number">2</span><br><span class="hljs-number">0x0804838d</span> in <span class="hljs-built_in">main</span> () at gdb_example.c:<span class="hljs-number">23</span><br><span class="hljs-number">23</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br></code></pre></td></tr></table></figure>
<h3 id="examine命令">examine命令</h3>
<p>我们可以使用examine命令（缩写为x）来查看内存地址中的值。examine命令的语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs prettyprint">x/&lt;n/f/u&gt; &lt;addr&gt; /&lt;n/f/u&gt; &lt;addr&gt; <br></code></pre></td></tr></table></figure>
<p><addr>表示一个内存地址。“x/”后的n、f、u都是可选的参数，n
是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容；f
表示显示的格式，如果地址所指的是字符串，那么格式可以是s，如果地址是指令地址，那么格式可以是i；u
表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4字节。u参数可以被一些字符代替：b表示单字节，h表示双字节，w表示四字节，g表示八字节。当我们指定了字节长度后，GDB会从指定的内存地址开始，读写指定字节，并把其当作一个值取出来。n、f、u这3个参数可以一起使用，例如命令“x/3uh
0x54320”表示从内存地址0x54320开始以双字节为1个单位（h）、16进制方式（u）显示3个单位（3）的内存。
==</p>
<p>譬如下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">main</span>()<br>&#123;<br>        <span class="hljs-type">char</span> *c = <span class="hljs-string">&quot;hello world&quot;</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, c);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们在</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> *c = <span class="hljs-string">&quot;hello world&quot;</span>;<br></code></pre></td></tr></table></figure>
<p>下一行设置断点后：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">(gdb) l<br><span class="hljs-number">1</span>    <span class="hljs-built_in">main</span>()<br><span class="hljs-number">2</span>    &#123;<br><span class="hljs-number">3</span>        <span class="hljs-type">char</span> *c = <span class="hljs-string">&quot;hello world&quot;</span>;<br><span class="hljs-number">4</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, c);<br><span class="hljs-number">5</span>    &#125;<br>(gdb) b <span class="hljs-number">4</span><br>Breakpoint <span class="hljs-number">1</span> at <span class="hljs-number">0x100000f17</span>: file main.c, line <span class="hljs-number">4.</span><br>(gdb) r<br>Starting program: /Users/songbarry/main<br>Reading symbols <span class="hljs-keyword">for</span> shared libraries +. done<br><br>Breakpoint <span class="hljs-number">1</span>, <span class="hljs-built_in">main</span> () at main.c:<span class="hljs-number">4</span><br><span class="hljs-number">4</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, c);<br></code></pre></td></tr></table></figure>
<p>可以通过多种方式看C指向的字符串：</p>
<p>方法1：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">(gdb) p c<br>$<span class="hljs-number">1</span> = <span class="hljs-number">0x100000f2e</span> <span class="hljs-string">&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure>
<p>方法2：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">(gdb) x/s <span class="hljs-number">0x100000f2e</span><br><span class="hljs-number">0x100000f2e</span>:	 <span class="hljs-string">&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure>
<p>方法3：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">(gdb) <span class="hljs-built_in">p</span> (<span class="hljs-type">char</span> *)<span class="hljs-number">0x100000f2e</span><br>$<span class="hljs-number">3</span> = <span class="hljs-number">0x100000f2e</span> <span class="hljs-string">&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure>
<p>将第一个字符改为大写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">(gdb) p *(<span class="hljs-type">char</span> *)<span class="hljs-number">0x100000f2e</span>=<span class="hljs-string">&#x27;H&#x27;</span><br>$<span class="hljs-number">4</span> = <span class="hljs-number">72</span> <span class="hljs-string">&#x27;H&#x27;</span><br></code></pre></td></tr></table></figure>
<p>再看看C：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">(gdb) p c<br>$<span class="hljs-number">5</span> = <span class="hljs-number">0x100000f2e</span> <span class="hljs-string">&quot;Hello world&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="set命令">set命令</h3>
<p>修改寄存器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">(gdb) set $v0 = <span class="hljs-number">0x004000000</span><br>(gdb) set $epc = <span class="hljs-number">0xbfc00000</span> <br></code></pre></td></tr></table></figure>
<p>修改内存：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">(gdb) set &#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&#125;<span class="hljs-number">0x8048a51</span>=<span class="hljs-number">0x0</span><br></code></pre></td></tr></table></figure>
<p>譬如对于第8节的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">(gdb) set &#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&#125;<span class="hljs-number">0x100000f2e</span>=<span class="hljs-number">0x0</span>       <br>(gdb) x/<span class="hljs-number">10</span>cb <span class="hljs-number">0x100000f2e</span><br><span class="hljs-number">0x100000f2e</span>:	<span class="hljs-number">0</span> <span class="hljs-string">&#x27;\0&#x27;</span>	<span class="hljs-number">0</span> <span class="hljs-string">&#x27;\0&#x27;</span>	<span class="hljs-number">0</span> <span class="hljs-string">&#x27;\0&#x27;</span>	<span class="hljs-number">0</span> <span class="hljs-string">&#x27;\0&#x27;</span>	<span class="hljs-number">111</span> <span class="hljs-string">&#x27;o&#x27;</span>	<span class="hljs-number">32</span> <span class="hljs-string">&#x27; &#x27;</span>	<span class="hljs-number">119</span> <span class="hljs-string">&#x27;w&#x27;</span>	<span class="hljs-number">111</span> <span class="hljs-string">&#x27;o&#x27;</span><br><span class="hljs-number">0x100000f36</span>:	<span class="hljs-number">114</span> <span class="hljs-string">&#x27;r&#x27;</span>	<span class="hljs-number">108</span> <span class="hljs-string">&#x27;l&#x27;</span><br>(gdb) p c<br>$<span class="hljs-number">10</span> = <span class="hljs-number">0x100000f2e</span> <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="jump命令">jump命令</h3>
一般来说，被调试程序会按照程序代码的运行顺序依次执行，但是GDB也提供了乱序执行的功能，也就是说，GDB可以修改程序的执行顺序，从而让程序随意跳跃。这个功能可以由GDB的jump命令：jump
<linespec>
来指定下一条语句的运行点。<linespec>可以是文件的行号，可以是file:line格式，也可以是+num这种偏移量格式，表示下一条运行语句从哪里开始。jump
<address>
这里的
<address>
<p>是代码行的内存地址。
注意，jump命令不会改变当前的程序栈中的内容，所以，如果使用jump从一个函数跳转到另一个函数，当跳转到的函数运行完返回，进行出栈操作时必然会发生错误，这可能导致意想不到的结果，所以最好只用jump在同一个函数中进行跳转。</p>
<h3 id="signal命令">signal命令</h3>
<p>使用singal命令，可以产生一个信号量给被调试的程序，如中断信号“Ctrl+C”。这非常方便于程序的调试，可以在程序运行的任意位置设置断点，并在该断点用GDB产生一个信号量，这种精确地在某处产生信号的方法非常有利于程序的调试。
signal命令的语法是：signal <signal>，<a
href="https://so.csdn.net/so/search?q=UNIX&amp;spm=1001.2101.3001.7020">UNIX</a>的系统信号量通常从1到15，所以<signal>取值也在这个范围。</p>
<h3 id="return命令">return命令</h3>
<p>如果在函数中设置了调试断点，在断点后还有语句没有执行完，这时候我们可以使用return命令强制函数忽略还没有执行的语句并返回。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">return</span><br><span class="hljs-keyword">return</span> &lt;expression&gt;<br></code></pre></td></tr></table></figure>
<p>上述return命令用于取消当前函数的执行，并立即返回，如果指定了<expression>，那么该表达式的值会被作为函数的返回值。</p>
<h3 id="call命令">call命令</h3>
<p>call命令用于强制调用某函数： call <expr>
表达式中可以一是函数，以此达到强制调用函数的目的，它会显示函数的返回值（如果函数返回值不是void）。
其实，前面介绍的print命令也可以完成强制调用函数的功能。</p>
<h3 id="info命令">info命令</h3>
<p>info命令可以在调试时用来查看寄存器、断点、观察点和信号等信息。要查看寄存器的值，可以使用如下命令：
info registers （查看除了浮点寄存器以外的寄存器）info all-registers
（查看所有寄存器，包括浮点寄存器）info registers &lt;regname ...&gt;
（查看所指定的寄存器） 要查看断点信息，可以使用如下命令：info break
列出当前所设置的所有观察点，使用如下命令：info watchpoints
查看有哪些信号正在被GDB检测，使用如下命令：info signals info handle
也可以使用info line命令来查看源代码在内存中的地址。info
threads可以看多线程。info
line后面可以跟行号、函数名、文件名:行号、文件名:函数名等多种形式，例如下面的命令会打印出所指定的源码在运行时的内存地址：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">info line tst.c:func<br></code></pre></td></tr></table></figure>
<h3 id="set-scheduler-locking-offonstep">set scheduler-locking
off|on|step</h3>
<p>off 不锁定任何线程，也就是所有线程都执行，这是默认值。 on
只有当前被调试程序会执行。 step
在单步的时候，除了next过一个函数的情况以外，只有当前线程会执行。</p>
<p>与多线程调试相关的命令还包括：</p>
<p>thread ID 切换当前调试的线程为指定ID的线程。</p>
<p>break thread_test.c:123 thread all 在所有线程中相应的行上设置断点</p>
<p>thread apply ID1 ID2 command
让一个或者多个线程执行GDB命令command。</p>
<p>thread apply all command 让所有被调试线程执行GDB命令command。</p>
<h3 id="disassemble">disassemble</h3>
<p>disassemble命令用于反汇编，它可被用来查看当前执行时的源代码的机器码，其实际上只是把目前内存中的指令dump出来。下面的示例用于查看函数func的汇编代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">(gdb) disassemble func<br>Dump of assembler code <span class="hljs-keyword">for</span> function func:<br><span class="hljs-number">0x8048450</span> &lt;func&gt;:       push   %ebp<br><span class="hljs-number">0x8048451</span> &lt;func+<span class="hljs-number">1</span>&gt;:     mov    %esp,%ebp<br><span class="hljs-number">0x8048453</span> &lt;func+<span class="hljs-number">3</span>&gt;:     sub    $<span class="hljs-number">0x18</span>,%esp<br><span class="hljs-number">0x8048456</span> &lt;func+<span class="hljs-number">6</span>&gt;:     movl   $<span class="hljs-number">0x0</span>,<span class="hljs-number">0xfffffffc</span>(%ebp)<br>...<br>End of assembler dump.<br></code></pre></td></tr></table></figure>
<h2 id="gcc">6.gcc</h2>
<h3 id="优化等级">优化等级</h3>
<p>gcc中指定优化级别的参数有：-O0、-O1、-O2、-O3、-Og、-Os、-Ofast。在编译时，如果没有指定优化参数，则默认为
-O0</p>
<p>-O1、-O2、-O3
中，随着数字变大，代码的优化程度也越高，不过这在某种意义上来说，也是以牺牲程序的可调试性为代价的。</p>
<p>-Og 是在 -O1
的基础上，去掉了那些影响调试的优化，所以如果最终是为了调试程序，可以使用这个参数。不过光有这个参数也是不行的，这个参数只是告诉编译器，编译后的代码不要影响调试，但调试信息的生成还是靠
-g 参数的。</p>
<p>参数 -Os 是在 -O2
的基础上，去掉了那些会导致最终可执行程序增大的优化，如果想要更小的可执行程序，可选择这个参数。</p>
<p>参数 -Ofast 是在 -O3
的基础上，添加了一些非常规优化，这些优化是通过打破一些国际标准（比如一些数学函数的实现标准）来实现的，所以一般不推荐使用该参数。</p>
<h3 id="编译链接命令">编译链接命令</h3>
<p>在使用 GCC 编译程序时，编译过程可以被细分为四个阶段：</p>
<p>1）<strong>预处理</strong>（ Pre-Processing
）阶段：主要对包含的头文件（＃include ）和宏定义（＃define,#ifdef …
）进行处理。可以使用“gcc -E” 让gcc 在预处理之后停止编译过程，生成 *.i
文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">gcc -E hello.c -o hello.i<br></code></pre></td></tr></table></figure>
<p>2）<strong>编译</strong>（ Compiling ）阶段：gcc
首先要检查代码的规范性，是否有语法错误等。以确定代码实际要做的工作，在检查无误后，gcc
把代码翻译成汇编语言。用户可以使用-S
选项进行查看，该选项只进行编译而不进行汇编，生成汇编代码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">gcc -S hello.i -o hello.s<br></code></pre></td></tr></table></figure>
<p>3） <strong>汇编</strong>（ Asse mbling ）阶段：生成目标代码 <em>.o
；有两种方式：使用 gcc 直接从源代码生成目标代码 gcc -c </em>.s -o <em>.o
以及使用汇编器从汇编代码生成目标代码 as </em>.s -o *.o</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">gcc -c hello.s -o hello.o<br>as hello.s -o hello.o<br></code></pre></td></tr></table></figure>
<p>也可以直接使用as <em>.s,
将<strong>执行汇编、链接过程生成可执行文件a.out</strong>,
可以像上面使用<strong>-o 选项</strong>指定输出文件的格式。
4）<strong>链接</strong>（ Linking
）阶段：生成可执行文件；可以生成的可执行文件格式有：
a.out/</em>/,当然可能还有其它格式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">gcc hello.o     生成可执行文件 a.out<br>gcc hello.o -o hello        生成可执行文件 hello<br></code></pre></td></tr></table></figure>
<p><strong>gcc 常用编译选项：</strong></p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-c</td>
<td>只编译不链接，生成目标文件<code>.o</code></td>
</tr>
<tr class="even">
<td>-S</td>
<td>只编译不汇编，生成汇编代码</td>
</tr>
<tr class="odd">
<td>-E</td>
<td>只进行预编译</td>
</tr>
<tr class="even">
<td>-g</td>
<td>在可执行程序中包含标准调试信息</td>
</tr>
<tr class="odd">
<td>-o file</td>
<td>指定file文件作为输出文件</td>
</tr>
<tr class="even">
<td>-v</td>
<td>打印出编译器内部编译各过程的命令行信息和编译器的版本</td>
</tr>
<tr class="odd">
<td>-Idir</td>
<td>在头文件的搜索路径列表中添加dir目录</td>
</tr>
<tr class="even">
<td>-static</td>
<td>进行静态编译，只链接静态库，禁止使用动态库</td>
</tr>
<tr class="odd">
<td>-shared</td>
<td>进行动态编译，尽可能地链接动态库，没有动态库时才会链接同名静态库</td>
</tr>
<tr class="even">
<td>-L dir</td>
<td>在库文件的搜索路径列表中添加dir目录</td>
</tr>
<tr class="odd">
<td>-lname</td>
<td>链接libname.a或libname.so的库文件</td>
</tr>
<tr class="even">
<td>-fPIC</td>
<td>生成使用相对地址的位置无关目标代码（Position Independent Code）</td>
</tr>
</tbody>
</table>
<p>gcc
在链接时优先使用动态链接库，只有当动态链接库不存在时才考虑使用静态链接库，如果需要的话可以在编译时加上<strong>-static</strong>
选项，强制使用静态链接库。</p>
<h2 id="重定向">7.重定向</h2>
<h3 id="linux-21">Linux 2&gt;&amp;1</h3>
<p>2&gt;&amp;1的意思是将标准错误(2)也定向到标准输出(1)的输出文件中。</p>
<p>Linux
中三种标准输入输出，分别是STDIN，STDOUT，STDERR，对应的数字是0，1，2。</p>
<p>STDIN就是标准输入，默认从键盘读取信息；</p>
<p>STDOUT是标准输出，默认将输出结果输出至终端，也就是显示器之类的东西；</p>
<p>STDERR是标准的错误信息，默认也会显示在终端上。</p>
<p>由于STDOUT与STDERR都会默认显示在终端上，为了区分二者的信息，就有了编号的0，1，2的定义，用1表示STDOUT，2表示STDERR。</p>
<h3 id="从commanddevnull说起">从command&gt;/dev/null说起</h3>
<p>其实这条命令是一个缩写版，对于一个重定向命令，肯定是<code>a &gt; b</code>这种形式，那么<code>command &gt; /dev/null</code>难道是command充当a的角色，/dev/null充当b的角色。这样看起来比较合理，其实一条命令肯定是充当不了a，肯定是command执行产生的输出来充当a，其实就是标准输出stdout。所以<code>command &gt; /dev/null</code>相当于执行了<code>command 1 &gt; /dev/null</code>。执行command产生了标准输出stdout(用1表示)，重定向到/dev/null的设备文件中。</p>
<h3 id="说说21">说说2&gt;&amp;1</h3>
<p>通过上面<code>command &gt; /dev/null</code>等价于<code>command 1 &gt; /dev/null</code>,那么对于<code>2&gt;&amp;1</code>也就好理解了，2就是标准错误，1是标准输出，那么这条命令不就是相当于把标准错误重定向到标准输出么。等等是&amp;1而不是1，这里&amp;是什么？这里<code>&amp;</code>相当于<strong>等效于标准输出</strong>。这里有点不好理解，先看下面。</p>
<h3 id="commanda-2a-与-commanda-21的区别">command&gt;a 2&gt;a 与
command&gt;a 2&gt;&amp;1的区别</h3>
<p>通过上面的分析，对于<code>command&gt;a 2&gt;&amp;1</code>这条命令，等价于<code>command 1&gt;a 2&gt;&amp;1</code>可以理解为执行command产生的标准输入重定向到文件a中，标准错误也重定向到文件a中。那么是否就说<code>command 1&gt;a 2&gt;&amp;1</code>等价于<code>command 1&gt;a 2&gt;a</code>呢。其实不是，<code>command 1&gt;a 2&gt;&amp;1</code>与<code>command 1&gt;a 2&gt;a</code>还是有区别的，区别就在于前者只打开一次文件a，后者会打开文件两次，并导致stdout被stderr覆盖。<code>&amp;1</code>的含义就可以理解为用标准输出的引用，引用的就是重定向标准输出产生打开的a。从IO效率上来讲，<code>command 1&gt;a 2&gt;&amp;1</code>比<code>command 1&gt;a 2&gt;a</code>的效率更高</p>
<h3 id="再思考一下">再思考一下</h3>
<p>为什么2&gt;&amp;1 要放在后边呢？
我的理解是因为2（也就是错误输出）要重定向到&amp;1，也就是标准输出的引用中，也就是标准输出打开的文件中，所以需要现在前面打开1的输出文件。</p>
<h3 id="nohup及nohup.out">nohup及nohup.out</h3>
<p>如果使用nohup执行命令，配合&amp;的使用，则可以不挂断的将命令执行到后台，如果没有指定重定向文件，则输出将附加到当前目录的
nohup.out 文件中。如果当前目录的 nohup.out 文件不可写，输出重定向到
$HOME/nohup.out 文件中，实例如下：</p>
<p>nohup test.pl 2&gt;&amp;1 &amp;</p>
<p>在shell脚本中，默认情况下，总是有三个文件处于打开状态，标准输入(键盘输入)、标准输出（输出到屏幕）、标准错误（也是输出到屏幕），它们分别对应的<strong>文件描述符</strong>是0，1，2
。</p>
<p><strong>&gt; 默认为标准输出重定向，与 1&gt; 相同 2&gt;&amp;1</strong>
意思是把 标准错误输出 重定向到 标准输出.</p>
<p><strong>&amp;&gt;file</strong> 意思是把<strong>标准输出</strong> 和
<strong>标准错误输出</strong> 都重定向到文件file中</p>
<p><strong>/dev/null是一个文件，这个文件比较特殊，所有传给它的东西它都丢弃掉</strong></p>
<p><strong>举例说明:</strong></p>
<p>当前目录只有一个文件 a.txt. [root@redhat box]# ls a.txt [root@redhat
box]# ls a.txt b.txt ls: b.txt: No such file or directory
由于没有b.txt这个文件, 于是返回错误值, 这就是所谓的2输出 a.txt
而这个就是所谓的1输出</p>
<p><strong>再接着看:</strong></p>
<p>[root@redhat box]# ls a.txt b.txt 1&gt;<strong>file.out</strong>
2&gt;<strong>file.err</strong> 执行后,没有任何返回值. 原因是, 返回值都<a
href="https://so.csdn.net/so/search?q=重定向&amp;spm=1001.2101.3001.7020">重定向</a>到相应的文件中了,而不再前端显示
[root@redhat box]# cat file.out a.txt [root@redhat box]# cat file.err
ls: b.txt: No such file or directory 一般来说, "1&gt;" 通常可以省略成
"&gt;". 即可以把如上命令写成: ls a.txt b.txt &gt;file.out 2&gt;file.err
有了这些认识才能理解 "1&gt;&amp;2" 和 "2&gt;&amp;1". <strong>1&gt;&amp;2
正确返回值传递给2输出通道 &amp;2表示2输出通道</strong> 如果此处错写成
1&gt;2, 就表示把1输出重定向到文件2中. <strong>2&gt;&amp;1
错误返回值传递给1输出通道, 同样&amp;1表示1输出通道.</strong> 举个例子.
[root@redhat box]# <strong>ls a.txt b.txt 1&gt;file.out
2&gt;&amp;1</strong> [root@redhat box]# cat file.out ls: b.txt: No such
file or directory a.txt 现在,
正确的输出和错误的输出都定向到了file.out这个文件中, 而不显示在前端.
补充下, 输出不只1和2, 还有其他的类型, 这两种只是最常用和最基本的.</p>
<p>例如： rm -f $(find / -name core) &amp;&gt;
/dev/null，<strong>/dev/null是一个文件，这个文件比较特殊，所有传给它的东西它都丢弃掉。</strong></p>
<p>例如： 注意，为了方便理解，必须设置一个环境使得执行grep da
<em>命令会有正常输出和错误输出，然后分别使用下面的命令生成三个文件：
grep da </em> &gt; greplog1 grep da * &gt; greplog2 1&gt;&amp;2<br />
grep da * &gt; greplog3 2&gt;&amp;1 //grep da * 2&gt; greplog4
1&gt;&amp;2 结果一样 #查看greplog1会发现里面只有正常输出内容
#查看greplog2会发现里面什么都没有#查看greplog3会发现里面既有正常输出内容又有错误输出内容</p>
<h2 id="grep命令">8. grep命令</h2>
<p><code>grep</code>命令是打印匹配文本行，其全称为 Global Search Regular
Expression and Print out the line；基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&lt;code class=<span class="hljs-string">&quot;hljs css has-numbering&quot;</span>&gt;&lt;span class=<span class="hljs-string">&quot;hljs-tag&quot;</span>&gt;grep&lt;/span&gt; &lt;span class=<span class="hljs-string">&quot;hljs-attr_selector&quot;</span>&gt;[OPTIONS]&lt;/span&gt; &lt;span class=<span class="hljs-string">&quot;hljs-tag&quot;</span>&gt;PATTERN&lt;/span&gt; &lt;span class=<span class="hljs-string">&quot;hljs-attr_selector&quot;</span>&gt;[FILE...]&lt;/span&gt;<br>&lt;span class=<span class="hljs-string">&quot;hljs-tag&quot;</span>&gt;grep&lt;/span&gt; &lt;span class=<span class="hljs-string">&quot;hljs-attr_selector&quot;</span>&gt;[OPTIONS]&lt;/span&gt; &lt;span class=<span class="hljs-string">&quot;hljs-attr_selector&quot;</span>&gt;[-e PATTERN | -f FILE]&lt;/span&gt; &lt;span class=<span class="hljs-string">&quot;hljs-attr_selector&quot;</span>&gt;[FILE...]&lt;/span&gt;<br>&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<p>其中，<code>OPTIONS</code>表示选项；<code>PATTERN</code>表示匹配模式，匹配模式可以是字符串、变量、正则表达式，若匹配模式中含义空格，则需要使用双引号将匹配模式引起来；<code>FILE</code>表示一系列文件；<code>grep</code>命令从文件中搜索满足指定匹配模式的文本行，并打印出来。</p>
<p>正则表达式的分类为：</p>
<ul>
<li>基本正则表达式（Basic Regular Expression）：Basic RegEx，简称
<strong>BRE</strong></li>
<li>扩展正则表达式（Extended Regular Expression）：Extended RegEx，简称
<strong>ERE</strong></li>
<li>Perl 正则表达式（Perl Regular Expression）：Perl RegEx，简称
<strong>PCRE</strong>；</li>
</ul>
<p><code>grep</code>命令根据不同的参数支持不同的正则表达式：</p>
<ul>
<li><code>grep</code>命令后不跟任何参数（默认），则表示要使用“BRE”；</li>
<li><code>grep</code>命令后跟<code>-E</code>参数，则表示要使用“ERE”；</li>
<li><code>grep</code>命令后跟<code>-P</code>参数，则表示要使用“PCRE”；</li>
</ul>
<p>常用<code>OPTIONS</code>选项如下表所示：</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-E</td>
<td>指定 PATTERN 匹配模式为扩展正则表达式</td>
</tr>
<tr class="even">
<td>-F</td>
<td>指定 PATTERN 匹配模式为固定的字符串</td>
</tr>
<tr class="odd">
<td>-G</td>
<td>指定 PATTERN 匹配模式为基本正则表达式</td>
</tr>
<tr class="even">
<td>-P</td>
<td>指定 PATTERN 匹配模式为 Perl 正则表达式</td>
</tr>
<tr class="odd">
<td>-R</td>
<td>查找所有文件包含子目录</td>
</tr>
<tr class="even">
<td>-e PATTERN</td>
<td>指定 PATTERN 为一个或多个搜索模式</td>
</tr>
<tr class="odd">
<td>-f FILE</td>
<td>指定包含搜索模式的 FILE</td>
</tr>
<tr class="even">
<td><strong>-i</strong></td>
<td>匹配是忽略字母大小写</td>
</tr>
<tr class="odd">
<td><strong>-v</strong></td>
<td>显示所有与匹配模式不匹配的文本行（如grep -v "grep"或grep -v grep
意思是不显示包含grep符串的那一行）</td>
</tr>
<tr class="even">
<td>-w</td>
<td>执行单词搜索</td>
</tr>
<tr class="odd">
<td>-x</td>
<td>显示与指定模式精确匹配而不含其他字符的文本行</td>
</tr>
<tr class="even">
<td>-y</td>
<td>与选项 -i 相同功能</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
<tr class="even">
<td>-c</td>
<td>只打印匹配的文本行的行数，不显示匹配内容</td>
</tr>
<tr class="odd">
<td>-l</td>
<td>只显示匹配文本行的文件名，不显示匹配内容</td>
</tr>
<tr class="even">
<td><strong>-n</strong></td>
<td>列出所有匹配的文本行，并显示行号</td>
</tr>
<tr class="odd">
<td><strong>-r</strong></td>
<td>递归搜索目录(当前目录及其各级子目录)</td>
</tr>
<tr class="even">
<td>-s</td>
<td>不显示错误信息</td>
</tr>
</tbody>
</table>
<p>在当前目录下
查找"hello,world!"字符串<code>grep -rn "hello,world!" *</code> * :
表示当前目录所有文件，也可以是某个文件名</p>
<p>命令行参数：</p>
<p>grep -i pattern files ：不区分大小写地搜索。默认情况区分大小写，</p>
<p>grep -l pattern files ：只列出匹配的文件名，</p>
<p>grep -L pattern files ：列出不匹配的文件名，</p>
<p>grep -w pattern files
：只匹配整个单词，而不是字符串的一部分（如匹配‘magic’，而不是‘magical’），</p>
<p>grep -C number pattern files ：匹配的上下文分别显示[number]行，</p>
<p>grep pattern1 | pattern2 files ：显示匹配 pattern1 或 pattern2
的行，</p>
<p>grep pattern1 files | grep pattern2 ：显示既匹配 pattern1 又匹配
pattern2 的行。</p>
<p>&lt; 和 &gt; 分别标注单词的开始与结尾。</p>
<p>grep man * 会匹配 ‘Batman’、‘manic’、‘man’等，</p>
<p>grep '&lt;man' * 匹配‘manic’和‘man’，但不是‘Batman’，</p>
<p>grep '&lt;man&gt;'
只匹配‘man’，而不是‘Batman’或‘manic’等其他的字符串。</p>
<p>'^'：指匹配的字符串在行首，</p>
<p>'$'：指匹配的字符串在行尾，</p>
<h2 id="流编辑器-sed">9. 流编辑器 sed</h2>
<h3 id="sed命令">sed命令</h3>
<p>元字符集：<br />
<code>^</code>锚定行的开始 如：/^sed/匹配所有以sed开头的行。</p>
<p><code>$</code>锚定行的结束 如：/sed$/匹配所有以sed结尾的行。</p>
<p><code>.</code>匹配一个非换行符的字符
如：/s.d/匹配s后接一个任意字符，然后是d。</p>
<p><code>*</code>匹配零或多个字符
如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。</p>
<p><code>[]</code>匹配一个指定范围内的字符，如/[Ss]ed/匹配sed和Sed。</p>
<p><code>[^]</code>匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。</p>
<p>保存匹配的字符，如s/able/\1rs，loveable被替换成lovers。</p>
<p><code>&amp;</code>保存搜索字符用来替换其他字符，如s/love/<strong>&amp;</strong>/，love这成<strong>love</strong>。</p>
<p><code>\&lt;</code>锚定单词的开始，如:/&lt;love/匹配包含以love开头的单词的行。</p>
<p><code>\&gt;</code>锚定单词的结束，如/love&gt;/匹配包含以love结尾的单词的行。</p>
<p><code>x\&#123;m\&#125;</code>重复字符x，m次，如：/0{5}/匹配包含5个o的行。</p>
<p><code>x\&#123;m,\&#125;</code>重复字符x,至少m次，如：/o{5,}/匹配至少有5个o的行。</p>
<p><code>x\&#123;m,n\&#125;</code>重复字符x，至少m次，不多于n次，如：/o{5,10}/匹配5--10个o的行。</p>
<p>​ 先看几个实例：</p>
<p>删除：d命令</p>
<ul>
<li>$ sed '2d' example-----删除example文件的第二行。</li>
<li>$ sed '2,$d' example-----删除example文件的第二行到末尾所有行。</li>
<li>$ sed '$d' example-----删除example文件的最后一行。</li>
<li>$ sed '/test/'d example-----删除example文件所有包含test的行。</li>
</ul>
<p>替换：s命令</p>
<ul>
<li><p>$ sed 's/test/mytest/g'
example-----在整行范围内把test替换为mytest。如果没有g标记，则只有每行第一个匹配的test被替换成mytest。</p></li>
<li><p>$ sed -n 's/^test/mytest/p'
example-----(-n)选项和p标志一起使用表示只打印那些发生替换的行。也就是说，如果某一行开头的test被替换成mytest，就打印它。</p></li>
<li><p>$ sed 's/^192.168.0.1/&amp;localhost/'
example-----&amp;符号表示替换换字符串中被找到的部份。所有以192.168.0.1开头的行都会被替换成它自已加localhost，变成192.168.0.1localhost。</p></li>
<li><p>$ sed -n 's/able/\1rs/p'
example-----love被标记为1，所有loveable会被替换成lovers，而且替换的行会被打印出来。</p></li>
<li><p>$ sed 's#10#100#g'
example-----不论什么字符，紧跟着s命令的都被认为是新的分隔符，所以，“#”在这里是分隔符，代替了默认的“/”分隔符。表示把所有10替换成100。</p>
<p>选定行的范围：逗号</p></li>
<li><p>$ sed -n '/test/,/check/p'
example-----所有在模板test和check所确定的范围内的行都被打印。</p></li>
<li><p>$ sed -n '5,/^test/p'
example-----打印从第五行开始到第一个包含以test开始的行之间的所有行。</p></li>
<li><p>$ sed '/test/,/check/s/$/sed test/'
example-----对于模板test和west之间的行，每行的末尾用字符串sed
test替换。</p></li>
</ul>
<p>多点编辑：e命令</p>
<ul>
<li>$ sed -e '1,5d' -e 's/test/check/'
example-----(-e)选项允许在同一行里执行多条命令。如例子所示，第一条命令删除1至5行，第二条命令用check替换test。命令的执行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。</li>
<li>$ sed --expression='s/test/check/' --expression='/love/d'
example-----一个比-e更好的命令是--expression。它能给sed表达式赋值。</li>
</ul>
<p>从文件读入：r命令</p>
<ul>
<li>$ sed '/test/r file'
example-----file里的内容被读进来，显示在与test匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面。</li>
</ul>
<p>写入文件：w命令</p>
<ul>
<li>$ sed -n '/test/w file'
example-----在example中所有包含test的行都被写入file里。</li>
</ul>
<p>追加命令：a命令</p>
<ul>
<li>$ sed '/^test/a\---&gt;this is a example' example&lt;-----'this is a
example'被追加到以test开头的行后面，sed要求命令a后面有一个反斜杠。</li>
</ul>
<p>插入：i命令</p>
<p>$ sed '/test/i\</p>
<p>new line</p>
<p>-------------------------' example</p>
<p>如果test被匹配，则把反斜杠后面的文本插入到匹配行的前面。</p>
<p>下一个：n命令</p>
<ul>
<li>$ sed '/test/{ n; s/aa/bb/; }'
example-----如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb，并打印该行，然后继续。</li>
</ul>
<p>变形：y命令</p>
<ul>
<li>$ sed '1,10y/abcde/ABCDE/'
example-----把1--10行内所有abcde转变为大写，注意，正则表达式元字符不能使用这个命令。</li>
</ul>
<p>退出：q命令</p>
<ul>
<li>$ sed '10q' example-----打印完第10行后，退出sed。</li>
</ul>
<p>保持和获取：h命令和G命令</p>
<ul>
<li>$ sed -e '/test/h' -e '$G
example-----在sed处理文件的时候，每一行都被保存在一个叫模式空间的临时缓冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。在这个例子里，匹配test的行被找到后，将存入模式空间，h命令将其复制并存入一个称为保持缓存区的特殊缓冲区内。第二条语句的意思是，当到达最后一行后，G命令取出保持缓冲区的行，然后把它放回模式空间中，且追加到现在已经存在于模式空间中的行的末尾。在这个例子中就是追加到最后一行。简单来说，任何包含test的行都被复制并追加到该文件的末尾。</li>
</ul>
<p>保持和互换：h命令和x命令</p>
<ul>
<li>$ sed -e '/test/h' -e '/check/x' example
-----互换模式空间和保持缓冲区的内容。也就是把包含test与check的行互换。</li>
</ul>
<p><code>sed</code>命令从文件或者标准输入中一次读取一行数据，将该行数据复制到缓冲区，然后读取命令行或脚本的编辑子命令，对缓冲区中的文本行进行编辑。重复此工作，直到所有文本行都处理完毕。</p>
<p><code>sed</code>命令编辑的是文件是原始文件在缓冲区中的副本，并不影响原始文件，但是可以把编辑结果通过输出重定向保存起来。</p>
<p><code>sed</code>命令的基本语法如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&lt;code class=<span class="hljs-string">&quot;hljs r has-numbering&quot;</span>&gt;sed [OPTION]&lt;span class=<span class="hljs-string">&quot;hljs-keyword&quot;</span>&gt;...&lt;/span&gt; &#123;script&#125; [input-file]&lt;span class=<span class="hljs-string">&quot;hljs-keyword&quot;</span>&gt;...&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<p>常用选项<code>OPTION</code>如下表所示：</p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>-n</strong></td>
<td>取消默认输出</td>
</tr>
<tr class="even">
<td>-e script</td>
<td>允许执行多个脚本</td>
</tr>
<tr class="odd">
<td><strong>-f script-file</strong></td>
<td><strong>从脚本文件中读取命令</strong></td>
</tr>
<tr class="even">
<td><strong>-i</strong></td>
<td><strong>直接修改原始文件</strong></td>
</tr>
<tr class="odd">
<td>-l N</td>
<td>指定行长度为 N</td>
</tr>
<tr class="even">
<td>-r</td>
<td>在脚本中使用扩展正则表达式</td>
</tr>
<tr class="odd">
<td>-s</td>
<td>把文件作为单独文件</td>
</tr>
<tr class="even">
<td>-u</td>
<td>最低限度的缓存输入与输出</td>
</tr>
</tbody>
</table>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">test2.sh<br><span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;code&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;python&quot;</span>&gt;</span>  asdafsadfasdfsa<br>  badfasdfas<br>  bdsdfsdfsdf<br>  csdfasdfasf<br></code></pre></td></tr></table></figure>
<p>test.sh #!/bin/bash</p>
<p>sed -ie '/^b/ s/b/bbbbbb/g' test2.sh</p>
<p>执行后test2.sh的结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">asdafsadfasdfsa<br>bbbbadfasdfas<br>bbbbdsdfsdfsdf<br>csdfasdfasf<br></code></pre></td></tr></table></figure>
<p><strong>如果不带-i，那么test2.sh中的内容不会发生变化，
发生变化的只是缓冲区中的内容。</strong></p>
<h3 id="文本行定位">文本行定位</h3>
<p><code>sed</code>命令提供了两种方式来实现文本行的定位：<strong>行号定位</strong>、<strong>正则表达式定位</strong></p>
<h3 id="行号定位"><strong>行号定位</strong></h3>
<ul>
<li>定位某个特定的行<strong><code>n</code></strong>：<code>n</code>是一个整数，表示定位到文本的第<code>n</code>行；</li>
<li>定位某段连续的行<strong><code>n,m</code></strong>：<code>n</code>和<code>m</code>都是整数，表示定位到起始行为<code>n</code>，终止行为<code>m</code>的文本行；</li>
<li>指定起始行和步长<strong><code>start~step</code></strong>：起始行为<code>start</code>，步长为<code>step</code>；</li>
<li>第一行<strong><code>1</code></strong>和最后一行<strong><code>$</code></strong>：<code>1</code>表示第一行，<code>$</code>表示最后一行；</li>
<li>指定某行后面的几行<strong><code>n,+x</code></strong>：表示从第<code>n</code>行开始到后面的<code>x</code>行；</li>
</ul>
<h3 id="正则表达式定位"><strong>正则表达式定位</strong></h3>
<p><code>sed</code>命令使用正则表达式定位文本行的语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs vala has-numbering&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;#regexp 表示正则表达式&lt;/span&gt;<br>/regexp/<br><br>如：/^b/ 表示行首为b<br>   /1,3/ 表示第1～3行<br>&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<h3 id="sed命令的常用操作">sed命令的常用操作</h3>
<p><code>sed</code>命令的常用编辑命令有：打印、删除、增加、替换；其基本语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs css has-numbering&quot;&gt;&lt;span class=&quot;hljs-attr_selector&quot;&gt;[address1[,address2]&lt;/span&gt;] &lt;span class=&quot;hljs-tag&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;hljs-attr_selector&quot;&gt;[argument]&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<p>其中<code>address</code>称为位置参数，即上面的行定位；<code>command</code>是<code>sed</code>所提供的子命令，用来实现编辑操作；<code>argument</code>表示子命令的选项参数；</p>
<h4 id="打印文本">1) 打印文本</h4>
<p><code>sed</code>命令中可通过位置参数和<strong><code>p</code></strong>命令打印所需要的文本行，其语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs css has-numbering&quot;&gt;&lt;span class=&quot;hljs-attr_selector&quot;&gt;[address1[,address2]&lt;/span&gt;] &lt;span class=&quot;hljs-tag&quot;&gt;p&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;&lt;span class=&quot;hljs-shebang&quot;&gt;#! /bin/bash<br>&lt;/span&gt;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#输出第1~4行文本，注意1,3p之间是单引号&lt;/span&gt;<br>sed -n &lt;span class=&quot;hljs-string&quot;&gt;&#x27;1,3p&#x27;&lt;/span&gt; test.txt<br><br>&lt;span class=&quot;hljs-comment&quot;&gt;#输出以Lin开头的文本行&lt;/span&gt;<br>result=`sed -n &lt;span class=&quot;hljs-string&quot;&gt;&#x27;/^Lin/ p&#x27;&lt;/span&gt; test.txt`<br>&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$result&lt;/span&gt;&quot;&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<h4 id="替换文本">2) 替换文本</h4>
<p><code>sed</code>命令中可通过位置参数和<code>s</code>子命令替换文本行，其语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs coffeescript has-numbering&quot;&gt;[address1[,address2]] s&lt;span class=&quot;hljs-regexp&quot;&gt;/pattern/replacemen/&lt;/span&gt;[flag]&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<p><code>flag</code>为替换标志，不同值会影响<code>s</code>子命令的行为；<code>flag</code>常用取值如下表所示：</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="header">
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>g</strong></td>
<td>全局匹配，会替换文本行所有符合规则的字符串</td>
</tr>
<tr class="even">
<td>p</td>
<td>替换第一个符合规则的字符串，并将缓冲区输出到标准输出</td>
</tr>
<tr class="odd">
<td>w</td>
<td>替换第一个符合规则的字符串，并将受影响的行输出到磁盘文件中</td>
</tr>
<tr class="even">
<td>十进制数n</td>
<td>替换文本行中第n个符合规则的字符串</td>
</tr>
<tr class="odd">
<td>空</td>
<td>若不指定flag值，替换文本行中第一个符合规则的字符串</td>
</tr>
</tbody>
</table>
<h4 id="删除文本">3) 删除文本</h4>
<p><code>sed</code>命令中可通过位置参数和<code>d</code>子命令删除文本行，其语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs css has-numbering&quot;&gt;&lt;span class=&quot;hljs-attr_selector&quot;&gt;[address1[,address2]&lt;/span&gt;] &lt;span class=&quot;hljs-tag&quot;&gt;d&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<h4 id="增加文本">4) 增加文本</h4>
<p><strong>追加文本</strong>
<code>sed</code>命令中可通过位置参数和<code>a</code>子命令追加文本行，其语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs vala has-numbering&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;#将string插入到address1位置后面&lt;/span&gt;<br>[address1] a &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt; &lt;/code&gt;<br></code></pre></td></tr></table></figure>
<h4 id="插入文本"><strong>5) 插入文本</strong></h4>
<p><code>sed</code>命令中可通过位置参数和<code>i</code>子命令插入文本行，其语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs vala has-numbering&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;#将string插入到address1位置前面&lt;/span&gt;<br>[address1] i &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<h4 id="组合命令">6) 组合命令</h4>
<p><code>sed</code>命令支持将多个子命令组合在一起使用；具体方式如下所示：</p>
<ul>
<li>使用<code>-e</code>选项：<code>-e</code>选项可以将多个子命令组合在一起使用；例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;&lt;span class=&quot;hljs-shebang&quot;&gt;#! /bin/bash<br>&lt;/span&gt;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#将全部小写字母 e 替换成大写字母 E，并打印第 1 行到第 3 行文本行&lt;/span&gt;<br>result=`sed -n &lt;span class=&quot;hljs-operator&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#x27;s/e/E/g&#x27;&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#x27;1,3 p&#x27;&lt;/span&gt; test.txt`<br>&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$result&lt;/span&gt;&quot;&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<ul>
<li>使用分号<code>;</code>执行多个子命令： 其语法格式：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;sed &lt;span class=&quot;hljs-operator&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#x27;command1; command2...&#x27;&lt;/span&gt; filename&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;&lt;span class=&quot;hljs-shebang&quot;&gt;#! /bin/bash<br>&lt;/span&gt;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#将全部小写字母 e 替换成大写字母 E，并打印第 1 行到第 3 行文本行&lt;/span&gt;<br>result=`sed -n &lt;span class=&quot;hljs-operator&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#x27;s/e/E/g; 1,3 p&#x27;&lt;/span&gt; test.txt`<br>&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$result&lt;/span&gt;&quot;&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<ul>
<li>对同一个地址使用多个子命令： 其语法格式：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs r has-numbering&quot;&gt;address&#123;<br>    command1<br>    command2<br>    command3<br>    &lt;span class=&quot;hljs-keyword&quot;&gt;...&lt;/span&gt;<br>&#125;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#或&lt;/span&gt;<br>[address] &#123; command1;command2;command3;&lt;span class=&quot;hljs-keyword&quot;&gt;...&lt;/span&gt;&#125;&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<h4 id="sed脚本文件">7)sed脚本文件</h4>
<p>可以将多个子命令写成后缀名为<code>.sed</code>的<code>sed</code>脚本文件，<code>sed</code>脚本文件内容只需将各个子命令依次列出来，不必使用引号，若将多个子命令写在同一行，则不同子命令之间需使用分号隔开。调用<code>sed</code>脚本文件的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;sed &lt;span class=&quot;hljs-operator&quot;&gt;-f&lt;/span&gt; script&lt;/code&gt;<br>&lt;pre&gt;<br><br></code></pre></td></tr></table></figure>
<h2 id="awk命令">10. awk命令</h2>
<h3 id="awk命令的基本语法">awk命令的基本语法</h3>
<p><code>awk</code>命令是一个文本处理工具，其基本语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs mathematica has-numbering&quot;&gt;awk pattern &lt;span class=&quot;hljs-list&quot;&gt;&#123; actions &#125;&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<p>其中，<code>pattern</code>表示匹配模式，<code>actions</code>表示要执行的操作；即对符合<code>pattern</code>匹配模式的文本行执行<code>actions</code>操作；若省略<code>pattern</code>匹配模式，则表示对所有文本行执行<code>actions</code>操作；若省略<code>pattern</code>
匹配模式，则把匹配成功的文本行打印输出；但是不能同时省略<code>pattern</code>和<code>actions</code>。</p>
<p><code>pattern</code>匹配模式可以是以下其中一种：</p>
<ul>
<li>正则表达式；</li>
<li>关系表达式；</li>
<li>模式<code>1</code>，模式<code>2</code>：指定一行的范围；</li>
<li><code>BEGIN</code>：指定在第一行文本被处理之前所发生的操作；</li>
<li><code>END</code>：指定在最后一行文本被读取之后发送的操作；</li>
</ul>
<p><code>actions</code>命令由一个或多个命令、函数或者表达式组成，他们之间由换行符或分号隔开，并位于大括号内，一般有以下四种情况：</p>
<ul>
<li>变量或数组赋值；</li>
<li>输出命令，例如<code>printf</code>或<code>print</code>；</li>
<li>内置函数；</li>
<li>流控制语句，例如<code>if</code>、<code>while</code>或<code>for</code>语句；</li>
</ul>
<p><code>awk</code>命令的执行方式：</p>
<ul>
<li>通过命令行执行：其语法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;awk &lt;span class=&quot;hljs-string&quot;&gt;&#x27;awk程序语句&#x27;&lt;/span&gt; 数据文件&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<ul>
<li>执行 <code>awk</code>脚本：其语法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;#注意：awk脚本文件是后缀名为.awk的文件&lt;/span&gt;<br>awk &lt;span class=&quot;hljs-operator&quot;&gt;-f&lt;/span&gt; awk脚本文件 数据文件&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<ul>
<li>可执行脚本文件：即在
<code>shell</code>文件中指定解析器为<code>#! /bin/awk -f</code></li>
</ul>
<h3 id="awk命令的匹配模式">awk命令的匹配模式</h3>
<p>在<code>awk</code>命令的匹配模式主要包括：关系表达式、正则表达式、混合模式、区间模式、<code>BEGIN</code>模式、<code>END</code>模式等。</p>
<h4 id="关系表达式"><strong>1) 关系表达式</strong></h4>
<p><code>awk</code>命令中的关系运算符如下表所示：</p>
<table>
<thead>
<tr class="header">
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&gt;</td>
<td>大于</td>
</tr>
<tr class="even">
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr class="odd">
<td>&lt;</td>
<td>小于</td>
</tr>
<tr class="even">
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr class="odd">
<td>==</td>
<td>等于</td>
</tr>
<tr class="even">
<td>!=</td>
<td>不等于</td>
</tr>
<tr class="odd">
<td>~</td>
<td>匹配运算：例如<code>$1~/^A</code>表示匹配第一个字段以字符<code>A</code>开头的记录</td>
</tr>
<tr class="even">
<td>!~</td>
<td>不匹配运算</td>
</tr>
</tbody>
</table>
<h4 id="正则表达式"><strong>2) 正则表达式</strong></h4>
<p><code>awk</code>支持以正则表达式为匹配模式，其基本语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs vala has-numbering&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;#regexp 表示正则表达式&lt;/span&gt;<br>/regexp/&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<p>例如：输出以字符u开头的文本行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;&lt;span class=&quot;hljs-shebang&quot;&gt;#! /bin/bash&lt;/span&gt;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#filename:test.sh&lt;/span&gt;<br><br>result=`awk &lt;span class=&quot;hljs-string&quot;&gt;&#x27;/^u/ &#123;print&#125;&#x27;&lt;/span&gt; shell.md`<br><br>&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$result&lt;/span&gt;&quot;&lt;/span&gt;<br><br>&lt;span class=&quot;hljs-comment&quot;&gt;#输出结果：&lt;/span&gt;<br>$ sh test.sh <br>&lt;span class=&quot;hljs-built_in&quot;&gt;unset&lt;/span&gt; variable_name<br>&lt;span class=&quot;hljs-built_in&quot;&gt;unset&lt;/span&gt; var<br>until<br>until<br>&lt;span class=&quot;hljs-built_in&quot;&gt;unset&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;-f&lt;/span&gt; 函数名&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<h4 id="混合模式"><strong>3) 混合模式</strong></h4>
<p>在<code>awk</code>命令的匹配模式中，可以通过逻辑运算符使用多个表达式组成命令；基本逻辑运算符如下表所示：</p>
<table>
<thead>
<tr class="header">
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&amp;&amp;</td>
<td>逻辑与</td>
</tr>
<tr class="even">
<td>||</td>
<td>逻辑或</td>
</tr>
<tr class="odd">
<td>!</td>
<td>逻辑非</td>
</tr>
</tbody>
</table>
<h4 id="区间模式"><strong>4) 区间模式</strong></h4>
<p><code>awk</code>命令支持区间模式，其语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs  has-numbering&quot;&gt;pattern1, pattern2&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<p>例如：第一个匹配模式是：以字符串<code>one</code>开头的文本行；第二个匹配模式是：第<code>3</code>字段等于<code>14</code>的文本行；所有符合这两个匹配模式之间的文本行都会被输出；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;&lt;span class=&quot;hljs-shebang&quot;&gt;#!/bin/bash&lt;/span&gt;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#filename:test.sh&lt;/span&gt;<br><br>result=`awk &lt;span class=&quot;hljs-string&quot;&gt;&#x27;/^one/ , $3==14 &#123;print&#125;&#x27;&lt;/span&gt; test.txt`<br><br>&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$result&lt;/span&gt;&quot;&lt;/span&gt;<br><br>&lt;span class=&quot;hljs-comment&quot;&gt;#执行结果：&lt;/span&gt;<br>$ sh test.sh <br>one     &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;<br>two     &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;25&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;<br>three   &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;31&lt;/span&gt;<br>four    &lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;26&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;35&lt;/span&gt;<br>five    &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;40&lt;/span&gt;<br>&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<h4 id="begin模式"><strong>5) BEGIN模式</strong></h4>
<p><code>BEGIN</code>模式是<code>awk</code>命令一种特殊的内置模式，在<code>awk</code>读取数据之前对执行的操作；</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs livecodeserver has-numbering&quot;&gt;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#! /usr/bin/awk -f&lt;/span&gt;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#filename:test.sh&lt;/span&gt;<br><br>BEGIN &#123; print &lt;span class=&quot;hljs-string&quot;&gt;&quot;Beging operator.&quot;&lt;/span&gt; &#125;<br>/^&lt;span class=&quot;hljs-constant&quot;&gt;one&lt;/span&gt;/ , $&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;==&lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt; &#123;print&#125;<br><br>&lt;span class=&quot;hljs-comment&quot;&gt;#执行结果：&lt;/span&gt;<br>$ ./test.sh test.txt<br>Beging operator.<br>&lt;span class=&quot;hljs-constant&quot;&gt;one&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;<br>&lt;span class=&quot;hljs-constant&quot;&gt;two&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;25&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;<br>&lt;span class=&quot;hljs-constant&quot;&gt;three&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;31&lt;/span&gt;<br>&lt;span class=&quot;hljs-constant&quot;&gt;four&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;26&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;35&lt;/span&gt;<br>&lt;span class=&quot;hljs-constant&quot;&gt;five&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;40&lt;/span&gt;<br>&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<h4 id="end模式"><strong>6) END模式</strong></h4>
<p><code>END</code>模式是在处理完数据之后执行的操作；例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs asciidoc has-numbering&quot;&gt;#! /usr/bin/awk -f<br># /usr/bin/env awk -f<br>#filename:test.sh<br><br>BEGIN &#123;<br>&lt;span class=&quot;hljs-code&quot;&gt;    print &quot;Beging operator.&quot;&lt;/span&gt;<br>&lt;span class=&quot;hljs-code&quot;&gt;    print &quot;====================&quot;&lt;/span&gt;<br>&#125;<br>/^one/ , $3==14 &#123;print&#125;<br><br>END &#123;<br>&lt;span class=&quot;hljs-code&quot;&gt;    print &quot;====================&quot;&lt;/span&gt;<br>&lt;span class=&quot;hljs-code&quot;&gt;    print &quot;Ending operator.&quot;&lt;/span&gt;<br>&#125;<br><br><br>#执行结果：<br>$ ./test.sh test.txt<br>&lt;span class=&quot;hljs-header&quot;&gt;Beging operator.<br>====================&lt;/span&gt;<br>one     10  20  30<br>two     15  25  20<br>three   20  15  31<br>four    16  26  35<br>&lt;span class=&quot;hljs-header&quot;&gt;five    11  14  40<br>====================&lt;/span&gt;<br>Ending operator.<br>&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<h3 id="awk-变量">awk 变量</h3>
<p><code>awk</code>中的用户自定义的变量一般在<code>BEGIN</code>模式中定义；</p>
<h4 id="系统内置变量">系统内置变量</h4>
<p><code>awk</code>的常用系统内置变量如下表所示：</p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="header">
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>$0</td>
<td>当前记录（存放着整个行的内容）</td>
</tr>
<tr class="even">
<td><span class="math inline">\(1~\)</span>n</td>
<td>当前记录的第n个字段，字段间由FS分隔</td>
</tr>
<tr class="odd">
<td>FS</td>
<td>输入字段分隔符 默认是空格或Tab</td>
</tr>
<tr class="even">
<td>NF</td>
<td>当前记录中的字段个数，就是有多少列</td>
</tr>
<tr class="odd">
<td>NR</td>
<td>已经读出的记录数，就是行号，从1开始，如果有多个文件话，这个值也是不断累加中</td>
</tr>
<tr class="even">
<td>FNR</td>
<td>当前记录数，与NR不同的是，这个值会是各个文件自己的行号</td>
</tr>
<tr class="odd">
<td>RS</td>
<td>输入的记录分隔符， 默认为换行符</td>
</tr>
<tr class="even">
<td>OFS</td>
<td>输出字段分隔符， 默认也是空格</td>
</tr>
<tr class="odd">
<td>ORS</td>
<td>输出的记录分隔符，默认为换行符</td>
</tr>
<tr class="even">
<td>FILENAME</td>
<td>当前输入文件的名字</td>
</tr>
</tbody>
</table>
<h4 id="运算符">运算符</h4>
<p><code>awk</code>命令支持常用的运算符：算术运算符、赋值运算符、条件运算符、逻辑运算法、关系运算符等操作；</p>
<p><strong>算术运算符</strong></p>
<p><code>awk</code>命令直接支持的算术运算符有：加+、减-、乘*、除/、模运算%、指数运算^；</p>
<p><strong>赋值运算符</strong></p>
<p><code>awk</code>命令常用的赋值运算符有：=、+=、-=、*=、/=、%=、^=；</p>
<p><strong>条件运算符</strong></p>
<p><code>awk</code>命令的条件运算符语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs  has-numbering&quot;&gt;表达式?值1:值2&lt;/code&gt;<br></code></pre></td></tr></table></figure>
<p><strong>逻辑运算法</strong></p>
<p><code>awk</code>命令支持的逻辑运算符：&amp;&amp;、||、！；</p>
<p><strong>关系运算符</strong></p>
<p><code>awk</code>命令支持的关系运算符：&gt;、&gt;=、&lt;、&lt;=、==、！=、<sub>、!</sub>；</p>
<h4 id="awk-函数"><strong>awk 函数</strong></h4>
<p><code>awk</code>提供了许多系统函数，用户也可以自定义函数；</p>
<p><strong>字符串函数</strong></p>
<p>常用的字符串函数有：</p>
<table>
<colgroup>
<col style="width: 34%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>index(string1, string2)</td>
<td>返回 string2 在string1中第一次出现的位置</td>
</tr>
<tr class="even">
<td>length(string)</td>
<td>返回string的长度</td>
</tr>
<tr class="odd">
<td>match(string,regexp)</td>
<td>返回string中符合regexp的子字符串</td>
</tr>
<tr class="even">
<td>split(string,array,seperator)</td>
<td>根据分隔符seperator，将字符串string分隔成多个字段，并存储到数组array中</td>
</tr>
<tr class="odd">
<td>sub(regexp,replacement,string)</td>
<td>将字符串string第一个符合regexp的子字符串替换成replacement</td>
</tr>
<tr class="even">
<td>gsub(regexp,replacement,string)</td>
<td>将字符串string中符合regexp的全部子字符串都替换成replacement</td>
</tr>
<tr class="odd">
<td>substr(string,start,[length])</td>
<td>从字符串string的start位置开始截取长度为length(若指定了length，否则一直截取到字符串string结束)字串</td>
</tr>
</tbody>
</table>
<p><strong>算术函数</strong></p>
<p>常用的算术函数有：int(x)、sqrt(x)、exp(x)、log(x)、sin(x)、cos(x)、rand(x)、srand(x)；2)</p>
<p>实例：</p>
<ul>
<li>$ awk '/^(no|so)/' test-----打印所有以模式no或so开头的行。</li>
<li>$ awk '/<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>/{print $1}'
test-----如果记录以n或s开头，就打印这个记录。</li>
<li>$ awk '<span class="math inline">\(1 ~/[0-9][0-9]\)</span>/(print
$1}' test-----如果第一个域以两个数字结束就打印这个记录。</li>
<li>$ awk '$1 == 100 || $2 &lt; 50'
test-----如果第一个或等于100或者第二个域小于50，则打印该行。</li>
<li>$ awk '$1 != 10' test-----如果第一个域不等于10就打印该行。</li>
<li>$ awk '/test/{print $1 + 10}'
test-----如果记录包含正则表达式test，则第一个域加10并打印出来。</li>
<li>$ awk '{print ($1 &gt; 5 ? "ok "$1: "error"$1)}'
test-----如果第一个域大于5则打印问号后面的表达式值，否则打印冒号后面的表达式值。</li>
<li>$ awk '/<sup>root/,/</sup>mysql/'
test----打印以正则表达式root开头的记录到以正则表达式mysql开头的记录范围内的所有记录。如果找到一个新的正则表达式root开头的记录，则继续打印直到下一个以正则表达式mysql开头的记录为止，或到文件末尾。</li>
</ul>
<h2 id="可执行文件elf">11. 可执行文件ELF</h2>
<h3 id="elf简介">ELF简介</h3>
<p>ELF文件除了包含程序本身的<strong>代码</strong>和<strong>静态数据</strong>之外，还包括一些用来<strong>描述它们的信息</strong>，否则我们连代码和数据之间的分界线在哪里都不知道。这些信息描述了可执行文件的组织形式,
不同组织形式形成了不同格式的可执行文件,</p>
<p>Windows主流的可执行文件是PE(Portable Executable)格式</p>
<p>GNU/Linux主要使用ELF(Executable and Linkable
Format)格式。ELF是GNU/Linux可执行文件的标准格式,
这是因为GNU/Linux遵循System V ABI(Application Binary Interface).</p>
<p><strong>为什么堆和栈的内容没有放入可执行文件里面?
程序运行时刻用到的堆和栈又是怎么来的?</strong></p>
<p>ELF文件提供了两个视角来组织一个可执行文件。</p>
<p>一是面向链接过程的section视角，这个视角提供了用于链接与重定位的信息(例如符号表)。</p>
<p>二是面向执行的segment视角，这个视角提供了用于加载可执行文件的信息。</p>
<p>通过readelf命令,
我们还可以看到section和segment之间的映射关系：一个segment可能由0个或多个section组成,
但一个section可能不被包含于任何segment中。</p>
<p>ELF中采用<strong>program header table</strong>来管理segment, program
header
table的一个表项描述了一个segment的所有属性，包括<strong>类型</strong>,
<strong>虚拟地址</strong>，<strong>标志</strong>，<strong>对齐方式</strong>，以及<strong>文件内偏移量</strong>和<strong>segment大小</strong>。根据这些信息,
我们就可以知道需要加载可执行文件的哪些字节了，同时我们也可以看到，加载一个可执行文件并不是加载它所包含的所有内容，只要加载那些与运行时刻相关的内容就可以了,
例如调试信息和符号表就不必加载。我们可以通过判断segment的Type属性是否为<strong>PT_LOAD</strong>来判断一个segment是否需要加载。更多与ELF文件相关的信息,
请参考</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">man 5 elf<br></code></pre></td></tr></table></figure>
<h3 id="readelf命令">readelf命令</h3>
<p>readelf命令，一般用于查看ELF格式的文件信息，常见的文件如在Linux上的可执行文件，动态库(<em>.so)或者静态库(</em>.a)
等包含ELF格式的文件。</p>
<p><strong>选项 -h</strong>(elf
header)，显示elf文件开始的文件头信息，如下所示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ELF Header:<br>  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 <br>  Class:                             ELF64<br>  Data:                              2<span class="hljs-string">&#x27;s complement, little endian</span><br><span class="hljs-string">  Version:                           1 (current)</span><br><span class="hljs-string">  OS/ABI:                            UNIX - System V</span><br><span class="hljs-string">  ABI Version:                       0</span><br><span class="hljs-string">  Type:                              EXEC (Executable file)</span><br><span class="hljs-string">  Machine:                           RISC-V</span><br><span class="hljs-string">  Version:                           0x1</span><br><span class="hljs-string">  Entry point address:               0x80000000</span><br><span class="hljs-string">  Start of program headers:          64 (bytes into file)</span><br><span class="hljs-string">  Start of section headers:          50496 (bytes into file)</span><br><span class="hljs-string">  Flags:                             0x4, double-float ABI</span><br><span class="hljs-string">  Size of this header:               64 (bytes)</span><br><span class="hljs-string">  Size of program headers:           56 (bytes)</span><br><span class="hljs-string">  Number of program headers:         2</span><br><span class="hljs-string">  Size of section headers:           64 (bytes)</span><br><span class="hljs-string">  Number of section headers:         13</span><br><span class="hljs-string">  Section header string table index: 12</span><br></code></pre></td></tr></table></figure>
<p><strong>选项 -l</strong>(program headers),segments
显示程序头（段头）信息(如果有数据的话)。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Elf file <span class="hljs-built_in">type</span> is EXEC (Executable file)<br>Entry point 0x80000000<br>There are 2 program headers, starting at offset 64<br><br>Program Headers:<br>  Type           Offset             VirtAddr           PhysAddr<br>                 FileSiz            MemSiz              Flags  Align<br>  LOAD           0x0000000000001000 0x0000000080000000 0x0000000080000000<br>                 0x000000000000a6c8 0x0000000000014028  RWE    0x1000<br>  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000<br>                 0x0000000000000000 0x0000000000000000  RW     0x10<br><br> Section to Segment mapping:<br>  Segment Sections...<br>   00     .text .rodata .sdata2.__func__.1497 .sdata2.mainargs .data .data.heap .data.lut .bss <br>   01     <br></code></pre></td></tr></table></figure>
<p>找出每一个需要加载的segment的<strong>Offset</strong>，<strong>VirtAddr</strong>，<strong>FileSiz</strong>和<strong>MemSiz</strong>这些参数。<strong>相对文件偏移Offset指出相应segment的内容从ELF文件的第Offset字节开始,
在文件中的大小为FileSiz, 它需要被分配到以VirtAddr为首地址的虚拟内存位置,
在内存中它占用大小为MemSiz。</strong>
也就是说，这个segment使用的内存就是[VirtAddr, VirtAddr +
MemSiz)这一连续区间，然后将segment的内容从ELF文件中读入到这一内存区间，<strong>并将[VirtAddr
+ FileSiz, VirtAddr + MemSiz)对应的物理区间清零。</strong></p>
<p>关于程序从何而来, 可以参考一篇文章: <a
href="https://www.tenouk.com/ModuleW.html">COMPILER, ASSEMBLER, LINKER
AND LOADER: A BRIEF STORY</a></p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>ns<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>异步复位同步撤离</title>
    <url>/2022/11/30/%E5%BC%82%E6%AD%A5%E5%A4%8D%E4%BD%8D%E5%90%8C%E6%AD%A5%E6%92%A4%E7%A6%BB/</url>
    <content><![CDATA[<h1 id="同步复位">1 同步复位</h1>
<h2 id="优点">1.1 优点</h2>
<p>一般能够确保电路是百分之百同步的。确保复位只发生在有效时钟沿，可以作为过滤掉毛刺的手段。</p>
<h2 id="缺点">1.2 缺点</h2>
<p>复位信号的有效时长必须大于时钟周期，才能真正被系统识别并完成复位。同时还要考虑如：时钟偏移、组合逻辑路径延时、复位延时等因素。
<strong>大多数的厂商目标库内的触发器都只有异步复位端口，采用同步复位的话，就会耗费较多的逻辑资源。</strong></p>
<span id="more"></span>
<h1 id="异步复位">2 异步复位</h1>
<h2 id="recovery-time和removal-time">2.1 recovery time和removal
time</h2>
<p>在同步电路中，输入数据需要与时钟满足setup time和hold
time才能进行数据的正常传输，防止亚稳态。同样的道理，对于一个异步复位寄存器来说，同样异步复位信号同样需要和时钟满足<strong>recovery
time</strong>和<strong>removal
time</strong>才能有效进行复位操作和复位释放操作，防止输出亚稳态。</p>
<figure>
<img src="异步复位同步撤离.assets/27ae96e33de2f650b59996834cd1d472.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>recovery
time</strong>（恢复时间）：撤销复位时，恢复到非复位状态的电平必须在时钟有效沿来临之前的一段时间到来，才能保证时钟能有效恢复到非复位状态，此段时间为recovery
time，类似于同步时钟的setup time。</p>
<p><strong>removal
time</strong>（去除时间）：复位时，在时钟有效沿来临之后复位信号还需要保持复位状态的一段时间为去除时间removal
time(去除时间)。类似同步时钟hold time。</p>
<p>复位信号的操作（无论是复位还是释放）如果在时钟的recovery
time和removal
time之间的时间窗口内，都会产生亚稳态。异步复位信号一般会持续相对较长的时间，保证寄存器能复位完成。但是由于复位信号是异步的，我们不知道它会在什么时刻被释放。如果异步复位信号撤销时，不满足recovery
time和removal
time时，可能会造成亚稳态。显然，并不是复位信号撤销时才可能出现亚稳态，复位信号一开始出现时，同样可能会存在亚稳态，只不过异步复位信号持续时间长，即使第一个周期出现了亚稳态（即第一个周期复位未成功），下一个时钟周期也不会再出现亚稳态了。如果复位信号的变化只持续刚刚一个时钟周期，那么复位信号开始和撤销时都可能会出现亚稳态。</p>
<h2 id="优点-1">2.2 优点</h2>
<ul>
<li>异步复位信号识别方便，而且可以<strong>很方便的使用全局复位</strong>。</li>
<li>由于大多数的厂商目标库内的触发器都有异步复位端口，可以<strong>节约逻辑资源</strong>。</li>
</ul>
<h2 id="缺点-1">2.3 缺点</h2>
<ul>
<li>复位信号容易受到毛刺的影响。</li>
<li>复位结束时刻恰在亚稳态窗口内时，无法决定现在的复位状态是1还是0，会导致亚稳态。</li>
</ul>
<h1 id="异步复位同步释放"><strong>3 异步复位同步释放</strong></h1>
<p>Synchronized Asynchronous
Reset，就是在复位信号到来的时候不受时钟信号的同步，而是在复位信号释放的时候受到时钟信号的同步。</p>
<p>电路目的：防止复位信号撤除时产生亚稳态事件。</p>
<p>​
异步复位：显而易见，reset_n异步复位后，rst_n将拉低，即实现异步复位。</p>
<p>​
同步释放：这个是关键，看如何实现同步释放，即当复位信号reset_n撤除时，由于双缓冲电路（双寄存器）的作用，rst_n复位信号不会随着reset_n的撤除而撤除。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">//Synchronized Asynchronous Reset：只适用于没有PLL的系统复位信号的设置</span><br><span class="hljs-keyword">module</span> sync_async_reset(clock,reset_n,rst_n);<br><br>  <span class="hljs-keyword">input</span> clock, reset_n;<br>  <span class="hljs-keyword">output</span> rst_n;<br>  <span class="hljs-keyword">reg</span> rst_nr1, rst_nr2;<br>  <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clock <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> reset_n) <span class="hljs-keyword">begin</span><br>      <span class="hljs-keyword">if</span>(!reset_n) <span class="hljs-keyword">begin</span><br>      rst_nr1 &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>          rst_nr2 &lt;= <span class="hljs-number">1&#x27;b0</span>;		<span class="hljs-comment">//异步复位</span><br>      <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      rst_nr1 &lt;= <span class="hljs-number">1&#x27;b1</span>;<br>      rst_nr2 &lt;= rst_nr1;		  <span class="hljs-comment">//同步释放</span><br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-keyword">assign</span> rst_n = rst_nr2;			<span class="hljs-comment">//新的系统复位信号rst_n	</span><br><span class="hljs-comment">//信号rst_n作为新的系统复位信号，后续可以用来直接“异步复位”</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>
<figure>
<img
src="异步复位同步撤离.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tpZXpoYW5nMTk5Mw==,size_16,color_FFFFFF,t_70.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img
src="异步复位同步撤离.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjUxODU1OA==,size_16,color_FFFFFF,t_70.png"
alt="在这里插入图片描述" />
<figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>当异步复位信号撤销时，用来同步的第二个寄存器输入的数据仍然是0，因此第二个寄存器是不会出现亚稳态的。第一个寄存器虽然可能出现亚稳态，即使其出现了亚稳态，这个亚稳态还需要通过第二个寄存器，这时第二个寄存器就起到了打拍的作用。也就是说，第二级的亚稳态只可能是上一级寄存器传播过来的，但是这个亚稳态经过第二级寄存器后，其大概率已经稳定下来了，就算稳定下来不为1，也就相当与复位信号多持续了一个周期而已。因此我们可以看出，使用异步复位同步释放时，异步复位撤销后是需要额外等待一个时钟周期的，否则会激励可能会被复位信号覆盖掉。</p>
<p>注意：
既解决了同步复位的资源消耗问题，又解决了异步复位的亚稳态问题，其根本思想是异步信号同步化；</p>
<p>​ 新的系统复位信号可以直接用来“异步复位”；</p>
<p>​ 只适用于不带PLL的系统。</p>
<h1 id="pll配置后的复位设计">4 PLL配置后的复位设计</h1>
<p>​ 当多个时钟都是用PLL产生时，它们的系统复位信号采用如下设计：</p>
<p>①先用FPGA的外部输入时钟clk将FPGA的输入复位信号rst_n做异步复位、同步释放处理（注意采用反逻辑），然后这个复位信号输入PLL，同时将clk也输入PLL。设计的初衷是在PLL输出有效时钟之前，系统的其他部分都保持复位状态。</p>
<p>②PLL的输出<strong>locked信号</strong>在PLL有效输出前一直时低电平，PLL输出稳定有效之后才会拉高该信号，所以这里就把前面提到的FPGA外部输入复位信号rst_n和这个locked信号相与作为整个系统的复位信号。</p>
<p>③这个复位信号也需要让合适的PLL输出时钟异步复位、同步释放处理一下。也就是说，为了达到可靠稳定的复位信号，该设计中对复位信号进行了两次处理，分别是在PLL输出前和PLL输出后。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> sys_ctrl(clk,rst_n,sys_rst_n,clk_25m,clk_100m);<br> <br>	<span class="hljs-keyword">input</span> clk;			<span class="hljs-comment">//FPGA输入时钟信号</span><br>	<span class="hljs-keyword">input</span> rst_n;		<span class="hljs-comment">//系统硬件复位信号</span><br>	<span class="hljs-keyword">output</span> sys_rst_n;	<span class="hljs-comment">//系统复位信号，低有效	 </span><br>	<span class="hljs-keyword">output</span> clk_25m, clk_100m;<br>	<br>	<span class="hljs-keyword">reg</span> rst_r1, rst_r2;<br>	<span class="hljs-keyword">reg</span> sysrst_nr1, sysrst_nr2;<br>	<span class="hljs-keyword">wire</span> pll_rst;<br>	<span class="hljs-keyword">wire</span> locked;		<span class="hljs-comment">//输出信号有效标志，高表示PLL输出有效</span><br>	<span class="hljs-keyword">wire</span> sysrst_nr0;<br>	<span class="hljs-keyword">wire</span> sys_rst_n;		<span class="hljs-comment">//系统复位信号，低有效</span><br>	<br>	<span class="hljs-comment">//第一个异步复位同步释放</span><br>	<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst_n)<br>		<span class="hljs-keyword">if</span>(!rst_n) <span class="hljs-keyword">begin</span><br>			rst_r1 &lt;= <span class="hljs-number">1&#x27;b1</span>;<br>			rst_r2 &lt;= <span class="hljs-number">1&#x27;b1</span>;		<span class="hljs-comment">//注意这里是“反”逻辑</span><br>		<span class="hljs-keyword">end</span><br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>			rst_r1 &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>			rst_r2 &lt;= rst_r1;<br>		<span class="hljs-keyword">end</span><br>	 <br>	<span class="hljs-keyword">assign</span> pll_rst = rst_r2;	<span class="hljs-comment">//PLL的复位信号</span><br>	<br>	PLL_ctrl uut_PLL_ctrl(<br>		<span class="hljs-variable">.areset</span>(pll_rst),<br>		<span class="hljs-variable">.inclk0</span>(clk),<br>		<span class="hljs-variable">.c0</span>(clk_25m),<br>		<span class="hljs-variable">.c1</span>(clk_100m),<br>		<span class="hljs-variable">.locked</span>(locked)<br>	);<br>	<br>	<span class="hljs-keyword">assign</span> sysrst_nr0 = rst_n &amp; locked;		<span class="hljs-comment">//&quot;与&quot;逻辑</span><br>	<br>	<span class="hljs-comment">//第二个异步复位同步释放</span><br>	<span class="hljs-comment">//注意这里的同步时钟为合适的PLL输出时钟</span><br>	<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk_100m <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> sysrst_nr0)<br>		<span class="hljs-keyword">if</span>(!sysrst_nr0) <span class="hljs-keyword">begin</span><br>			sysrst_nr1 &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>			sysrst_nr2 &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>		<span class="hljs-keyword">end</span><br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>			sysrst_nr1 &lt;= <span class="hljs-number">1&#x27;b1</span>;<br>			sysrst_nr2 &lt;= sysrst_nr1;<br>		<span class="hljs-keyword">end</span><br>	<br>	<span class="hljs-comment">//信号sys_rst_n作为新的系统复位信号，后续可用作异步复位</span><br>	<span class="hljs-keyword">assign</span> sys_rst_n = sysrst_nr2;<br> <br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>
<figure>
<img
src="异步复位同步撤离.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tpZXpoYW5nMTk5Mw==,size_16,color_FFFFFF,t_70-16698136856697.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
]]></content>
      <categories>
        <category>IC</category>
      </categories>
      <tags>
        <tag>复位</tag>
      </tags>
  </entry>
  <entry>
    <title>总线</title>
    <url>/2022/11/20/%E6%80%BB%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="什么是总线">什么是总线？</h1>
<p>总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线，它是由导线组成的传输线束，
按照计算机所传输的信息种类，计算机的总线可以划分为数据总线、地址总线和控制总线，分别用来传输数据、数据地址和控制信号。总线是一种内部结构，它是CPU、内存、输入、输出设备传递信息的公用通道，主机的各个部件通过总线相连接，外部设备通过相应的接口电路再与总线相连接，从而形成了计算机硬件系统。在计算机系统中，各个部件之间传送信息的公共通路叫总线，微型计算机是以总线结构来连接各个功能部件的。</p>
<span id="more"></span>
<h1 id="axi总线">AXI总线</h1>
<ul>
<li><a
href="https://developer.arm.com/Architectures/AMBA"><strong>AMBA手册</strong></a></li>
<li><a
href="https://www.lzrnote.cn/2021/10/08/axi总线总结/"><strong>总线中文手册及总结</strong></a></li>
<li><a
href="https://zhuanlan.zhihu.com/p/44766356"><strong>深入AXI4总线</strong></a></li>
</ul>
<h2 id="validready-握手机制">VALID/READY 握手机制</h2>
<p>VALID/READY
作为一种双向流控机制，可以使发送接收双方都有能力控制传输速率。</p>
<p><strong>发送方</strong>置高 <strong>VALID</strong>
信号表示发送方已经将数据，地址或者控制信息已经就绪，并保持于消息总线上。</p>
<p><strong>接收方</strong>置高 <strong>READY</strong>
信号表示接收方已经做好接收的准备。</p>
<p>当双方的 VALID/READY
信号同时为高，在时钟上升沿，完成一次数据传输。所有数据传输完毕后，双方同时置低自己的信号。</p>
<p>所谓的<strong>双向流控</strong>机制，指的是发送方通过置起 VALID
信号控制发送的时机与速度，接收方也可以通过 READY
信号的置起与否控制接收速度。发送方拥有传输的主动权，但接收方在不具备接收能力时，也能够置低信号停止传输，反压发送方。</p>
<p>VALID 信号一旦置起就不能置低，直到完成握手（handshake
occurs）。在设计接收方逻辑时，检测到 VALID
信号置起，如果系统正忙，完全可以让发送方等待，发送方在完成传输之前都不会置低
VALID
信号，不需要考虑发送方撤销传输的可能。协议另外规定：发送方不能通过等待接收方
READY 信号来确定置起 VALID 信号的时机。</p>
<p>换句话说，发送方准备发送，置起 VALID
信号是完全<strong>主动与独立</strong>的过程。接收方 READY
信号按照协议可以依赖发送方 VALID
信号，但如果此时发送方也依赖接收方信号，就会造成死锁的情况，所以协议在这里强调了
VALID 信号的主动性。</p>
<p>接收方可以置起 READY 之后发现：其实我好像还挺忙，然后置低 READY
信号。只要此时 VALID 信号没有置起，这种操作是完全可以。</p>
<p>READY 信号原则上由接收方自身的接收状况以及 VALID
信号控制。（或者仅由接收方自身的接收状况决定）协议中没有规定 READY
信号的默认状态，即未进行传输时的电平状态（default value）。</p>
<p>协议建议 AW/AR READY
信号的默认电平为高电平。若默认电平为低，则每次传输至少需要 2
个周期才能完成，第一个周期置高 VALID 信号，第二个周期从机才会置高 READY
信号。相当于每次传输增加 1
个周期时间开销，这在某些情况下会对传输效率有较大的影响。</p>
<h2 id="axi4-lite">AXI4-Lite</h2>
<h2 id="axi4">AXI4</h2>
<p>AXI4协议分为以下几个通道：</p>
<ul>
<li>AR：读地址通道</li>
<li>R ：读数据通道</li>
<li>AW：写地址通道</li>
<li>W ：写数据通道</li>
<li>B ：写反馈通道</li>
</ul>
<h3 id="araw通道">AR/AW通道：</h3>
<p>Master-&gt;Slave信号:</p>
<ul>
<li><code>A[RW]ADDR</code>：读写的字节地址</li>
<li><code>A[RW]LEN</code>：读写的传输次数，次数定义为<code>A[RW]LEN+1</code>。</li>
<li><code>A[RW]SIZE</code>：单次传输的数据大小，字节数定义为<code>2 ** A[RW]SIZE</code>，且不可超过数据总线宽度。</li>
<li><code>A[RW]BURST</code>：突发传输类型（INCR与WARP模式可以一次地址握手完成多次不同地址的数据传输，提高Cache替换效率，若只需要实现AXI4Lite可直接使用FIXED模式）</li>
<li><code>A[RW]VALID</code>：读写的有效性</li>
</ul>
<p>此外，这里依据Slave支持的特性不同可能还有<code>A[RW]CACHE</code>、<code>A[RW]PROT</code>、<code>A[RW]PROT</code>、<code>A[RW]QOS</code>信号，这些信号我们可暂时忽略，直接assign为0即可。</p>
<p>如果总线支持<code>A[RW]ID</code>，则需要对于不同的设备传输正确的ID信息。例如你的CPU的I-Cache与D-Cache独立，且都使用AXI访问总线，你就可以在CPU核里面写一个AXI
Crossbar，并使用不同的ID区分设备，在握手时仲裁，并在数据返回时发送给对应的设备。</p>
<p>Slave-&gt;Master:</p>
<ul>
<li><code>A[RW]READY</code>：地址握手完成</li>
</ul>
<p>地址握手流程：</p>
<ol type="1">
<li>初始状态，Master端<code>A[RW]VALID</code>
<strong>必须</strong>为0，Slave端<code>A[RW]READY</code>只要不是复位状态<strong>可以</strong>为1，以便Slave单周期握手。</li>
<li>Master填写正确填写<code>A[RW]ADDR</code>、<code>A[RW]SIZE</code>等信号，并将<code>A[RW]VALID</code>设置为1。</li>
<li>当某一时刻的<strong>时钟上升沿之前</strong>出现<code>A[RW]VALID</code>与<code>A[RW]READY</code>都为1时，地址握手结束。此时Master端<strong>必须在时钟上升沿之后</strong>将<code>A[RW]VALID</code>信号置0或发送新的请求。否则Slave端将认为同一个地址请求发送了2次，并做出2次响应。</li>
</ol>
<h3 id="r通道">R通道：</h3>
<p>Slave-&gt;Master信号：</p>
<ul>
<li><code>RDATA</code>：读取数据结果</li>
<li><code>RLAST</code>：标记最后一次读数据传输
可用于检验COUNT是否一致</li>
<li><code>RRESP</code>：读数据的反馈，用于传输总线错误。
简单核的实现可以在总线错误时不产生异常，只需要确保软件访问物理内存地址一定正确即可。</li>
<li><code>RVALID</code>：读数据有效</li>
</ul>
<p><code>RID</code>用于与<code>ARID</code>对应，用于标识对应的请求。</p>
<p>Master-&gt;Slave信号：</p>
<ul>
<li><code>RREADY</code>：本次读数据传输完成</li>
</ul>
<h3 id="w通道">W通道：</h3>
<p>Master-&gt;Slave信号：</p>
<ul>
<li><code>WDATA</code>：写数据</li>
<li><code>WSTRB</code>：写掩码</li>
<li><code>WLAST</code>：标记最后一次写数据传输（可用于检验COUNT是否一致）</li>
<li><code>WVALID</code>：写数据有效</li>
</ul>
<p>注：AXI3存在WID，AXI4省略了WID。因为AXI不允许Master先握手AW再握手W这样的操作，因此WID显得无意义。</p>
<p>Slave-&gt;Master信号：</p>
<ul>
<li><code>WREADY</code>：本次写数据传输完成</li>
</ul>
<h3 id="b通道">B通道：</h3>
<p>Slave-&gt;Master信号：</p>
<ul>
<li><code>BID</code>：与AWID对应，表示对应写请求的反馈。</li>
<li><code>BRESP</code>：写数据的反馈，与<code>RRESP</code>一样，用于传输总线错误。</li>
<li><code>BVALID</code>：写反馈有效</li>
</ul>
<p>Master-&gt;Slave信号：</p>
<ul>
<li><code>BREADY</code>：本次写反馈传输完成</li>
</ul>
<h3 id="burst类型">Burst类型</h3>
<p>AXI4支持突发传输，实现一次地址握手传输多个数据，避免将大量时间花在地址握手传输上。</p>
<p>尽管AR与R通道以及AW与W通道的分离看似地址与数据可以流水化传输，但是对于许多硬件Slave设备而言，往往地址握手后一段时间才能读写第一个数据（例如DDR内存），这便是突发传输能够加速的原因。</p>
<p>AXI4支持以下3种BURST类型：</p>
<ol type="1">
<li><p>FIXED</p>
<p>每次都操作[<code>A[RW]ADDR</code> +:
<code>A[RW]SIZE</code>]部分。</p></li>
<li><p>INCR</p>
<p>从<code>A[RW]ADDR</code>开始，
每次操作地址递增<code>A[RW]SIZE</code>。</p>
<p>如果某一时刻操作的地址越过了总线宽度范围，则本次只传输到结束位置，下次传输地址从对齐总线宽度的地方开始。</p>
<p>例如某一时刻操作地址=5，总线宽度8字节，每次传输字节数为4，则本次操作传输字节5-7部分，下次传输8-11部分。</p></li>
<li><p>WARP</p>
<p>类似INCR类型，用于传输一段2的整数幂字节的地址范围，但可以通过设置<code>A[RW]ADDR</code>决定起始地址。</p>
<p>但这一类型的Burst对于发送的地址存在一定限制，详情请大家自己看AMBA文档。</p>
<p>具体地址计算细节请自行阅读<a
href="https://developer.arm.com/Architectures/AMBA">AMBA文档</a>的A3.Transcation
structure部分。</p></li>
</ol>
<h4 id="narrow-burst">Narrow Burst</h4>
<p>当<code>A[RW]SIZE</code>指定的单次传输数据大小<strong>小于</strong>总线数据宽度时，这种Burst称为Narrow
Burst。</p>
<p>对于Narrow
Burst，无论是读写请求，数据都出现在<code>[RW]DATA</code>对应访问地址%总线宽度的位置。</p>
<p>举个例子：使用INCR
Burst读取内存地址[6]、[7]、[8]，每次读取1字节。总线<code>RDATA</code>宽度为64位。</p>
<p>按照以下方式发送AR请求：</p>
<ul>
<li>ARADDR=6</li>
<li>ARSIZE=0（1 Bytes）</li>
<li>ARLEN=2（3 Bursts）</li>
<li>ARBURST=1（INCR）</li>
</ul>
<p>SLAVE会在R通道传回3个请求，分别是：</p>
<ul>
<li><p>第一次传输：</p>
<p>Slave读取[6]地址，有效数据在<code>RDATA</code>的<code>[55:48]</code>部分。</p></li>
<li><p>第二次传输</p>
<p>Slave读取[7]地址，有效数据在<code>RDATA</code>的<code>[63:56]</code>部分。</p></li>
<li><p>第三次传输：</p>
<p>Slave读取[8]地址，有效数据在<code>RDATA</code>的<code>[7:0]</code>部分。</p></li>
</ul>
<h3 id="axi4注意事项">AXI4注意事项</h3>
<ol type="1">
<li><p>所有通道的<code>VALID</code>与<code>READY</code>之间不能有组合逻辑。无论对于Master端还是Slave端。如果想要单周期握手，对于AR、AW、W通道，Slave可以选择默认状态下将<code>READY</code>置1。对于R、B通道，Master可以选择默认状态下将<code>READY</code>置1。</p></li>
<li><p>对于写请求，不可等待<code>AW</code>握手完成后再升高<code>WVALID</code>。因为AXI协议允许Slave设备等待<code>AWVALID</code>与<code>WVALID</code>都为1后，再升高<code>AWREADY</code>。如果这么做或许部分SoC上能运行，但会在使用部分Slave设备时出现死锁（例如Vivado
Block Memory Generator）。</p></li>
<li><p>AXI请求不可撤销。</p>
<p>一旦任何通道的VALID升高后，其数据必须保持不变直到握手结束，包括ID部分和VALID本身。所以只依靠AXI信号实现的纯组合逻辑AXI
Crossbar一定是不符合规范的。</p></li>
<li><p>对于外设的MMIO访问，需要根据所对应访存的指令的长度正确填写<code>A[RW]SIZE</code>。</p>
<p>例如<code>lb</code>与<code>sb</code>指令的<code>A[RW]SIZE</code>必须为0（表示1字节）。不应该在针对MMIO的写请求时使用<code>WSTRB</code>指定要更改的数据范围。对于读请求，也不应该读出整个数据宽度后再选择。因为这两种方式在MMIO设备看来访问的是不同的寄存器。</p></li>
<li><p>写操作直到BVALID拉高才算结束。</p>
<p>如果不等待B通道马上在AR通道发出读请求，有可能读到写完成之前的旧值。</p></li>
</ol>
<h3 id="写传输操作write-transcation">写传输操作：Write transcation</h3>
<p>如下图所示，主机首先在写地址通道（AW）上告知从机本次传输操作（transcaction，对应后文中的"传输操作"）的特性，包括地址和控制信息。然后，在写数据通道（W）向从机写入数据，一次传输操作中可能包括多个数据传输。</p>
<p>最后，从机在接收到写数据后，通过写回复通道（R）将本次传输操作的响应告知主机。主机以收到从机的响应信号，作为本次传输操作结束的标志。<strong>写回复是针对整个传输操作（transcaction）的，而不是针对每个写入数据（data
transfer），且所有传输操作中，写回复
与写数据的关系都如下图所示，写回复必然是在收到传输操作中最后一个写数据之后触发。</strong></p>
<p>但是，写地址与写数据的关系并不局限于一种情况。一般来说，写数据都发生在写地址操作之后，但也不是绝对的，在有些情况下，可以先写数据，或者在同一周期写入数据与地址，都是允许的。这也表现了
AXI 通道之间的独立性。</p>
<figure>
<img src="总线.assets/v2-7c95b31e753dfedfdfb1ad0d890af01e_1440w.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="读操作read-transcation">读操作：Read transcation</h3>
<p>读操作只涉及两个通道，首先主机在读地址通道上写入本次Transcation待读取数据的地址以及控制信息。从机在接收到地址后，将该地址上的数据通过读数据通道传输给主机。读操作通道间（ARC&amp;RC）完全独立，从机发出读数据一定发生在主机写入读地址后。</p>
<figure>
<img src="总线.assets/v2-f28c75e6e50991c6640e5737af46bdf3_1440w.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="突发传输burst-transaction">突发传输：Burst Transaction</h3>
<p>两个 AXI 组件为了传输一组数据而进行的所有交互称为 <strong>AXI
Transaction</strong>，AXI 传输事务，包括所有 5 个通道上的交互。</p>
<p>AXI 是一个 burst-based 协议，AXI 传输事务中的数据传输以 burst
形式组织，称为 <strong>AXI Burst</strong>。每个传输事务包括一至多个
Burst。每个 Burst 中传输一至多个数据，每个数据传输称为 <strong>AXI
Transfer</strong>。每个Transfer
因为使用一个周期，又被称为一拍数据（Beat）。主机可以写入起始地址以及突发传输的长度等信息，从机将起始地址开始，依次接收主机传输的写数据，或者读取连续地址上的数据，作为读数据传输给主机。所以上面两张图中，一次传输操作中（Transcation）
中包括了一次地址与控制信息（Address &amp; Control）、多个数据（data
transfer）。</p>
<p>注意：单次 burst 传输中的数据，其地址不能跨越 4KB
边界。之所以这样规定是为了避免一笔burst交易访问两个slave（每个slave的地址空间是4K/1K对齐的）。4K对齐最大原因是系统中定义一个page大小是4K，而所谓的4K边界是指低12bit为0的地址。</p>
<p>补充一下：对于一次burst传输，只给出首地址，burst内部的地址按照<span
class="math inline">\(2^{size}\)</span>累加，也就是按每个数据字节数累加，协议之所以这么做，原因是计算机底层存储是按字节存储的。假设传输的数据是32bit，也就是4个字节，那么实际上会分配4个地址给这个32bit数据，所以按照标准的axi协议，相邻的burst首地址按照（awlen+1）*<span
class="math inline">\(2^{size}\)</span>累加，master发送首地址时要遵循这种方式，slave收到地址后，按照标准协议，解析出的burst内部的地址就是按2^size累加的。这样一来，除非size为0，也就是数据为1个字节，地址才是连续的，否则，解析出的地址不连续，不过可以根据用户侧需求，对标准协议地址进行处理，使之连续。上面说的有点混乱，举个例子：假如awlen为3，也就是一次突发传输4个数据。awsize为2，也就是每个数据4字节，32bit，第一次突发传输首地址awaddr为0。那么，根据标准axi协议，slave解析出的第一个burst四个数对应的地址为0，4，8，12，即按字节数累加。master发送第二个burst时，awaddr必须为16，slave解析第二个burst四个点得到的地址为16，20，24，28。这样就相当于给每个32bit分了四个地址，在底层每个地址存一个字节。应用时，有时不涉及底层的存储，假如只完成一个memory的读写，希望使用连续地址，那么用户可以讲按照标准协议解析出的地址除以4之后使用，则0，4，8，12就变成了0，1，2，3。另外，同一个burst的地址不能跨4K边界，而不是4KB，4KB讲的是容量。这是因为底层page的存储容量为4KB。一个burst内部地址按字节数累加，地址跨4K，也就是操作一个burst的数据时跨了4KB，跨page了，这是不允许的，一个
burst的数据必须在同一个page里，否则容易出现错误。</p>
<h3 id="传输事务结构transaction-structure">传输事务结构：Transaction
structure</h3>
<h4 id="读写地址结构"><strong>读写地址结构</strong></h4>
<p>在整个transaction中，主机首先将接下来 burst
传输的<strong>控制信息</strong>以及<strong>数据首个字节的地址</strong>传输给从机，这个地址被称为起始地址。在本次
burst
后续传输期间，从机将根据控制信息计算后续数据的地址。地址通道中传输的控制信息中包括三项突发传输相关的信号(AR/AW
均一致，下图为以 AR 为例)：</p>
<figure>
<img src="总线.assets/v2-7c260f2be1cb05ae5409f4b549ffd3b4_1440w.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>（1）LEN</strong>，指一次突发传输中包含的数据传输(transfer)数量。</p>
<p>在 AXI4 中，INCR 类型最大支持长度为 256，其他类型最大长度为
16，突发长度至少为 1。Len 信号从零开始表示，实际的长度值为 Len +
1。突发传输长度在不同burst type下有一些限制，包括：</p>
<ul>
<li>对于 WRAP 模式，突发传输长度仅能为2,4,8,16</li>
<li>在一次突发传输中，地址不能跨越一个 4KB 分区</li>
<li>一次突发传输不能在完成所有数据传输前提前结束（early
termination）</li>
</ul>
<p>协议中多次<strong>强调</strong>，通信双方都不能在传输事务的所有
Transfer 完成前提前结束，哪怕发生错误，也得走完整个传输事务的流程。</p>
<p>但是主机也有办法减少传输的数据。在写传输事务中，发送方可以通过置低所有的写有效位，使写数据无效。在读传输事务中，主机可以直接丢弃读取到的数据。</p>
<p><strong>（2）SIZE</strong>，指传输中的数据位宽，具体地，是每周期传输数据的字节数量。</p>
<p>突发传输数据宽度不能超过数据总线本身的位宽。而当数据总线位宽大于突发传输宽度时，将根据协议的相关规定，将数据在部分数据线上传输。突发传输宽度信号
AXSIZE 位宽为 3bit，表示为：</p>
<figure>
<img src="总线.assets/v2-53b57203fc06a4f4b18c2668cc8bc6fd_1440w.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>（3）突发传输类型</strong>，类型共有 3 种，分别为 FIXED，INCR
以及 WRAP，使用 2 位表示。</p>
<figure>
<img src="总线.assets/v2-907b3d1e2637ec20fc56acd6c7b8ed88_1440w.jpeg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>FIXED</strong>：burst
中所有数据都使用<strong>起始地址</strong>。该模式适合对某个固定地址进行多次数据更新，比如读写一个
fifo 时，读写地址就是固定的。</p>
<p><strong>INCR</strong>：后续数据的地址在初始地址的基础上进行递增，<strong>递增幅度与传输宽度相同</strong>。适合对于
RAM 等通过地址映射（mapped memory）的存储介质进行读写操作。</p>
<p><strong>WRAP</strong>：首先根据起始地址得到绕回边界地址（wrap
boundary）与最高地址。当前地址小于最高地址时，WRAP 与 INCR
类型完全相同，地址递增。但到递增后的地址到达最高地址后，地址直接回到绕回边界地址，再进行递增，就这样循环往复。最高地址由绕回边界地址计算得到：wrap
boundary + （N_bytes x burst_len）。根据协议，WRAP 适合对 cache
的访问。</p>
<p><strong>地址计算参考</strong></p>
<p>手册在章节 A3
详细给出了不同的突发传输模式下的地址计算公式与伪代码，有相关需求的读者可以参看这一部分。</p>
<h4 id="读写数据结构"><strong>读写数据结构</strong></h4>
<p>在 AXI 数据传输过程中，主要涉及到窄位宽数据传输（Narrow
Transfer）、非对齐传输（Unaligned
Transfer）以及混合大小端传输（mix-endianness）等问题。</p>
<h5 id="narrow-transfer"><strong>（1）Narrow Transfer</strong></h5>
<p>当本次传输中数据位宽小于通道本身的数据位宽时，称为<strong>窄位宽数据传输</strong>。</p>
<p>在窄位宽写传输中，主机需要告知从机数据通道中哪些字节是有效的，需要使用到写数据通道中的
WSTRB 信号。WSTRB 信号中的单个 bit
置起，表示对应位置上的字节有效，对应关系为：当 WSTRB[n] 为 1
时，WDATA[8n+7:8n]有效。WSTRB 信号比特位宽等于数据通道位宽的字节数量</p>
<p>对应于下图的情况中，灰色的部分代表数据无效，第一次的传输中低地址第一字节有效，其他数据无效的
，WSTRB 信号为 0x01，WSTRB [0] 为 1，即 WDATA[7:0] 有效。</p>
<figure>
<img src="总线.assets/v2-f33f82462fb92881289d62c092b2c301_1440w.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>从图中我们发现，在每次数据传输中使用的数据总线字节位置（byte
line）不同，尽管数据以字节为单位，分为多个周期传输，但是数据的位置仍与其地址对应。D[7:0]将写入起始地址
0x0，故位于最低字节。D[15:8] 将写入地址 0x1，故位于次低字节。</p>
<p>个人理解该设计的意义在于，当主机是因为从机或者其他客观条件限制，需要进行窄传输时，可以一次性将数据放置于数据总线上，只需在每次传输期间改变
WSTRB 信号即可。以上图为例，主机将 D[31:0]
防置于总线，在接下来的四个周期中，仅需对 WSTRB 进行移位，即可依次完成 4
个字节的传输。</p>
<p>该结构<strong>有利于 memory
类型的从机进行写入处理</strong>，这里设想一种实现方式，结合下图讲解，在
64bit 位宽的总线上进行 32bit 位宽传输，起始地址为 0x4
。此时假设存储介质位宽与总线位宽一致，为 64 bit。</p>
<p>在 transfer 1st 中，从机获取整个总线上的 64bit
数据存储至存储介质中，比如 DDR，并利用 wstrb 作为 mask 信号屏蔽无效的低
32 bit（比如 DDR 的 DQM 信号）。这时候存储介质的写入地址为
0x0，但实际只从地址 0x4 开始写入了 32bit 数据。在后续的 transfer
继续按以上模式工作。窄传输中通过主机来调整有效数据的字节位置，以及给出字节有效信号
WSTRB，能够使从机无需进行数据重组等工作。</p>
<figure>
<img src="总线.assets/v2-57c3410645d9a3c2f41a0138be9ab826_1440w.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>注意</strong>：协议未规定窄传输中从机的具体实现，这里举了一个设想的例子</p>
<p>在读传输中，从机的操作逻辑与写传输中的主机相同，但是从机没有类似
WSTRB
的信号。所以<strong>需要主机根据突发传输宽度与总线位宽，计算当前总线中有效数据所在字节位置，读取数据</strong>。</p>
<p>协议规定在 INCR 和 WRAP 模式中每次使用的 byte line
必须不同，即<strong>数据位置与地址对应</strong>。而在 FIXED
模式中，整个传输过程使用相同的 byte line（地址不会变）。</p>
<h5 id="unaligned-transfer"><strong>（2）Unaligned
Transfer</strong></h5>
<p>AXI
协议支持地址非对齐的传输，允许突发传输的首字节地址，即起始地址与<strong>突发传输位宽</strong>不对齐。举个例子，总线位宽为
32bit 时，如果起始地址为 0x1002 ，则产生了非对齐现象。与 32bit
位宽总线对齐的地址需要能被 4 整除，即 ADDR[1:0] = 2'b0。</p>
<p><strong>注意</strong>：此处对齐与否应该取决于突发传输的宽度，而不是总线位宽。</p>
<p>对于非对齐传输，主机会进行两项操作：</p>
<ul>
<li>即使起始地址非对齐，也保证<strong>所有传输是对齐</strong>的</li>
<li>在首个 transfer
中增加填充数据，<strong>将首次传输填充至对齐</strong>，填充数据使用
WSTRB 信号标记为无效</li>
</ul>
<p>我们通过几个例子来说明主机具体的工作：</p>
<figure>
<img src="总线.assets/v2-e8aa348f7fbc4a866e902d339175750f_1440w.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>起始地址为 0x1，非对齐，但主机通过添加一字节的填充数据将 transfer 1st
的实际地址调整为对齐的 0x0，并用 WSTRB 信号为 4'b1110
标识出最低字节上无效的填充数据。</p>
<p>在读传输中，从机也按照同样的原则，在读数据中填充无效数据实现对齐，由主机自行分离。</p>
<figure>
<img src="总线.assets/v2-6317343fab92defb85d0cad2117074ff_1440w.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>这个例子是窄传输+非对齐传输，但问题不大，我们根据之前的经验来看下。首先起始地址为不对齐的
0x07 ，所以首先将首个传输填充至与突发传输位宽 32 bit 对齐：0x07 mod
4(byte) = 3 byte</p>
<p>至此非对齐的问题就已经解决了。接下问题就简化为窄传输。32bit 数据在
64bit 总线上传输，根据我们上一节的分析，在 transfer 1st 中 再填充 4
个字节。后续的 transfer 中则遵从窄传输的原则即可。</p>
<h5 id="byte-invarience"><strong>（3）Byte Invarience</strong></h5>
<p>我们来讨论数据传输结构三个问题中的最后一个：混合的大小端模式。</p>
<p><strong>大端</strong>认为：<strong>高字节</strong>（MSB）应该存在<strong>低地址</strong>，而<strong>小端</strong>认为<strong>低字节</strong>（LSB）才应该存在<strong>低地址</strong>。</p>
<p>那么为了能够使大小端模式在存储中共存，AXI
协议设计了一种字节顺序恒定（Byte-invariant）的大小端传输方案。对于存储中包括多个字节的数据结构（单字节自然不存在大小端问题）：</p>
<ul>
<li>无论大小端模式，每个数据结构存储空间的分配方式是相同的</li>
<li>该数据结构按照其大小端模式决定字节存储的地址顺序</li>
<li>在传输过程中不考虑数据结构的大小端，按照字节原先存储的顺序，原样传输并存放至对端</li>
</ul>
<p>该模式的意义在传输双方均不对数据结构的大小端进行解析转换，而严格按照字节的存储顺序进行传输并转存，防止大小端共存产生<strong>数据覆盖</strong>。</p>
<h4 id="读写回复结构"><strong>读写回复结构</strong></h4>
<p>读写传输事务（Transaction）都存在 2bit 位宽的回复信号
RRESP/BRESP，分别存在 4 种回复情况，分别为</p>
<ul>
<li><p>OKAY ，常规访问成功</p></li>
<li><p>EXOKAY，独占访问成功</p></li>
<li><p>SLVERR，从机错误，尽管从机接收到了访问请求，但因为种种原因向主机返回了一个错误状态，AXI
传输事务的回复由应用具体决定，可能包括以下错误场景：</p></li>
<li><ul>
<li>FIFO 或者缓冲区溢出</li>
<li>主机发起了不支持的传输位宽</li>
<li>尝试向读保护的地址写入数据</li>
<li>超时</li>
</ul></li>
<li><p>DECERR，解码错误，一般由 interconnect
组件产生，表示主机发送的传输事务地址无效，无法将传输事务发送给某个从机。</p></li>
</ul>
<p><strong>注意</strong>：在写传输事务中，单个写回复针对的是整个
burst，而不是 burst 中单个
transfer。但是在读传输事务中，从机可以为突发传输中每一个读传输数据产生不同的读回复信号。</p>
<h3 id="事务类型与属性">事务类型与属性</h3>
<p>AXI 协议中定义了一组信号表示读写传输事务的类型，分别为 ARCACHE 以及
AWCACHE，合称为 AXCACHE。两者控制了</p>
<ul>
<li>传输事务在整个系统中如何进行（How a transaction progresses through
the system）</li>
<li>系统缓存对传输事务的操作（How any system-level caches handle the
transaction）</li>
</ul>
<p>AXI 协议中存在两类从机：存储从机（Memory
Slave）与外设从机（Peripheral Slave）。</p>
<p>我们协议中传输事务属性主要是为存储从机准备，<strong>存储从机必须支持所有的事务属性信号</strong>。而对于外设从机，支持哪些属性信号，就看着办了，协议只有一个要求：外设从机必须完成整个传输事务，哪怕存在其不支持的某个事务属性信号。</p>
<p>外设从机对于属性信号的支持以及相应的访问方式由具体实现决定，一般设计者会将支持的方式列于该从机的规格书中，从机也只对所支持访问方式进行正确响应。极端情况下，从机接收到一个不支持的访问方式，这是可以的。但是一定要完成这次的传输事务，以防止整个系统死锁。协议也不要求从机支持复活机制。（continued
correct operation is <strong>not required</strong>）</p>
<h4 id="系统级缓存">系统级缓存</h4>
<p><strong>注意：AXI
协议缓存相关机制是针对处理器的系统级缓存的一种实现</strong></p>
<p>所谓系统级缓存（system level
cache）区别于处理器内部的缓存，系统级缓存提高整个系统访问外部存储的速度。当系统级缓存连接在处理器核与外部存储之间时，可以被看做处理器核外部的
L2 缓存，如下图所示</p>
<figure>
<img src="总线.assets/v2-eb053295f403d5230c57f64f63f1e228_1440w.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>处理器核、系统缓存以及外部存储控制器通过 AXI 总线接口互联。L1
缓存位于处理器核内部。当处理器访问外部存储中的数据，在 L1
缓存中缺失时，向外部缓存发起传输事务。传输事务在通过系统缓存时，如果该事务命中缓存表项，即可直接得到结果，避免访问外部存储带来的缺失代价。</p>
<h4 id="存储相关属性信号">存储相关属性信号</h4>
<h2 id="axi-vip">AXI VIP</h2>
<p>AXI Verification IP (AXI VIP) 是支持用户对 AXI4 和 AXI4-Lite
进行仿真的 IP。它还可作为 AXI Protocol Checker 来使用。</p>
<p>此IP只是仿真IP，将不进行综合（它将在Pass-through配置中被连线所替代）。</p>
<p>AXI VIP IP 核用途如下：</p>
<ul>
<li><p>生成 Master AXI 指令和写内容</p></li>
<li><p>生成 Slave AXI 读内容和写响应</p></li>
<li><p>检查 AXI 传输是否符合协议标准</p></li>
</ul>
<p>它支持 5 种不同配置：</p>
<ul>
<li><p>AXI Master VIP</p></li>
<li><p>AXI Pass-through VIP（无/有内存模型）</p></li>
<li><p>AXI Slave VIP（无/有内存模型）</p></li>
</ul>
<h1 id="soc-simulator">SoC Simulator</h1>
<p>一个简单易用的软件定义AXI Slave设备框架</p>
]]></content>
      <categories>
        <category>IC</category>
      </categories>
      <tags>
        <tag>AXI</tag>
        <tag>PCle</tag>
      </tags>
  </entry>
  <entry>
    <title>智能计算系统</title>
    <url>/2022/10/19/%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="第一章概述">第一章：概述</h1>
<p><strong>智能计算系统是智能的物质载体</strong></p>
<p>学习目标：学习人工智能系统的设计与研究，掌握对智能计算的完整软硬件技术栈。</p>
<h2 id="人工智能三个流派">人工智能三个流派</h2>
<p><strong>行为主义</strong>：基于控制论，构建感知-动作型控制系统
<strong>符号主义</strong>：基于符号逻辑的方法，用逻辑表示知识和求解问题
<strong>连接主义</strong>：基于大脑中神经元细胞连接的计算模型，用<strong>人工神经网络</strong>来<strong>拟合</strong>智能行为</p>
<span id="more"></span>
<h2 id="深度学习的局限性">深度学习的局限性</h2>
<p>深度学习是一把梯子，而不是火箭</p>
<ul>
<li>泛化能力有限</li>
<li>缺乏推理能力</li>
<li>缺乏可解释性</li>
<li>鲁棒性欠佳</li>
</ul>
<h2 id="异构智能计算系统">异构智能计算系统</h2>
<p>满足智能计算的算力增长需求，降低能耗比</p>
<h1 id="第二章神经网络基础">第二章：神经网络基础</h1>
]]></content>
      <categories>
        <category>基础课程</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>计算机体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>梅森旋转算法</title>
    <url>/2022/11/11/%E6%A2%85%E6%A3%AE%E8%9E%BA%E6%97%8B%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="背景知识">背景知识</h1>
<p>梅森数：形如<span
class="math inline">\(2^p－1\)</span>的一类数，指数p是素数，常记为Mp。</p>
<p>梅森素数：是素数的梅森数，就称为梅森素数</p>
<p>真随机数：使用物理现象产生的：比如掷钱币、骰子、转轮、使用电子元件的噪音、核裂变等等，这样的随机数发生器叫做物理性随机数发生器。</p>
<p>伪随机数：按照一定算法模拟产生的，其结果是确定的，是可见的。我们可以这样认为这个可预见的结果其出现的概率是100%。用计算机随机函数所产生的“随机数”并不随机，是伪随机数。</p>
<span id="more"></span>
<p>本原多项式：一个 m 阶的不可约多项式 <span
class="math inline">\(\large f(x)\)</span>，如果 <span
class="math inline">\(\large f(x)\)</span> 整除 <span
class="math inline">\(\large x^n+ 1\)</span>的最小正整数 n 满足 <span
class="math inline">\(n = 2^m − 1\)</span> ，则该多项式是本原的。</p>
<figure>
<img src="梅森螺旋算法.assets/OIP-C.jpeg" alt="查看源图像" />
<figcaption aria-hidden="true">查看源图像</figcaption>
</figure>
<p>线性反馈移位寄存器LFSR：</p>
<p><img src="梅森螺旋算法.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdHRsZV9zb2xkaWVy,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述" style="zoom: 33%;" /></p>
<p>r级线性反馈移位寄存器唯一地表达为𝑟次幂的多项式<span
class="math inline">\(G(x)=\sum_{i=0}^r{g_ix^i}, g_0=g_r=1\)</span></p>
<h1 id="梅森螺旋">梅森螺旋</h1>
<p><a
href="http://www.math.sci.hiroshima-u.ac.jp/m-mat/MT/emt.html">Mersenne
Twister: A random number generator (since 1997/10)</a></p>
<p>Mersenne
Twister这个名字来自周期长度通常取Mersenne素数这样一个事实。常见的有两个变种Mersenne
Twister MT19937和Mersenne Twister MT19937-64。</p>
<p>Mersenne Twister算法的原理：Mersenne
Twister算法是利用线性反馈移位寄存器(LFSR)产生随机数的，LFSR的反馈函数是寄存器中某些位的简单异或。</p>
<p>一个n位的LFSR在重复之前最多产生<span
class="math inline">\(2^n-1\)</span>位的伪随机序列。只有具有一定抽头序列的LFSR才能产生<span
class="math inline">\(2^n-1\)</span>位长的伪随机序列。为了使LFSR成为最大周期的LFSR，由抽头序列加上常数1形成的多项式必须是本原多项式。例如(32,7,5,3,2,1,0)是指本原多项式<span
class="math inline">\(x^{32}+x^7+x^5+x^3+x^2+x+1\)</span>，把它转化为最大周期LFSR就是在LFSR的第32，7，5，2，1位抽头。利用上述两种方法产生周期为m的伪随机序列后，只需要将产生的伪随机序列除以序列的周期，就可以得到(0，1)上均匀分布的伪随机序列了。</p>
<p>Mersenne
Twister优点：随机性好，在计算机上容易实现，占用内存较少(MT19937的C代码执行仅需624个字的工作区域)，与其它已使用的伪随机数发生器相比，产生随机数的速度快、周期长，可达到2^19937-1，且具有623维均匀分布的性质，序列关联比较小，能通过很多随机性测试。</p>
<p><strong>其他随机数产生器性能对比</strong></p>
<figure>
<img src="梅森螺旋算法.assets/ce74efc0d7db44589e385feaa8b75832.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h1 id="verilog实现">Verilog实现</h1>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>梅森素数</tag>
        <tag>伪随机数</tag>
      </tags>
  </entry>
  <entry>
    <title>版图</title>
    <url>/2022/12/11/%E7%89%88%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="bb">bb</h1>
<h1 id="mos管结构">MOS管结构</h1>
<figure>
<img src="版图.assets/152627yr8abtq6dp6q8pbq.png" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>NWELL：</strong>N阱</p>
<p><strong>GT：</strong>poly，多晶硅栅</p>
<p><strong>SP：</strong>P+，</p>
<p><strong>SN：</strong>N+</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>版图</tag>
      </tags>
  </entry>
  <entry>
    <title>高速缓存与一致性</title>
    <url>/2022/11/26/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    <content><![CDATA[<h1 id="cache的基本原理">Cache的基本原理</h1>
<p>Cache指的是高速缓存简称缓存，原始意义是指访问速度比一般随机存取存储器（RAM）快的一种RAM，通常它不像系统主存那样使用DRAM技术，而使用昂贵但较快速的SRAM技术。</p>
<p>在CPU中，Cache是介于内存和处理器之间的缓存，用于存放CPU即将可能使用的数据，当CPU要使用的数据在Cache中取到时，便不再需要到内存去存取数据，从而减少处理器访问内存的次数。
提供“缓存”的目的是为了让数据访问的速度适应CPU的处理速度，由于CPU的运行速度远快于存储器的存储速度，当处理器通过内存存取一次数据将耗费数十个时钟周期，而处理器访问Cache则只需要一个或者几个时钟周期，所以Cache的出现极大的减小了CPU运行速度和存储速度的差距。设想一下一个主频2GHz的4-way超标量处理器访问一个100ns的DRAM,
在访问一次DRAM时间内，处理器内部可以执行800条指令，这是不可以接受的，所以就有了和处理器一样工艺制造的L1Cache，紧密耦合在处理器内，得以让处理器能够直接访问Cache得到数据。虽然Cache能极大的提升处理器的性能，但是在一块芯片中，Cache的容量大小一般只有1KB到32KB，而这相较于内存存储的几个GB甚至TB的数据来说，Cache的容量是微乎其微的,Cache只能缓存内存的一小部分数据，但是Cache依然能够让处理器取到大部分需要的数据，其中的原理是内存中“程序执行与数据访问的局域性行为”，即一定程序执行时间和空间内，被访问的代码集中于一部分，所以Cache中缓存的数据都是被近期访问过数据或者可能会被访问的数据，这样就使得Cache的命中率大大提高。</p>
<figure>
<img
src="高速缓存与一致性.assets/v2-bc15d8c0612599fc3de51c4382e07aa5_r.jpg"
alt="v2-bc15d8c0612599fc3de51c4382e07aa5_r" />
<figcaption
aria-hidden="true">v2-bc15d8c0612599fc3de51c4382e07aa5_r</figcaption>
</figure>
<span id="more"></span>
<p>CPU要访问的数据在cache中有缓存，称为“命中” (hit)，反之则称为“缺失”
(miss)。</p>
<p><strong>cache size</strong>：ache可以缓存最大数据的大小。</p>
<p><strong>cache line
size</strong>：将cache平均分成相等的很多块，块的大小。</p>
<p>cache
line是cache和主存之间数据传输的最小单位。当CPU试图load一个字节数据的时候，如果cache缺失，那么cache控制器会从主存中一次性的load
cache line size的数据到cache中。若cache
line大小是8字节，CPU即使读取一个byte，在cache缺失后，cache会从主存中load
8字节填充整个cache line。</p>
<p><strong>以下均以8 Bytes的cache line、64
Bytes的cache为例。</strong></p>
<figure>
<img
src="高速缓存与一致性.assets/v2-3e0de5f8b95e27dbd41328c9d089224c_1440w.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="多级cache存储结构">多级cache存储结构</h2>
<p>cahe的速度在一定程度上同样影响着系统的性能。一般情况cache的速度可以达到1ns，几乎可以和CPU寄存器速度媲美。但是，这就满足人们对性能的追求了吗？并没有。当cache中没有缓存我们想要的数据的时候，依然需要漫长的等待从主存中load数据。为了进一步提升性能，引入多级cache。前面提到的cache，称之为L1
cache（第一级cache）。我们在L1 cache 后面连接L2 cache，在L2 cache
和主存之间连接L3
cache。等级越高，速度越慢，容量越大。但是速度相比较主存而言，依然很快。不同等级cache速度之间关系如下：</p>
<figure>
<img
src="高速缓存与一致性.assets/v2-0910f3308b1d0e425c308307869a3f68_1440w.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>在Cortex-A53架构上，L1 cache分为单独的instruction
cache（ICache）和data cache（DCache）。L1
cache是CPU私有的，每个CPU都有一个L1 cache。一个cluster
内的所有CPU共享一个L2 cache，L2
cache不区分指令和数据，都可以缓存。所有cluster之间共享L3 cache。L3
cache通过总线和主存相连。</p>
<figure>
<img
src="高速缓存与一致性.assets/v2-155a251f204f87982b21b742002ef136_1440w.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="多级cache之间的配合工作">多级cache之间的配合工作</h2>
<p>假设现在考虑的系统只有两级cache。当CPU试图从某地址load数据时，首先从L1
cache中查询是否命中，如果命中则把数据返回给CPU。如果L1
cache缺失，则继续从L2 cache中查找。当L2 cache命中时，数据会返回给L1
cache以及CPU。如果L2
cache也缺失，很不幸，我们需要从主存中load数据，将数据返回给L2 cache、L1
cache及CPU。这种多级cache的工作方式称之为<strong>inclusive
cache</strong>。</p>
<p><strong>inclusive
cache</strong>：某一地址的数据可能存在多级缓存中。</p>
<p><strong>exclusive
cache</strong>：某一地址的数据缓存只会存在于多级cache其中一级。</p>
<figure>
<img
src="高速缓存与一致性.assets/v2-4974c1f109f00f887fceda68b37bd3f5_1440w.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="直接映射缓存direct-mapped-cache">直接映射缓存(Direct mapped
cache)</h2>
<p>假设CPU从0x0654地址读取一个字节。如何根据地址在有限大小的cache中查找数据呢？采取的做法是对地址进行散列。</p>
<p>利用地址低3 bits用来寻址8
Bytes中某一字节，我们称这部分bit组合为offset。</p>
<p>同理，8行cache line，需要3
bits查找某一行，这部分地址部分称之为index。</p>
<p>当我们找到cache line之后，访问的地址对应的数据可能存在这个cache
line中，但是也有可能是其他地址对应的数据。所以引入tag ,每一个cache
line都对应唯一一个tag，tag中保存的是整个地址位宽去除index和offset使用的bit剩余部分。tag也是cache的一部分，但是我们谈到cache
size的时候并不考虑tag占用的内存部分。</p>
<p>valid bit：用来表示cache line中数据是否有效。</p>
<p>tag、index和offset三者组合就可以唯一确定一个地址了。首先根据地址中index位找到cache
line后，检查valid bit是否有效，若有效再取出当前cache
line对应的tag和地址中的tag进行比较，如果相等，这说明cache命中。</p>
<figure>
<img
src="高速缓存与一致性.assets/v2-e8deb539258684ad9d4dffef08b02c09_1440w.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>直接映射缓存在硬件设计上更加简单，成本上较低。根据直接映射缓存的工作方式，主存地址0x00-0x88地址对应的cache分布图。如果依次访问地址0x00、0x40、0x80，这3个地址对应的cache
line是同一个。当我们访问0x00地址时，cache会缺失，当我们访问0x40地址时，索引到cache中第0行cache
line，存储的是地址0x00地址对应的数据，所以此时依然会cache缺失。然后从主存中加载0x40地址数据到第一行cache
line中。继续访问0x80地址，依然会cache缺失。这种现象叫做cache
thrashing。针对这个问题，我们引入多路组相连缓存。</p>
<figure>
<img
src="高速缓存与一致性.assets/v2-b3d111caabc93c638bb08bde5026d711_1440w.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2
id="两路组相连缓存two-way-set-associative-cache">两路组相连缓存(Two-way
set associative cache)</h2>
<p>路（way）：将cache平均分成多份，每一份就是一路。两路组相连缓存就是将cache平均分成2份，每份32
Bytes。</p>
<figure>
<img
src="高速缓存与一致性.assets/v2-4653656ec3d4d5942bae805df6723690_1440w.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>cache被分成2路，每路包含4行cache line。我们将所有索引一样的cache
line组合在一起称之为set。例如，上图中一个组有两个cache
line，总共4个set。我们依然假设从地址0x0654地址读取一个字节数据。在两路组相连缓存中，index只需要2
bits，因为一路只有4行cache line。上面的例子根据index找到第2行cache
line，第2行对应2个cache line，分别对应way 0和way
1。因此index也可以称作set
index（组索引）。先根据index找到set，然后将组内的所有cache
line对应的tag取出来和地址中的tag部分对比，如果其中一个相等就意味着命中。</p>
<p>因此，两路组相连缓存较直接映射缓存最大的差异就是：第一个地址对应的数据可以对应2个cache
line，而直接映射缓存一个地址只对应一个cache
line。那么这究竟有什么好处呢？</p>
<p>两路组相连缓存的硬件成本相对于直接映射缓存更高。因为其每次比较tag的时候需要比较多个cache
line对应的tag，但可以有助于降低cache颠簸可能性。根据两路组相连缓存的工作方式，我们可以画出主存地址0x00-0x4f地址对应的cache分布图。</p>
<figure>
<img
src="高速缓存与一致性.assets/v2-9db10cd5b86e5a10f08980ab1d1cfc07_1440w.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>如果一个程序试图依次访问地址0x00、0x40、0x80。现在0x00地址的数据可以被加载到way
1，0x40可以被加载到way
0。在两路组相连缓存的情况下，0x00和0x40地址的数据都缓存在cache中。<strong>当cache
size一定的情况下，组相连缓存对性能的提升最差情况下也和直接映射缓存一样，在大部分情况下组相连缓存效果比直接映射缓存好。</strong>同时，其降低了cache颠簸的频率。从某种程度上来说，直接映射缓存是组相连缓存的一种特殊情况，每个组只有一个cache
line而已。因此，直接映射缓存也可以称作单路组相连缓存。</p>
<h2 id="全相连缓存full-associative-cache">全相连缓存(Full associative
cache)</h2>
<p>全相连缓存，所有的cache line都在一个组内</p>
<figure>
<img
src="高速缓存与一致性.assets/v2-1e61e8d13030ed4f0b42c2d1a854ffce_1440w.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>由于所有的cache line都在一个set内，因此地址中不需要set
index部分。我们根据地址中的tag部分和所有的cache
line对应的tag进行比较。哪个tag比较相等，就意味着命中某个cache
line。因此，在全相连缓存中，任意地址的数据可以缓存在任意的cache
line中。所以，这可以最大程度的降低cache颠簸的频率。但是硬件成本上也是更高。</p>
<h2 id="cache分配策略cache-allocation-policy">Cache分配策略(Cache
allocation policy)</h2>
<p>cache的分配策略是指我们什么情况下应该为数据分配cache
line。cache分配策略分为读和写两种情况。</p>
<h3 id="读分配read-allocation">读分配(read allocation)</h3>
<p>当CPU读数据时，发生cache缺失，这种情况下都会分配一个cache
line缓存从主存读取的数据。默认情况下，cache都支持读分配。</p>
<h3 id="写分配write-allocation">写分配(write allocation)</h3>
<p>当CPU写数据发生cache缺失时，才会考虑写分配策略。当不支持写分配时，写指令直接更新主存数据。当支持写分配时，首先从主存中加载数据到cache
line中（相当于先做个读分配动作），然后会更新cache line中的数据。</p>
<h2 id="cache更新策略cache-update-policy">Cache更新策略(Cache update
policy)</h2>
<p>cache更新策略是指当发生cache命中时，写操作应该如何更新数据。cache更新策略分成两种：写直通和回写。</p>
<h3 id="写直通write-through">写直通(write through)</h3>
<p>当CPU执行store指令并在cache命中时，我们更新cache中的数据并且更新主存中的数据。<strong>cache和主存的数据始终保持一致</strong>。</p>
<h3 id="写回write-back">写回(write back)</h3>
<p>当CPU执行store指令并在cache命中时，我们只更新cache中的数据。并且每个cache
line中会有一个bit位记录数据是否被修改过，称之为<strong>dirty
bit</strong>。我们会将dirty bit置位。主存中的数据只会在cache
line被替换或者显示的clean操作时更新。因此，主存中的数据可能是未修改的数据，而修改的数据躺在cache中。<strong>cache和主存的数据可能不一致。</strong></p>
<p>同时思考个问题，为什么cache
line大小是cache控制器和主存之间数据传输的最小单位呢？这也是因为每个cache
line只有一个dirty bit。这一个dirty bit代表着整个cache
line是否被修改的状态。</p>
<p>cache控制器根据地址查找判断是否命中，这里的地址究竟是虚拟地址(virtual
address，VA)还是物理地址(physical
address，PA)？我们应该清楚CPU发出对某个地址的数据访问，这个地址其实是虚拟地址，虚拟地址经过MMU转换成物理地址，最终从这个物理地址读取数据。因此cache的硬件设计既可以采用虚拟地址也可以采用物理地址甚至是取两者地址部分组合作为查找cache的依据。</p>
<h2 id="虚拟高速缓存vivt">虚拟高速缓存(VIVT)</h2>
<p>我们首先介绍的是虚拟高速缓存，这种cache硬件设计简单。在cache诞生之初，大部分的处理器都使用这种方式。虚拟高速缓存以虚拟地址作为查找对象。</p>
]]></content>
      <categories>
        <category>Arch</category>
      </categories>
      <tags>
        <tag>PCle</tag>
        <tag>Cache</tag>
      </tags>
  </entry>
</search>
