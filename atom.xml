<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mai&#39;s blog</title>
  
  <subtitle>try my best</subtitle>
  <link href="https://zmailee.github.io/atom.xml" rel="self"/>
  
  <link href="https://zmailee.github.io/"/>
  <updated>2022-11-10T07:44:07.848Z</updated>
  <id>https://zmailee.github.io/</id>
  
  <author>
    <name>zmaiLee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SynopsysEDA</title>
    <link href="https://zmailee.github.io/2022/11/10/SynopsysEDA/"/>
    <id>https://zmailee.github.io/2022/11/10/SynopsysEDA/</id>
    <published>2022-11-10T07:20:14.357Z</published>
    <updated>2022-11-10T07:44:07.848Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><strong>Design Compiler</strong> for the synthesis,</p></li><li><p><strong>ICC Compiler</strong> for the layout</p></li><li><p><strong>PrimeTime PX</strong> for estimating the powerconsumption</p></li></ul><span id="more"></span><h1 id="第一章design-compiler使用">第一章：Design Compiler使用</h1><h2 id="综合">1.1综合</h2><p>Systhesis = Translation(转换) + G ate M apping(映射) + Logic O ptimization(优化)</p><ul><li>Tranlation：把电路转换为ED A 内部数据</li><li>Mapping：将门级网表映射到晶圆厂给定的工艺库上，形成对应的门级网表</li><li>Optimization：根据工作频率、面积、功耗来对电路进行优化，推断出满足要求的门级网表</li></ul><h2 id="逻辑综合流程">1.2逻辑综合流程</h2><p>1.读取库和设计：包括目标库、链接库、符号库等</p><p>2.添加时序约束和设计规则约束：包括环境约束、面积约束、时序约束等</p><p>3.综合RTL设计：将RTL代码转换为用标准单元表示的门级网表</p><p>4.分析结果</p><p>5.输出设计数据</p><h2 id="command">1.3Command</h2><h3 id="打开-d-c">打开 D C</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">design_vision //GUI界面<br>dc_shell -f syn.tcl | <span class="hljs-built_in">tee</span> -i syn.log //批量模式(batch mode)<br>dc_shell //命令行模式<br></code></pre></td></tr></table></figure><h3 id="读取verilog设置顶层">读取verilog，设置顶层</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">read_verilog xxx.v<br>current_design TOP(设置最顶层的模块)<br></code></pre></td></tr></table></figure><h3 id="设置路径search_path">设置路径：search_path</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">set_app_var search_path <span class="hljs-string">&quot;<span class="hljs-variable">$search_path</span> ./rtl&quot;</span><br></code></pre></td></tr></table></figure><h3 id="建立库library_setup">建立库：library_setup</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">//target library(工艺库) <br>set_app_var target_library xxx.db<br><br>//link library(链接库) <br>set_app_var link_library xxx.db<br>set_app_var link_library <span class="hljs-string">&quot;<span class="hljs-variable">$target_library</span>&quot;</span><br></code></pre></td></tr></table></figure><h3 id="约束">约束</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">//时序约束<br>create_clock -period 2 [get_ports CLK] //clock period 2ns<br>set_clock uncertainty -setup 0.3 [get_ports CLK] //clock skew<br>set_clock transition -max 0.15 [get_ports CLK] //CLK跳转最大时间为0.15ns<br>set_clock_latency -max 0.7 [get_ports CLK] //晶振到CLK端口所需最大时间为0.7ns<br>set_input_delay -max 0.6 -clock CLK [get_ports A] //A端口数据到寄存器输入时延<br>set_out_put -max 0.8 -clock CLK [get_ports B] //寄存器输出到B端口的时延<br><br>//环境约束<br>set_input_transition 0.12 [get_ports A] //输入端口A的电平跳变时间0.12ns<br>set_load [<span class="hljs-built_in">expr</span>&#123;30.0/1000&#125;] [get_ports B]<br></code></pre></td></tr></table></figure><h3 id="编译">编译</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">compile<br>compile_utra<br></code></pre></td></tr></table></figure><h3 id="输出信息">输出信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">report_clock<br>report_timing<br>write_sdc xxx.sdc//输出约束条件<br>write_sdf xxx.sdf//输出时延信息<br>write_file -format verilog -output xxx_netlist.v//输出网表文件<br></code></pre></td></tr></table></figure><h1 id="第二章icc-compiler">第二章：ICC Compiler</h1><h1 id="第二章primetime-px">第二章：PrimeTime PX</h1>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Design Compiler&lt;/strong&gt; for the synthesis,&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;ICC Compiler&lt;/strong&gt; for the layout&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;PrimeTime PX&lt;/strong&gt; for estimating the power
consumption&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="工具" scheme="https://zmailee.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="EDA" scheme="https://zmailee.github.io/tags/EDA/"/>
    
    <category term="数字IC" scheme="https://zmailee.github.io/tags/%E6%95%B0%E5%AD%97IC/"/>
    
  </entry>
  
  <entry>
    <title>IC后端</title>
    <link href="https://zmailee.github.io/2022/11/09/IC%E5%90%8E%E7%AB%AF/"/>
    <id>https://zmailee.github.io/2022/11/09/IC%E5%90%8E%E7%AB%AF/</id>
    <published>2022-11-09T03:35:24.612Z</published>
    <updated>2022-11-09T03:55:44.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章标准单元库">第一章：标准单元库</h1><h2 id="hvtsvtlvt">HVT/SVT/LVT</h2><p>High Vt、Standard Vt（也有称为Regular Vt，即RVT)、LowVt。Vt阈值电压越低，因为饱和电流变小，所以速度性能越高；但是因为漏电流会变大，因此功耗会变差。</p><span id="more"></span><h2 id="pvt">PVT</h2><p>Process、Voltage、Temperature</p><h2 id="multi-channel-library">multi-channel library</h2><p>对应不同的gate-length，即沟道长度。例如，UMC28nm的SVTmin 相对SVTmax，性能增加20%，静态功耗增加80%。</p><h2 id="t9t12t">7T/9T/12T</h2><p>T，代表track，是单元库的版图规则，作为一个计量单位。</p><p>7T/9T/12T分别对应ultra-high-density（for lowest power in SOCblocks）、high-density（for highest density in GPUblocks）、high-speed（for highest performance in CPU blocks）。</p><p>标准单元库的单元高度，基本都是固定的，方便版图的布局；高度，通常以track作为计量单位pitch=minSpacing+minWidth。</p><p>grid是单元库里，与工艺制造精度相关的名称。一般pin都放置在grid上，工艺在版图上的最小精度。</p><figure><img src="IC后端.assets/SouthEast.png" alt="这里写图片描述" /><figcaption aria-hidden="true">这里写图片描述</figcaption></figure><h2 id="推荐的单元库选择方法">推荐的单元库选择方法</h2><p><img src="IC后端.assets/SouthEast-16679659616183.png"alt="img" /><strong>HLP</strong>，high performance low power；<strong>HPC</strong>，high performace compact。28nmHLP的core电压，是1.05V；HPC的core电压，则是0.9V。</p><figure><img src="IC后端.assets/SouthEast-16679660832146.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;第一章标准单元库&quot;&gt;第一章：标准单元库&lt;/h1&gt;
&lt;h2 id=&quot;hvtsvtlvt&quot;&gt;HVT/SVT/LVT&lt;/h2&gt;
&lt;p&gt;High Vt、Standard Vt（也有称为Regular Vt，即RVT)、Low
Vt。Vt阈值电压越低，因为饱和电流变小，所以速度性能越高；但是因为漏电流会变大，因此功耗会变差。&lt;/p&gt;</summary>
    
    
    
    <category term="基础课程" scheme="https://zmailee.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="人工智能" scheme="https://zmailee.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="计算机体系结构" scheme="https://zmailee.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习笔记</title>
    <link href="https://zmailee.github.io/2022/11/02/linux/"/>
    <id>https://zmailee.github.io/2022/11/02/linux/</id>
    <published>2022-11-02T07:11:43.295Z</published>
    <updated>2022-11-04T05:27:00.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="添加环境变量"><strong>1.添加环境变量</strong></h2><p>https://www.cnblogs.com/youyoui/p/10680329.html</p><p>1、Linux的环境变量是保存在变量PATH中</p><ul><li><strong>export</strong>命令显示当前系统定义的所有环境变量</li><li><strong>echo $PATH</strong>命令输出当前的PATH环境变量的值</li></ul><p>2、Linux环境变量值之间是通过冒号分隔的( : )</p><p><strong>临时添加环境变量PATH：</strong>可通过export命令，如将/usr/local/nginx/sbin/目录临时添加到环境变量中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=/usr/local/nginx/sbin/:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><span id="more"></span><h2 id="常用命令">2.常用命令</h2><h3 id="开启全部权限解锁文件">开启全部权限：解锁文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chmod</span> -R 777 xx/xx/xx<br></code></pre></td></tr></table></figure><h3 id="tar命令">tar命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">解压命令:tar -xzvf xxx.tar.gz <br>压缩命令:tar zcvf 文件名.tar.gz 待压缩的文件名<br>//-x 表示 extract， 提取，因为是解压所以使用。<br>//-c 表示压缩，compress<br>//-z 表示先使用 gzip支持压缩或解压缩。其他的压缩或解压缩方式，比如-j表示bzip2的方式<br>//-v 表示 verbose，在压缩或解压缩过程中显示正在处理的文件名<br>//-f 表示 file，指定要处理的 tar 包<br>//-C 可以指定输出目录,默认是解压到当前目录<br><br></code></pre></td></tr></table></figure><h2 id="git">3.git</h2><p>When you want to commit the change, type</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit --allow-empty -am <span class="hljs-string">&quot;提交备注&quot;</span><br></code></pre></td></tr></table></figure><p>The <code>--allow-empty</code> option is necessary, because usuallythe change is already committed by development tracing system. Withoutthis option, <code>git</code> will reject no-change commits</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 删除本地分支<br>git branch -d localBranchName<br><br>// 删除远程分支<br>git push origin --delete remoteBranchName<br></code></pre></td></tr></table></figure><h2 id="make">4.make</h2><p>通过<code>lscpu</code>命令来查询有多少个CPU.在<code>make</code>时候添加<code>-j?</code>的参数,其中<code>?</code>为你查询到的CPU数量.</p><p>为了查看编译加速的效果, 在编译的命令前面添加<code>time</code>命令,它将会对紧跟在其后的命令的执行时间进行统计。可以通过<code>make clean</code>清除所有的编译结果,然后重新编译并统计时间,</p><h2 id="gdb">5.GDB</h2><h3 id="常用命令-1">常用命令</h3><blockquote><ul><li>start #开始调试,停在第一行代码处,(gdb)start</li><li>finish #执行到函数retun返回</li><li>bt（backtrace） #列出调用栈</li><li>info locals #列出当前函数的局部变量</li><li>l #list的缩写查看源代码,(gdb) l [number/function]</li><li>watch var_name #追踪变量</li><li>b <lines> #b: Breakpoint的简写，<strong>设置断点</strong>。(gdb) b10</li><li>b <func> #b: Breakpoint的简写，设置断点。(gdb) b main</li><li>b filename:[line/function]#b:在文件filename的某行或某个函数处设置断点</li><li>i breakpoints #i:info 的简写。(gdb)i breakpoints</li><li>d [bpNO] #d: Deletebreakpoint，删除指定编号的某个断点，或删除所有断点。(gdb)d 1</li><li>s #s:step执行一行源程序代码，如果此行代码中有函数调用，<strong>则进入该函数</strong>；(gdb)s</li><li>n #n:next执行一行源程序代码，此行<strong>代码中的函数调用也一并执行</strong>。(gdb)n</li><li>r#run，运行被调试程序。如果没有下断点，则执行完；如果有断点，则程序暂停在第一个断点处。</li><li>c#continue的简写，继续执行被调试程序，直至下一个断点或程序结束。</li><li>p [var]#Print的简写，<strong>显示指定变量</strong>（临时变量或全局变量 例如 inta）<strong>的值</strong>。(gdb) p a</li><li>display [var] #display，设置想要跟踪的变量(例如 int a)。(gdb)display a</li><li>undisplay [varnum]#undisplay取消对变量的跟踪，被跟踪变量用整型数标识。(gdb) undisplay1</li><li>set args #可指定运行时参数。(gdb)set args 10 20</li><li>show args #查看运行时参数。</li><li>q #Quit的简写，退出GDB调试环境。(gdb) q</li><li>help [cmd]#GDB帮助命令。如果指定“命令名称”参数，则显示该命令的详细说明；如果没有指定参数，则分类显示所有GDB命令(gdb)help</li><li>回车 #重复前面的命令，(gdb)回车</li></ul></blockquote><hr /><h3 id="man命令">man命令</h3><table><colgroup><col style="width: 4%" /><col style="width: 54%" /><col style="width: 42%" /></colgroup><thead><tr class="header"><th>编号</th><th>说明</th><th>解释</th></tr></thead><tbody><tr class="odd"><td>1</td><td>Executable programs or shell commands</td><td><strong>标准Linux命令</strong></td></tr><tr class="even"><td>2</td><td>System calls(functions provided by the kernel)</td><td><strong>系统调用（内核）</strong></td></tr><tr class="odd"><td>3</td><td>Library functions(functions within program 1 ibraries)</td><td><strong>库函数</strong></td></tr><tr class="even"><td>4</td><td>Special devices(usually found in /dev</td><td><strong>设备说明</strong>（通常在/dev下可以找到）</td></tr><tr class="odd"><td>5</td><td>File formats and conventions eg /etc/ passwd</td><td><strong>文件格式</strong></td></tr><tr class="even"><td>6</td><td>Games</td><td>游戏娱乐等</td></tr><tr class="odd"><td>7</td><td>Miscellaneous</td><td>杂乱项</td></tr><tr class="even"><td>8</td><td>System administration commands</td><td><strong>系统管理员命令</strong>（通常针对<strong>root</strong>用户）</td></tr><tr class="odd"><td>9</td><td>Kernel routines</td><td>常规<strong>内核</strong>文件</td></tr></tbody></table><p>编号 说明 解释 1 Executable programs or shell commands 标准Linux命令2 System calls 系统调用（内核） 3 Library functions 库函数 4 Specialdevices 设备说明（通常在/dev下可以找到） 5 File formats 文件格式 6 Games游戏娱乐等 7 Miscellaneous 杂乱项 8 System administration commands系统管理员命令（通常针对root用户） 9 Kernel routines 常规内核文件</p><h3 id="list命令">list命令</h3><blockquote><p>list，显示当前行后面的源程序。</p><p>list - ，显示当前行前面的源程序</p><p>list <linenum> ，显示程序第linenum行周围的源程序</p><p>list <function> ，显示函数名为function的函数的源程序</p></blockquote><h3 id="break命令">break命令</h3><ul><li><p>break <function>在进入指定函数时停住</p></li><li><p>break <linenum>在指定行号停住</p></li><li><p>break +offset / break-offset在当前行号的前面或后面的offset行停住</p></li><li><p>break filename:linenum在源文件filename的linenum行处停住</p></li><li><p>breakfilename:function在源文件filename的function函数的入口处停住</p></li><li><p>break *address在程序运行的内存地址处停住</p></li><li><p>break表示在下一条指令处停住</p></li><li><p>break ... if <condition>“...”可以是上述的break <linenum>、break+offset / break –offset中的参数，在循环体中，可以设置break ifi=100，表示当i为100时停住程序</p></li><li><p>查看断点时，可使用info命令，如info breakpoints n、info breakn（n表示断点号）</p></li></ul><h3 id="单步命令">单步命令</h3><p>next(n)的单步不会进入函数的内部，</p><p>step(s)命令则在单步执行一个函数时，会进入其内部</p><ul><li>step <count></li></ul><p>单步跟踪，如果有函数调用，则进入该函数（进入函数的前提是，此函数被编译有debug信息）。step后面不加count表示一条条地执行，加表示执行后面的count条指令，然后再停住。</p><ul><li>next <count></li></ul><p>单步跟踪，如果有函数调用，它不会进入该函数。同样地，next后面不加count表示一条条地执行，加表示执行后面的count条指令，然后再停住。</p><ul><li>set step-mode</li></ul><p>set step-modeon用于打开step-mode模式，这样，在进行单步跟踪时，程序不会因为没有debug信息而不停住，这个参数的设置可便于查看机器码。setstep-mod off用于关闭step-mode模式。</p><ul><li>finish</li></ul><p>运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。</p><ul><li>until （缩写u）</li></ul><p>一直在循环体内执行单步，退不出来是一件令人烦恼的事情，until命令可以运行程序直到退出循环体。</p><ul><li>stepi（缩写si）和nexti（缩写ni）</li></ul><p>stepi和nexti用于单步跟踪一条机器指令，一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步执行机器指令。另外，运行“display/i$pc”命令后，单步跟踪会在打出程序代码的同时打出机器指令，即汇编代码。</p><h3 id="continue命令">continue命令</h3><p>当程序被停住后，可以使用continue命令（缩写c，fg命令同continue命令）恢复程序的运行直到程序结束，或到达下一个断点，命令格式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">continue</span> [ignore-count]<br>c [ignore-count]<br>fg [ignore-count]<br></code></pre></td></tr></table></figure><p>ignore-count表示忽略其后多少次断点。假设我们设置了函数断点add()，并watchi，则在continue过程中，每次遇到add()函数或i发生变化，程序就会停住，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) <span class="hljs-keyword">continue</span><br>Continuing.<br>Hardware watchpoint <span class="hljs-number">3</span>: i<br><br>Old value = <span class="hljs-number">2</span><br>New value = <span class="hljs-number">3</span><br><span class="hljs-number">0x0804838d</span> in <span class="hljs-built_in">main</span> () at gdb_example.c:<span class="hljs-number">23</span><br><span class="hljs-number">23</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>(gdb) <span class="hljs-keyword">continue</span><br>Continuing.<br><br>Breakpoint <span class="hljs-number">1</span>, <span class="hljs-built_in">main</span> () at gdb_example.c:<span class="hljs-number">25</span><br><span class="hljs-number">25</span>          sum[i] = <span class="hljs-built_in">add</span>(array1[i], array2[i]);<br>(gdb) <span class="hljs-keyword">continue</span><br>Continuing.<br>Hardware watchpoint <span class="hljs-number">3</span>: i<br><br>Old value = <span class="hljs-number">3</span><br>New value = <span class="hljs-number">4</span><br><span class="hljs-number">0x0804838d</span> in <span class="hljs-built_in">main</span> () at gdb_example.c:<span class="hljs-number">23</span><br><span class="hljs-number">23</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br></code></pre></td></tr></table></figure><h3 id="print命令">print命令</h3><p>在调试程序时，当程序被停住时，可以使用print命令（缩写为p），或是同义命令inspect来查看当前程序的运行数据。print命令的格式是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">print &lt;expr&gt;<br>print /&lt;f&gt; &lt;expr&gt;<br></code></pre></td></tr></table></figure><p><expr>是<ahref="https://so.csdn.net/so/search?q=表达式&amp;spm=1001.2101.3001.7020">表达式</a>，是被调试的程序中的表达式，<f>是输出的格式，比如，如果要把表达式按16进制的格式输出，那么就是/x。在表达式中，有几种GDB所支持的操作符，它们可以用在任何一种语言中，“@”是一个和数组有关的操作符，“::”指定一个在文件或是函数中的变量，“{<type>}<addr>”表示一个指向内存地址<addr>的类型为type的一个对象。</p><p>下面演示了查看sum[]数组的值的过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) print sum<br>$<span class="hljs-number">2</span> = &#123;<span class="hljs-number">133</span>, <span class="hljs-number">155</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;<br>(gdb) next<br><br>Breakpoint <span class="hljs-number">1</span>, <span class="hljs-built_in">main</span> () at gdb_example.c:<span class="hljs-number">25</span><br><span class="hljs-number">25</span>          sum[i] = <span class="hljs-built_in">add</span>(array1[i], array2[i]);<br>(gdb) next<br><span class="hljs-number">23</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>(gdb) print sum<br>$<span class="hljs-number">3</span> = &#123;<span class="hljs-number">133</span>, <span class="hljs-number">155</span>, <span class="hljs-number">143</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;<br></code></pre></td></tr></table></figure><p>当需要查看一段连续内存空间的值的时间，可以使用GDB的“@”操作符，“@”的左边是第一个内存地址，“@”的右边则是想查看内存的长度。例如如下动态申请的内存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prettyprint">int *array = (int *) malloc (len * sizeof (int)); *array = (int *) malloc (len * sizeof (int));<br></code></pre></td></tr></table></figure><p>在GDB调试过程中这样显示出这个动态数组的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prettyprint">p *array@len*array@len<br></code></pre></td></tr></table></figure><p>print的输出格式包括：</p><ul><li>x 按十六进制格式显示变量。</li><li>d 按十进制格式显示变量。</li><li>u 按十六进制格式显示无符号整型。</li><li>o 按八进制格式显示变量。</li><li>t 按二进制格式显示变量。</li><li>a 按十六进制格式显示变量。</li><li>c 按字符格式显示变量。</li><li>f 按浮点数格式显示变量。</li></ul><p>我们可用display命令设置一些自动显示的变量，当程序停住时，或是单步跟踪时，这些变量会自动显示。如果要修改变量，如x的值，可使用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prettyprint">print x=4 x=4<br></code></pre></td></tr></table></figure><p>当用GDB的print查看程序运行时的数据时，每一个print都会被GDB记录下来。GDB会以$1，$2，$3…这样的方式为每一个print命令编号。我们可以使用这个编号访问以前的表达式，如$1。</p><h3 id="watch命令">watch命令</h3><p>watch一般来观察某个表达式（变量也是一种表达式）的值是否有变化了，如果有变化，马上停住程序。我们有下面的几种方法来设置观察点：watch<expr>：为表达式（变量）expr设置一个观察点。一量表达式值有变化时，马上停住程序。rwatch<expr>：当表达式（变量）expr被读时，停住程序。awatch<expr>：当表达式（变量）的值被读或被写时，停住程序。infowatchpoints：列出当前所设置了的所有观察点。下面演示了观察i并在连续运行next时一旦发现i变化，i值就会显示出来的过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) watch i<br>Hardware watchpoint <span class="hljs-number">3</span>: <span class="hljs-built_in">i</span><br>(gdb) next<br><span class="hljs-number">23</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>(gdb) next<br>Hardware watchpoint <span class="hljs-number">3</span>: i<br><br>Old value = <span class="hljs-number">0</span><br>New value = <span class="hljs-number">1</span><br><span class="hljs-number">0x0804838d</span> in <span class="hljs-built_in">main</span> () at gdb_example.c:<span class="hljs-number">23</span><br><span class="hljs-number">23</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>(gdb) next<br><br>Breakpoint <span class="hljs-number">1</span>, <span class="hljs-built_in">main</span> () at gdb_example.c:<span class="hljs-number">25</span><br><span class="hljs-number">25</span>          sum[i] = <span class="hljs-built_in">add</span>(array1[i], array2[i]);<br>(gdb) next<br><span class="hljs-number">23</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>(gdb) next<br>Hardware watchpoint <span class="hljs-number">3</span>: i<br><br>Old value = <span class="hljs-number">1</span><br>New value = <span class="hljs-number">2</span><br><span class="hljs-number">0x0804838d</span> in <span class="hljs-built_in">main</span> () at gdb_example.c:<span class="hljs-number">23</span><br><span class="hljs-number">23</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br></code></pre></td></tr></table></figure><h3 id="examine命令">examine命令</h3><p>我们可以使用examine命令（缩写为x）来查看内存地址中的值。examine命令的语法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prettyprint">x/&lt;n/f/u&gt; &lt;addr&gt; /&lt;n/f/u&gt; &lt;addr&gt; <br></code></pre></td></tr></table></figure><p><addr>表示一个内存地址。“x/”后的n、f、u都是可选的参数，n是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容；f表示显示的格式，如果地址所指的是字符串，那么格式可以是s，如果地址是指令地址，那么格式可以是i；u表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4字节。u参数可以被一些字符代替：b表示单字节，h表示双字节，w表示四字节，g表示八字节。当我们指定了字节长度后，GDB会从指定的内存地址开始，读写指定字节，并把其当作一个值取出来。n、f、u这3个参数可以一起使用，例如命令“x/3uh0x54320”表示从内存地址0x54320开始以双字节为1个单位（h）、16进制方式（u）显示3个单位（3）的内存。==</p><p>譬如下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">main</span>()<br>&#123;<br>        <span class="hljs-type">char</span> *c = <span class="hljs-string">&quot;hello world&quot;</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, c);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> *c = <span class="hljs-string">&quot;hello world&quot;</span>;<br></code></pre></td></tr></table></figure><p>下一行设置断点后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) l<br><span class="hljs-number">1</span>    <span class="hljs-built_in">main</span>()<br><span class="hljs-number">2</span>    &#123;<br><span class="hljs-number">3</span>        <span class="hljs-type">char</span> *c = <span class="hljs-string">&quot;hello world&quot;</span>;<br><span class="hljs-number">4</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, c);<br><span class="hljs-number">5</span>    &#125;<br>(gdb) b <span class="hljs-number">4</span><br>Breakpoint <span class="hljs-number">1</span> at <span class="hljs-number">0x100000f17</span>: file main.c, line <span class="hljs-number">4.</span><br>(gdb) r<br>Starting program: /Users/songbarry/main<br>Reading symbols <span class="hljs-keyword">for</span> shared libraries +. done<br><br>Breakpoint <span class="hljs-number">1</span>, <span class="hljs-built_in">main</span> () at main.c:<span class="hljs-number">4</span><br><span class="hljs-number">4</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, c);<br></code></pre></td></tr></table></figure><p>可以通过多种方式看C指向的字符串：</p><p>方法1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) p c<br>$<span class="hljs-number">1</span> = <span class="hljs-number">0x100000f2e</span> <span class="hljs-string">&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) x/s <span class="hljs-number">0x100000f2e</span><br><span class="hljs-number">0x100000f2e</span>: <span class="hljs-string">&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure><p>方法3：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) <span class="hljs-built_in">p</span> (<span class="hljs-type">char</span> *)<span class="hljs-number">0x100000f2e</span><br>$<span class="hljs-number">3</span> = <span class="hljs-number">0x100000f2e</span> <span class="hljs-string">&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure><p>将第一个字符改为大写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) p *(<span class="hljs-type">char</span> *)<span class="hljs-number">0x100000f2e</span>=<span class="hljs-string">&#x27;H&#x27;</span><br>$<span class="hljs-number">4</span> = <span class="hljs-number">72</span> <span class="hljs-string">&#x27;H&#x27;</span><br></code></pre></td></tr></table></figure><p>再看看C：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) p c<br>$<span class="hljs-number">5</span> = <span class="hljs-number">0x100000f2e</span> <span class="hljs-string">&quot;Hello world&quot;</span><br></code></pre></td></tr></table></figure><h3 id="set命令">set命令</h3><p>修改寄存器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) set $v0 = <span class="hljs-number">0x004000000</span><br>(gdb) set $epc = <span class="hljs-number">0xbfc00000</span> <br></code></pre></td></tr></table></figure><p>修改内存：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) set &#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&#125;<span class="hljs-number">0x8048a51</span>=<span class="hljs-number">0x0</span><br></code></pre></td></tr></table></figure><p>譬如对于第8节的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) set &#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&#125;<span class="hljs-number">0x100000f2e</span>=<span class="hljs-number">0x0</span>       <br>(gdb) x/<span class="hljs-number">10</span>cb <span class="hljs-number">0x100000f2e</span><br><span class="hljs-number">0x100000f2e</span>:<span class="hljs-number">0</span> <span class="hljs-string">&#x27;\0&#x27;</span><span class="hljs-number">0</span> <span class="hljs-string">&#x27;\0&#x27;</span><span class="hljs-number">0</span> <span class="hljs-string">&#x27;\0&#x27;</span><span class="hljs-number">0</span> <span class="hljs-string">&#x27;\0&#x27;</span><span class="hljs-number">111</span> <span class="hljs-string">&#x27;o&#x27;</span><span class="hljs-number">32</span> <span class="hljs-string">&#x27; &#x27;</span><span class="hljs-number">119</span> <span class="hljs-string">&#x27;w&#x27;</span><span class="hljs-number">111</span> <span class="hljs-string">&#x27;o&#x27;</span><br><span class="hljs-number">0x100000f36</span>:<span class="hljs-number">114</span> <span class="hljs-string">&#x27;r&#x27;</span><span class="hljs-number">108</span> <span class="hljs-string">&#x27;l&#x27;</span><br>(gdb) p c<br>$<span class="hljs-number">10</span> = <span class="hljs-number">0x100000f2e</span> <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="jump命令">jump命令</h3>一般来说，被调试程序会按照程序代码的运行顺序依次执行，但是GDB也提供了乱序执行的功能，也就是说，GDB可以修改程序的执行顺序，从而让程序随意跳跃。这个功能可以由GDB的jump命令：jump<linespec>来指定下一条语句的运行点。<linespec>可以是文件的行号，可以是file:line格式，也可以是+num这种偏移量格式，表示下一条运行语句从哪里开始。jump<address>这里的<address><p>是代码行的内存地址。注意，jump命令不会改变当前的程序栈中的内容，所以，如果使用jump从一个函数跳转到另一个函数，当跳转到的函数运行完返回，进行出栈操作时必然会发生错误，这可能导致意想不到的结果，所以最好只用jump在同一个函数中进行跳转。</p><h3 id="signal命令">signal命令</h3><p>使用singal命令，可以产生一个信号量给被调试的程序，如中断信号“Ctrl+C”。这非常方便于程序的调试，可以在程序运行的任意位置设置断点，并在该断点用GDB产生一个信号量，这种精确地在某处产生信号的方法非常有利于程序的调试。signal命令的语法是：signal <signal>，<ahref="https://so.csdn.net/so/search?q=UNIX&amp;spm=1001.2101.3001.7020">UNIX</a>的系统信号量通常从1到15，所以<signal>取值也在这个范围。</p><h3 id="return命令">return命令</h3><p>如果在函数中设置了调试断点，在断点后还有语句没有执行完，这时候我们可以使用return命令强制函数忽略还没有执行的语句并返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">return</span><br><span class="hljs-keyword">return</span> &lt;expression&gt;<br></code></pre></td></tr></table></figure><p>上述return命令用于取消当前函数的执行，并立即返回，如果指定了<expression>，那么该表达式的值会被作为函数的返回值。</p><h3 id="call命令">call命令</h3><p>call命令用于强制调用某函数： call <expr>表达式中可以一是函数，以此达到强制调用函数的目的，它会显示函数的返回值（如果函数返回值不是void）。其实，前面介绍的print命令也可以完成强制调用函数的功能。</p><h3 id="info命令">info命令</h3><p>info命令可以在调试时用来查看寄存器、断点、观察点和信号等信息。要查看寄存器的值，可以使用如下命令：info registers （查看除了浮点寄存器以外的寄存器）info all-registers（查看所有寄存器，包括浮点寄存器）info registers &lt;regname ...&gt;（查看所指定的寄存器） 要查看断点信息，可以使用如下命令：info break列出当前所设置的所有观察点，使用如下命令：info watchpoints查看有哪些信号正在被GDB检测，使用如下命令：info signals info handle也可以使用info line命令来查看源代码在内存中的地址。infothreads可以看多线程。infoline后面可以跟行号、函数名、文件名:行号、文件名:函数名等多种形式，例如下面的命令会打印出所指定的源码在运行时的内存地址：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">info line tst.c:func<br></code></pre></td></tr></table></figure><h3 id="set-scheduler-locking-offonstep">set scheduler-lockingoff|on|step</h3><p>off 不锁定任何线程，也就是所有线程都执行，这是默认值。 on只有当前被调试程序会执行。 step在单步的时候，除了next过一个函数的情况以外，只有当前线程会执行。</p><p>与多线程调试相关的命令还包括：</p><p>thread ID 切换当前调试的线程为指定ID的线程。</p><p>break thread_test.c:123 thread all 在所有线程中相应的行上设置断点</p><p>thread apply ID1 ID2 command让一个或者多个线程执行GDB命令command。</p><p>thread apply all command 让所有被调试线程执行GDB命令command。</p><h3 id="disassemble">disassemble</h3><p>disassemble命令用于反汇编，它可被用来查看当前执行时的源代码的机器码，其实际上只是把目前内存中的指令dump出来。下面的示例用于查看函数func的汇编代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) disassemble func<br>Dump of assembler code <span class="hljs-keyword">for</span> function func:<br><span class="hljs-number">0x8048450</span> &lt;func&gt;:       push   %ebp<br><span class="hljs-number">0x8048451</span> &lt;func+<span class="hljs-number">1</span>&gt;:     mov    %esp,%ebp<br><span class="hljs-number">0x8048453</span> &lt;func+<span class="hljs-number">3</span>&gt;:     sub    $<span class="hljs-number">0x18</span>,%esp<br><span class="hljs-number">0x8048456</span> &lt;func+<span class="hljs-number">6</span>&gt;:     movl   $<span class="hljs-number">0x0</span>,<span class="hljs-number">0xfffffffc</span>(%ebp)<br>...<br>End of assembler dump.<br></code></pre></td></tr></table></figure><h2 id="gcc">6.gcc</h2><h3 id="优化等级">优化等级</h3><p>gcc中指定优化级别的参数有：-O0、-O1、-O2、-O3、-Og、-Os、-Ofast。在编译时，如果没有指定优化参数，则默认为-O0</p><p>-O1、-O2、-O3中，随着数字变大，代码的优化程度也越高，不过这在某种意义上来说，也是以牺牲程序的可调试性为代价的。</p><p>-Og 是在 -O1的基础上，去掉了那些影响调试的优化，所以如果最终是为了调试程序，可以使用这个参数。不过光有这个参数也是不行的，这个参数只是告诉编译器，编译后的代码不要影响调试，但调试信息的生成还是靠-g 参数的。</p><p>参数 -Os 是在 -O2的基础上，去掉了那些会导致最终可执行程序增大的优化，如果想要更小的可执行程序，可选择这个参数。</p><p>参数 -Ofast 是在 -O3的基础上，添加了一些非常规优化，这些优化是通过打破一些国际标准（比如一些数学函数的实现标准）来实现的，所以一般不推荐使用该参数。</p><h3 id="编译链接命令">编译链接命令</h3><p>在使用 GCC 编译程序时，编译过程可以被细分为四个阶段：</p><p>1）<strong>预处理</strong>（ Pre-Processing）阶段：主要对包含的头文件（＃include ）和宏定义（＃define,#ifdef …）进行处理。可以使用“gcc -E” 让gcc 在预处理之后停止编译过程，生成 *.i文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -E hello.c -o hello.i<br></code></pre></td></tr></table></figure><p>2）<strong>编译</strong>（ Compiling ）阶段：gcc首先要检查代码的规范性，是否有语法错误等。以确定代码实际要做的工作，在检查无误后，gcc把代码翻译成汇编语言。用户可以使用-S选项进行查看，该选项只进行编译而不进行汇编，生成汇编代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -S hello.i -o hello.s<br></code></pre></td></tr></table></figure><p>3） <strong>汇编</strong>（ Asse mbling ）阶段：生成目标代码 <em>.o；有两种方式：使用 gcc 直接从源代码生成目标代码 gcc -c </em>.s -o <em>.o以及使用汇编器从汇编代码生成目标代码 as </em>.s -o *.o</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -c hello.s -o hello.o<br>as hello.s -o hello.o<br></code></pre></td></tr></table></figure><p>也可以直接使用as <em>.s,将<strong>执行汇编、链接过程生成可执行文件a.out</strong>,可以像上面使用<strong>-o 选项</strong>指定输出文件的格式。4）<strong>链接</strong>（ Linking）阶段：生成可执行文件；可以生成的可执行文件格式有：a.out/</em>/,当然可能还有其它格式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc hello.o     生成可执行文件 a.out<br>gcc hello.o -o hello        生成可执行文件 hello<br></code></pre></td></tr></table></figure><p><strong>gcc 常用编译选项：</strong></p><table><colgroup><col style="width: 10%" /><col style="width: 89%" /></colgroup><thead><tr class="header"><th>选项</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>-c</td><td>只编译不链接，生成目标文件<code>.o</code></td></tr><tr class="even"><td>-S</td><td>只编译不汇编，生成汇编代码</td></tr><tr class="odd"><td>-E</td><td>只进行预编译</td></tr><tr class="even"><td>-g</td><td>在可执行程序中包含标准调试信息</td></tr><tr class="odd"><td>-o file</td><td>指定file文件作为输出文件</td></tr><tr class="even"><td>-v</td><td>打印出编译器内部编译各过程的命令行信息和编译器的版本</td></tr><tr class="odd"><td>-Idir</td><td>在头文件的搜索路径列表中添加dir目录</td></tr><tr class="even"><td>-static</td><td>进行静态编译，只链接静态库，禁止使用动态库</td></tr><tr class="odd"><td>-shared</td><td>进行动态编译，尽可能地链接动态库，没有动态库时才会链接同名静态库</td></tr><tr class="even"><td>-L dir</td><td>在库文件的搜索路径列表中添加dir目录</td></tr><tr class="odd"><td>-lname</td><td>链接libname.a或libname.so的库文件</td></tr><tr class="even"><td>-fPIC</td><td>生成使用相对地址的位置无关目标代码（Position Independent Code）</td></tr></tbody></table><p>gcc在链接时优先使用动态链接库，只有当动态链接库不存在时才考虑使用静态链接库，如果需要的话可以在编译时加上<strong>-static</strong>选项，强制使用静态链接库。</p><h2 id="重定向">7.重定向</h2><h3 id="linux-21">Linux 2&gt;&amp;1</h3><p>2&gt;&amp;1的意思是将标准错误(2)也定向到标准输出(1)的输出文件中。</p><p>Linux中三种标准输入输出，分别是STDIN，STDOUT，STDERR，对应的数字是0，1，2。</p><p>STDIN就是标准输入，默认从键盘读取信息；</p><p>STDOUT是标准输出，默认将输出结果输出至终端，也就是显示器之类的东西；</p><p>STDERR是标准的错误信息，默认也会显示在终端上。</p><p>由于STDOUT与STDERR都会默认显示在终端上，为了区分二者的信息，就有了编号的0，1，2的定义，用1表示STDOUT，2表示STDERR。</p><h3 id="从commanddevnull说起">从command&gt;/dev/null说起</h3><p>其实这条命令是一个缩写版，对于一个重定向命令，肯定是<code>a &gt; b</code>这种形式，那么<code>command &gt; /dev/null</code>难道是command充当a的角色，/dev/null充当b的角色。这样看起来比较合理，其实一条命令肯定是充当不了a，肯定是command执行产生的输出来充当a，其实就是标准输出stdout。所以<code>command &gt; /dev/null</code>相当于执行了<code>command 1 &gt; /dev/null</code>。执行command产生了标准输出stdout(用1表示)，重定向到/dev/null的设备文件中。</p><h3 id="说说21">说说2&gt;&amp;1</h3><p>通过上面<code>command &gt; /dev/null</code>等价于<code>command 1 &gt; /dev/null</code>,那么对于<code>2&gt;&amp;1</code>也就好理解了，2就是标准错误，1是标准输出，那么这条命令不就是相当于把标准错误重定向到标准输出么。等等是&amp;1而不是1，这里&amp;是什么？这里<code>&amp;</code>相当于<strong>等效于标准输出</strong>。这里有点不好理解，先看下面。</p><h3 id="commanda-2a-与-commanda-21的区别">command&gt;a 2&gt;a 与command&gt;a 2&gt;&amp;1的区别</h3><p>通过上面的分析，对于<code>command&gt;a 2&gt;&amp;1</code>这条命令，等价于<code>command 1&gt;a 2&gt;&amp;1</code>可以理解为执行command产生的标准输入重定向到文件a中，标准错误也重定向到文件a中。那么是否就说<code>command 1&gt;a 2&gt;&amp;1</code>等价于<code>command 1&gt;a 2&gt;a</code>呢。其实不是，<code>command 1&gt;a 2&gt;&amp;1</code>与<code>command 1&gt;a 2&gt;a</code>还是有区别的，区别就在于前者只打开一次文件a，后者会打开文件两次，并导致stdout被stderr覆盖。<code>&amp;1</code>的含义就可以理解为用标准输出的引用，引用的就是重定向标准输出产生打开的a。从IO效率上来讲，<code>command 1&gt;a 2&gt;&amp;1</code>比<code>command 1&gt;a 2&gt;a</code>的效率更高</p><h3 id="再思考一下">再思考一下</h3><p>为什么2&gt;&amp;1 要放在后边呢？我的理解是因为2（也就是错误输出）要重定向到&amp;1，也就是标准输出的引用中，也就是标准输出打开的文件中，所以需要现在前面打开1的输出文件。</p><h3 id="nohup及nohup.out">nohup及nohup.out</h3><p>如果使用nohup执行命令，配合&amp;的使用，则可以不挂断的将命令执行到后台，如果没有指定重定向文件，则输出将附加到当前目录的nohup.out 文件中。如果当前目录的 nohup.out 文件不可写，输出重定向到$HOME/nohup.out 文件中，实例如下：</p><p>nohup test.pl 2&gt;&amp;1 &amp;</p><p>在shell脚本中，默认情况下，总是有三个文件处于打开状态，标准输入(键盘输入)、标准输出（输出到屏幕）、标准错误（也是输出到屏幕），它们分别对应的<strong>文件描述符</strong>是0，1，2。</p><p><strong>&gt; 默认为标准输出重定向，与 1&gt; 相同 2&gt;&amp;1</strong>意思是把 标准错误输出 重定向到 标准输出.</p><p><strong>&amp;&gt;file</strong> 意思是把<strong>标准输出</strong> 和<strong>标准错误输出</strong> 都重定向到文件file中</p><p><strong>/dev/null是一个文件，这个文件比较特殊，所有传给它的东西它都丢弃掉</strong></p><p><strong>举例说明:</strong></p><p>当前目录只有一个文件 a.txt. [root@redhat box]# ls a.txt [root@redhatbox]# ls a.txt b.txt ls: b.txt: No such file or directory由于没有b.txt这个文件, 于是返回错误值, 这就是所谓的2输出 a.txt而这个就是所谓的1输出</p><p><strong>再接着看:</strong></p><p>[root@redhat box]# ls a.txt b.txt 1&gt;<strong>file.out</strong>2&gt;<strong>file.err</strong> 执行后,没有任何返回值. 原因是, 返回值都<ahref="https://so.csdn.net/so/search?q=重定向&amp;spm=1001.2101.3001.7020">重定向</a>到相应的文件中了,而不再前端显示[root@redhat box]# cat file.out a.txt [root@redhat box]# cat file.errls: b.txt: No such file or directory 一般来说, "1&gt;" 通常可以省略成"&gt;". 即可以把如上命令写成: ls a.txt b.txt &gt;file.out 2&gt;file.err有了这些认识才能理解 "1&gt;&amp;2" 和 "2&gt;&amp;1". <strong>1&gt;&amp;2正确返回值传递给2输出通道 &amp;2表示2输出通道</strong> 如果此处错写成1&gt;2, 就表示把1输出重定向到文件2中. <strong>2&gt;&amp;1错误返回值传递给1输出通道, 同样&amp;1表示1输出通道.</strong> 举个例子.[root@redhat box]# <strong>ls a.txt b.txt 1&gt;file.out2&gt;&amp;1</strong> [root@redhat box]# cat file.out ls: b.txt: No suchfile or directory a.txt 现在,正确的输出和错误的输出都定向到了file.out这个文件中, 而不显示在前端.补充下, 输出不只1和2, 还有其他的类型, 这两种只是最常用和最基本的.</p><p>例如： rm -f $(find / -name core) &amp;&gt;/dev/null，<strong>/dev/null是一个文件，这个文件比较特殊，所有传给它的东西它都丢弃掉。</strong></p><p>例如： 注意，为了方便理解，必须设置一个环境使得执行grep da<em>命令会有正常输出和错误输出，然后分别使用下面的命令生成三个文件：grep da </em> &gt; greplog1 grep da * &gt; greplog2 1&gt;&amp;2<br />grep da * &gt; greplog3 2&gt;&amp;1 //grep da * 2&gt; greplog41&gt;&amp;2 结果一样 #查看greplog1会发现里面只有正常输出内容#查看greplog2会发现里面什么都没有#查看greplog3会发现里面既有正常输出内容又有错误输出内容</p><h2 id="grep命令">8. grep命令</h2><p><code>grep</code>命令是打印匹配文本行，其全称为 Global Search RegularExpression and Print out the line；基本语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;code class=<span class="hljs-string">&quot;hljs css has-numbering&quot;</span>&gt;&lt;span class=<span class="hljs-string">&quot;hljs-tag&quot;</span>&gt;grep&lt;/span&gt; &lt;span class=<span class="hljs-string">&quot;hljs-attr_selector&quot;</span>&gt;[OPTIONS]&lt;/span&gt; &lt;span class=<span class="hljs-string">&quot;hljs-tag&quot;</span>&gt;PATTERN&lt;/span&gt; &lt;span class=<span class="hljs-string">&quot;hljs-attr_selector&quot;</span>&gt;[FILE...]&lt;/span&gt;<br>&lt;span class=<span class="hljs-string">&quot;hljs-tag&quot;</span>&gt;grep&lt;/span&gt; &lt;span class=<span class="hljs-string">&quot;hljs-attr_selector&quot;</span>&gt;[OPTIONS]&lt;/span&gt; &lt;span class=<span class="hljs-string">&quot;hljs-attr_selector&quot;</span>&gt;[-e PATTERN | -f FILE]&lt;/span&gt; &lt;span class=<span class="hljs-string">&quot;hljs-attr_selector&quot;</span>&gt;[FILE...]&lt;/span&gt;<br>&lt;/code&gt;<br></code></pre></td></tr></table></figure><p>其中，<code>OPTIONS</code>表示选项；<code>PATTERN</code>表示匹配模式，匹配模式可以是字符串、变量、正则表达式，若匹配模式中含义空格，则需要使用双引号将匹配模式引起来；<code>FILE</code>表示一系列文件；<code>grep</code>命令从文件中搜索满足指定匹配模式的文本行，并打印出来。</p><p>正则表达式的分类为：</p><ul><li>基本正则表达式（Basic Regular Expression）：Basic RegEx，简称<strong>BRE</strong></li><li>扩展正则表达式（Extended Regular Expression）：Extended RegEx，简称<strong>ERE</strong></li><li>Perl 正则表达式（Perl Regular Expression）：Perl RegEx，简称<strong>PCRE</strong>；</li></ul><p><code>grep</code>命令根据不同的参数支持不同的正则表达式：</p><ul><li><code>grep</code>命令后不跟任何参数（默认），则表示要使用“BRE”；</li><li><code>grep</code>命令后跟<code>-E</code>参数，则表示要使用“ERE”；</li><li><code>grep</code>命令后跟<code>-P</code>参数，则表示要使用“PCRE”；</li></ul><p>常用<code>OPTIONS</code>选项如下表所示：</p><table><colgroup><col style="width: 14%" /><col style="width: 85%" /></colgroup><thead><tr class="header"><th>选项</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>-E</td><td>指定 PATTERN 匹配模式为扩展正则表达式</td></tr><tr class="even"><td>-F</td><td>指定 PATTERN 匹配模式为固定的字符串</td></tr><tr class="odd"><td>-G</td><td>指定 PATTERN 匹配模式为基本正则表达式</td></tr><tr class="even"><td>-P</td><td>指定 PATTERN 匹配模式为 Perl 正则表达式</td></tr><tr class="odd"><td>-R</td><td>查找所有文件包含子目录</td></tr><tr class="even"><td>-e PATTERN</td><td>指定 PATTERN 为一个或多个搜索模式</td></tr><tr class="odd"><td>-f FILE</td><td>指定包含搜索模式的 FILE</td></tr><tr class="even"><td><strong>-i</strong></td><td>匹配是忽略字母大小写</td></tr><tr class="odd"><td><strong>-v</strong></td><td>显示所有与匹配模式不匹配的文本行（如grep -v "grep"或grep -v grep意思是不显示包含grep符串的那一行）</td></tr><tr class="even"><td>-w</td><td>执行单词搜索</td></tr><tr class="odd"><td>-x</td><td>显示与指定模式精确匹配而不含其他字符的文本行</td></tr><tr class="even"><td>-y</td><td>与选项 -i 相同功能</td></tr><tr class="odd"><td></td><td></td></tr><tr class="even"><td>-c</td><td>只打印匹配的文本行的行数，不显示匹配内容</td></tr><tr class="odd"><td>-l</td><td>只显示匹配文本行的文件名，不显示匹配内容</td></tr><tr class="even"><td><strong>-n</strong></td><td>列出所有匹配的文本行，并显示行号</td></tr><tr class="odd"><td><strong>-r</strong></td><td>递归搜索目录(当前目录及其各级子目录)</td></tr><tr class="even"><td>-s</td><td>不显示错误信息</td></tr></tbody></table><p>在当前目录下查找"hello,world!"字符串<code>grep -rn "hello,world!" *</code> * :表示当前目录所有文件，也可以是某个文件名</p><p>命令行参数：</p><p>grep -i pattern files ：不区分大小写地搜索。默认情况区分大小写，</p><p>grep -l pattern files ：只列出匹配的文件名，</p><p>grep -L pattern files ：列出不匹配的文件名，</p><p>grep -w pattern files：只匹配整个单词，而不是字符串的一部分（如匹配‘magic’，而不是‘magical’），</p><p>grep -C number pattern files ：匹配的上下文分别显示[number]行，</p><p>grep pattern1 | pattern2 files ：显示匹配 pattern1 或 pattern2的行，</p><p>grep pattern1 files | grep pattern2 ：显示既匹配 pattern1 又匹配pattern2 的行。</p><p>&lt; 和 &gt; 分别标注单词的开始与结尾。</p><p>grep man * 会匹配 ‘Batman’、‘manic’、‘man’等，</p><p>grep '&lt;man' * 匹配‘manic’和‘man’，但不是‘Batman’，</p><p>grep '&lt;man&gt;'只匹配‘man’，而不是‘Batman’或‘manic’等其他的字符串。</p><p>'^'：指匹配的字符串在行首，</p><p>'$'：指匹配的字符串在行尾，</p><h2 id="流编辑器-sed">9. 流编辑器 sed</h2><h3 id="sed命令">sed命令</h3><p>元字符集：<br /><code>^</code>锚定行的开始 如：/^sed/匹配所有以sed开头的行。</p><p><code>$</code>锚定行的结束 如：/sed$/匹配所有以sed结尾的行。</p><p><code>.</code>匹配一个非换行符的字符如：/s.d/匹配s后接一个任意字符，然后是d。</p><p><code>*</code>匹配零或多个字符如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。</p><p><code>[]</code>匹配一个指定范围内的字符，如/[Ss]ed/匹配sed和Sed。</p><p><code>[^]</code>匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。</p><p>保存匹配的字符，如s/able/\1rs，loveable被替换成lovers。</p><p><code>&amp;</code>保存搜索字符用来替换其他字符，如s/love/<strong>&amp;</strong>/，love这成<strong>love</strong>。</p><p><code>\&lt;</code>锚定单词的开始，如:/&lt;love/匹配包含以love开头的单词的行。</p><p><code>\&gt;</code>锚定单词的结束，如/love&gt;/匹配包含以love结尾的单词的行。</p><p><code>x\&#123;m\&#125;</code>重复字符x，m次，如：/0{5}/匹配包含5个o的行。</p><p><code>x\&#123;m,\&#125;</code>重复字符x,至少m次，如：/o{5,}/匹配至少有5个o的行。</p><p><code>x\&#123;m,n\&#125;</code>重复字符x，至少m次，不多于n次，如：/o{5,10}/匹配5--10个o的行。</p><p>​ 先看几个实例：</p><p>删除：d命令</p><ul><li>$ sed '2d' example-----删除example文件的第二行。</li><li>$ sed '2,$d' example-----删除example文件的第二行到末尾所有行。</li><li>$ sed '$d' example-----删除example文件的最后一行。</li><li>$ sed '/test/'d example-----删除example文件所有包含test的行。</li></ul><p>替换：s命令</p><ul><li><p>$ sed 's/test/mytest/g'example-----在整行范围内把test替换为mytest。如果没有g标记，则只有每行第一个匹配的test被替换成mytest。</p></li><li><p>$ sed -n 's/^test/mytest/p'example-----(-n)选项和p标志一起使用表示只打印那些发生替换的行。也就是说，如果某一行开头的test被替换成mytest，就打印它。</p></li><li><p>$ sed 's/^192.168.0.1/&amp;localhost/'example-----&amp;符号表示替换换字符串中被找到的部份。所有以192.168.0.1开头的行都会被替换成它自已加localhost，变成192.168.0.1localhost。</p></li><li><p>$ sed -n 's/able/\1rs/p'example-----love被标记为1，所有loveable会被替换成lovers，而且替换的行会被打印出来。</p></li><li><p>$ sed 's#10#100#g'example-----不论什么字符，紧跟着s命令的都被认为是新的分隔符，所以，“#”在这里是分隔符，代替了默认的“/”分隔符。表示把所有10替换成100。</p><p>选定行的范围：逗号</p></li><li><p>$ sed -n '/test/,/check/p'example-----所有在模板test和check所确定的范围内的行都被打印。</p></li><li><p>$ sed -n '5,/^test/p'example-----打印从第五行开始到第一个包含以test开始的行之间的所有行。</p></li><li><p>$ sed '/test/,/check/s/$/sed test/'example-----对于模板test和west之间的行，每行的末尾用字符串sedtest替换。</p></li></ul><p>多点编辑：e命令</p><ul><li>$ sed -e '1,5d' -e 's/test/check/'example-----(-e)选项允许在同一行里执行多条命令。如例子所示，第一条命令删除1至5行，第二条命令用check替换test。命令的执行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。</li><li>$ sed --expression='s/test/check/' --expression='/love/d'example-----一个比-e更好的命令是--expression。它能给sed表达式赋值。</li></ul><p>从文件读入：r命令</p><ul><li>$ sed '/test/r file'example-----file里的内容被读进来，显示在与test匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面。</li></ul><p>写入文件：w命令</p><ul><li>$ sed -n '/test/w file'example-----在example中所有包含test的行都被写入file里。</li></ul><p>追加命令：a命令</p><ul><li>$ sed '/^test/a\---&gt;this is a example' example&lt;-----'this is aexample'被追加到以test开头的行后面，sed要求命令a后面有一个反斜杠。</li></ul><p>插入：i命令</p><p>$ sed '/test/i\</p><p>new line</p><p>-------------------------' example</p><p>如果test被匹配，则把反斜杠后面的文本插入到匹配行的前面。</p><p>下一个：n命令</p><ul><li>$ sed '/test/{ n; s/aa/bb/; }'example-----如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb，并打印该行，然后继续。</li></ul><p>变形：y命令</p><ul><li>$ sed '1,10y/abcde/ABCDE/'example-----把1--10行内所有abcde转变为大写，注意，正则表达式元字符不能使用这个命令。</li></ul><p>退出：q命令</p><ul><li>$ sed '10q' example-----打印完第10行后，退出sed。</li></ul><p>保持和获取：h命令和G命令</p><ul><li>$ sed -e '/test/h' -e '$Gexample-----在sed处理文件的时候，每一行都被保存在一个叫模式空间的临时缓冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。在这个例子里，匹配test的行被找到后，将存入模式空间，h命令将其复制并存入一个称为保持缓存区的特殊缓冲区内。第二条语句的意思是，当到达最后一行后，G命令取出保持缓冲区的行，然后把它放回模式空间中，且追加到现在已经存在于模式空间中的行的末尾。在这个例子中就是追加到最后一行。简单来说，任何包含test的行都被复制并追加到该文件的末尾。</li></ul><p>保持和互换：h命令和x命令</p><ul><li>$ sed -e '/test/h' -e '/check/x' example-----互换模式空间和保持缓冲区的内容。也就是把包含test与check的行互换。</li></ul><p><code>sed</code>命令从文件或者标准输入中一次读取一行数据，将该行数据复制到缓冲区，然后读取命令行或脚本的编辑子命令，对缓冲区中的文本行进行编辑。重复此工作，直到所有文本行都处理完毕。</p><p><code>sed</code>命令编辑的是文件是原始文件在缓冲区中的副本，并不影响原始文件，但是可以把编辑结果通过输出重定向保存起来。</p><p><code>sed</code>命令的基本语法如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;code class=<span class="hljs-string">&quot;hljs r has-numbering&quot;</span>&gt;sed [OPTION]&lt;span class=<span class="hljs-string">&quot;hljs-keyword&quot;</span>&gt;...&lt;/span&gt; &#123;script&#125; [input-file]&lt;span class=<span class="hljs-string">&quot;hljs-keyword&quot;</span>&gt;...&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure><p>常用选项<code>OPTION</code>如下表所示：</p><table><thead><tr class="header"><th>选项</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><strong>-n</strong></td><td>取消默认输出</td></tr><tr class="even"><td>-e script</td><td>允许执行多个脚本</td></tr><tr class="odd"><td><strong>-f script-file</strong></td><td><strong>从脚本文件中读取命令</strong></td></tr><tr class="even"><td><strong>-i</strong></td><td><strong>直接修改原始文件</strong></td></tr><tr class="odd"><td>-l N</td><td>指定行长度为 N</td></tr><tr class="even"><td>-r</td><td>在脚本中使用扩展正则表达式</td></tr><tr class="odd"><td>-s</td><td>把文件作为单独文件</td></tr><tr class="even"><td>-u</td><td>最低限度的缓存输入与输出</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">test2.sh<br><span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;code&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;python&quot;</span>&gt;</span>  asdafsadfasdfsa<br>  badfasdfas<br>  bdsdfsdfsdf<br>  csdfasdfasf<br></code></pre></td></tr></table></figure><p>test.sh #!/bin/bash</p><p>sed -ie '/^b/ s/b/bbbbbb/g' test2.sh</p><p>执行后test2.sh的结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">asdafsadfasdfsa<br>bbbbadfasdfas<br>bbbbdsdfsdfsdf<br>csdfasdfasf<br></code></pre></td></tr></table></figure><p><strong>如果不带-i，那么test2.sh中的内容不会发生变化，发生变化的只是缓冲区中的内容。</strong></p><h3 id="文本行定位">文本行定位</h3><p><code>sed</code>命令提供了两种方式来实现文本行的定位：<strong>行号定位</strong>、<strong>正则表达式定位</strong></p><h3 id="行号定位"><strong>行号定位</strong></h3><ul><li>定位某个特定的行<strong><code>n</code></strong>：<code>n</code>是一个整数，表示定位到文本的第<code>n</code>行；</li><li>定位某段连续的行<strong><code>n,m</code></strong>：<code>n</code>和<code>m</code>都是整数，表示定位到起始行为<code>n</code>，终止行为<code>m</code>的文本行；</li><li>指定起始行和步长<strong><code>start~step</code></strong>：起始行为<code>start</code>，步长为<code>step</code>；</li><li>第一行<strong><code>1</code></strong>和最后一行<strong><code>$</code></strong>：<code>1</code>表示第一行，<code>$</code>表示最后一行；</li><li>指定某行后面的几行<strong><code>n,+x</code></strong>：表示从第<code>n</code>行开始到后面的<code>x</code>行；</li></ul><h3 id="正则表达式定位"><strong>正则表达式定位</strong></h3><p><code>sed</code>命令使用正则表达式定位文本行的语法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs vala has-numbering&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;#regexp 表示正则表达式&lt;/span&gt;<br>/regexp/<br><br>如：/^b/ 表示行首为b<br>   /1,3/ 表示第1～3行<br>&lt;/code&gt;<br></code></pre></td></tr></table></figure><h3 id="sed命令的常用操作">sed命令的常用操作</h3><p><code>sed</code>命令的常用编辑命令有：打印、删除、增加、替换；其基本语法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs css has-numbering&quot;&gt;&lt;span class=&quot;hljs-attr_selector&quot;&gt;[address1[,address2]&lt;/span&gt;] &lt;span class=&quot;hljs-tag&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;hljs-attr_selector&quot;&gt;[argument]&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure><p>其中<code>address</code>称为位置参数，即上面的行定位；<code>command</code>是<code>sed</code>所提供的子命令，用来实现编辑操作；<code>argument</code>表示子命令的选项参数；</p><h4 id="打印文本">1) 打印文本</h4><p><code>sed</code>命令中可通过位置参数和<strong><code>p</code></strong>命令打印所需要的文本行，其语法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs css has-numbering&quot;&gt;&lt;span class=&quot;hljs-attr_selector&quot;&gt;[address1[,address2]&lt;/span&gt;] &lt;span class=&quot;hljs-tag&quot;&gt;p&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;&lt;span class=&quot;hljs-shebang&quot;&gt;#! /bin/bash<br>&lt;/span&gt;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#输出第1~4行文本，注意1,3p之间是单引号&lt;/span&gt;<br>sed -n &lt;span class=&quot;hljs-string&quot;&gt;&#x27;1,3p&#x27;&lt;/span&gt; test.txt<br><br>&lt;span class=&quot;hljs-comment&quot;&gt;#输出以Lin开头的文本行&lt;/span&gt;<br>result=`sed -n &lt;span class=&quot;hljs-string&quot;&gt;&#x27;/^Lin/ p&#x27;&lt;/span&gt; test.txt`<br>&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$result&lt;/span&gt;&quot;&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure><h4 id="替换文本">2) 替换文本</h4><p><code>sed</code>命令中可通过位置参数和<code>s</code>子命令替换文本行，其语法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs coffeescript has-numbering&quot;&gt;[address1[,address2]] s&lt;span class=&quot;hljs-regexp&quot;&gt;/pattern/replacemen/&lt;/span&gt;[flag]&lt;/code&gt;<br></code></pre></td></tr></table></figure><p><code>flag</code>为替换标志，不同值会影响<code>s</code>子命令的行为；<code>flag</code>常用取值如下表所示：</p><table><colgroup><col style="width: 13%" /><col style="width: 86%" /></colgroup><thead><tr class="header"><th>取值</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><strong>g</strong></td><td>全局匹配，会替换文本行所有符合规则的字符串</td></tr><tr class="even"><td>p</td><td>替换第一个符合规则的字符串，并将缓冲区输出到标准输出</td></tr><tr class="odd"><td>w</td><td>替换第一个符合规则的字符串，并将受影响的行输出到磁盘文件中</td></tr><tr class="even"><td>十进制数n</td><td>替换文本行中第n个符合规则的字符串</td></tr><tr class="odd"><td>空</td><td>若不指定flag值，替换文本行中第一个符合规则的字符串</td></tr></tbody></table><h4 id="删除文本">3) 删除文本</h4><p><code>sed</code>命令中可通过位置参数和<code>d</code>子命令删除文本行，其语法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs css has-numbering&quot;&gt;&lt;span class=&quot;hljs-attr_selector&quot;&gt;[address1[,address2]&lt;/span&gt;] &lt;span class=&quot;hljs-tag&quot;&gt;d&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure><h4 id="增加文本">4) 增加文本</h4><p><strong>追加文本</strong><code>sed</code>命令中可通过位置参数和<code>a</code>子命令追加文本行，其语法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs vala has-numbering&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;#将string插入到address1位置后面&lt;/span&gt;<br>[address1] a &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt; &lt;/code&gt;<br></code></pre></td></tr></table></figure><h4 id="插入文本"><strong>5) 插入文本</strong></h4><p><code>sed</code>命令中可通过位置参数和<code>i</code>子命令插入文本行，其语法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs vala has-numbering&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;#将string插入到address1位置前面&lt;/span&gt;<br>[address1] i &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure><h4 id="组合命令">6) 组合命令</h4><p><code>sed</code>命令支持将多个子命令组合在一起使用；具体方式如下所示：</p><ul><li>使用<code>-e</code>选项：<code>-e</code>选项可以将多个子命令组合在一起使用；例如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;&lt;span class=&quot;hljs-shebang&quot;&gt;#! /bin/bash<br>&lt;/span&gt;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#将全部小写字母 e 替换成大写字母 E，并打印第 1 行到第 3 行文本行&lt;/span&gt;<br>result=`sed -n &lt;span class=&quot;hljs-operator&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#x27;s/e/E/g&#x27;&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#x27;1,3 p&#x27;&lt;/span&gt; test.txt`<br>&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$result&lt;/span&gt;&quot;&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure><ul><li>使用分号<code>;</code>执行多个子命令： 其语法格式：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;sed &lt;span class=&quot;hljs-operator&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#x27;command1; command2...&#x27;&lt;/span&gt; filename&lt;/code&gt;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;&lt;span class=&quot;hljs-shebang&quot;&gt;#! /bin/bash<br>&lt;/span&gt;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#将全部小写字母 e 替换成大写字母 E，并打印第 1 行到第 3 行文本行&lt;/span&gt;<br>result=`sed -n &lt;span class=&quot;hljs-operator&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#x27;s/e/E/g; 1,3 p&#x27;&lt;/span&gt; test.txt`<br>&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$result&lt;/span&gt;&quot;&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure><ul><li>对同一个地址使用多个子命令： 其语法格式：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs r has-numbering&quot;&gt;address&#123;<br>    command1<br>    command2<br>    command3<br>    &lt;span class=&quot;hljs-keyword&quot;&gt;...&lt;/span&gt;<br>&#125;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#或&lt;/span&gt;<br>[address] &#123; command1;command2;command3;&lt;span class=&quot;hljs-keyword&quot;&gt;...&lt;/span&gt;&#125;&lt;/code&gt;<br></code></pre></td></tr></table></figure><h4 id="sed脚本文件">7)sed脚本文件</h4><p>可以将多个子命令写成后缀名为<code>.sed</code>的<code>sed</code>脚本文件，<code>sed</code>脚本文件内容只需将各个子命令依次列出来，不必使用引号，若将多个子命令写在同一行，则不同子命令之间需使用分号隔开。调用<code>sed</code>脚本文件的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;sed &lt;span class=&quot;hljs-operator&quot;&gt;-f&lt;/span&gt; script&lt;/code&gt;<br>&lt;pre&gt;<br><br></code></pre></td></tr></table></figure><h2 id="awk命令">10. awk命令</h2><h3 id="awk命令的基本语法">awk命令的基本语法</h3><p><code>awk</code>命令是一个文本处理工具，其基本语法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs mathematica has-numbering&quot;&gt;awk pattern &lt;span class=&quot;hljs-list&quot;&gt;&#123; actions &#125;&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure><p>其中，<code>pattern</code>表示匹配模式，<code>actions</code>表示要执行的操作；即对符合<code>pattern</code>匹配模式的文本行执行<code>actions</code>操作；若省略<code>pattern</code>匹配模式，则表示对所有文本行执行<code>actions</code>操作；若省略<code>pattern</code>匹配模式，则把匹配成功的文本行打印输出；但是不能同时省略<code>pattern</code>和<code>actions</code>。</p><p><code>pattern</code>匹配模式可以是以下其中一种：</p><ul><li>正则表达式；</li><li>关系表达式；</li><li>模式<code>1</code>，模式<code>2</code>：指定一行的范围；</li><li><code>BEGIN</code>：指定在第一行文本被处理之前所发生的操作；</li><li><code>END</code>：指定在最后一行文本被读取之后发送的操作；</li></ul><p><code>actions</code>命令由一个或多个命令、函数或者表达式组成，他们之间由换行符或分号隔开，并位于大括号内，一般有以下四种情况：</p><ul><li>变量或数组赋值；</li><li>输出命令，例如<code>printf</code>或<code>print</code>；</li><li>内置函数；</li><li>流控制语句，例如<code>if</code>、<code>while</code>或<code>for</code>语句；</li></ul><p><code>awk</code>命令的执行方式：</p><ul><li>通过命令行执行：其语法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;awk &lt;span class=&quot;hljs-string&quot;&gt;&#x27;awk程序语句&#x27;&lt;/span&gt; 数据文件&lt;/code&gt;<br></code></pre></td></tr></table></figure><ul><li>执行 <code>awk</code>脚本：其语法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;#注意：awk脚本文件是后缀名为.awk的文件&lt;/span&gt;<br>awk &lt;span class=&quot;hljs-operator&quot;&gt;-f&lt;/span&gt; awk脚本文件 数据文件&lt;/code&gt;<br></code></pre></td></tr></table></figure><ul><li>可执行脚本文件：即在<code>shell</code>文件中指定解析器为<code>#! /bin/awk -f</code></li></ul><h3 id="awk命令的匹配模式">awk命令的匹配模式</h3><p>在<code>awk</code>命令的匹配模式主要包括：关系表达式、正则表达式、混合模式、区间模式、<code>BEGIN</code>模式、<code>END</code>模式等。</p><h4 id="关系表达式"><strong>1) 关系表达式</strong></h4><p><code>awk</code>命令中的关系运算符如下表所示：</p><table><thead><tr class="header"><th>运算符</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>&gt;</td><td>大于</td></tr><tr class="even"><td>&gt;=</td><td>大于等于</td></tr><tr class="odd"><td>&lt;</td><td>小于</td></tr><tr class="even"><td>&lt;=</td><td>小于等于</td></tr><tr class="odd"><td>==</td><td>等于</td></tr><tr class="even"><td>!=</td><td>不等于</td></tr><tr class="odd"><td>~</td><td>匹配运算：例如<code>$1~/^A</code>表示匹配第一个字段以字符<code>A</code>开头的记录</td></tr><tr class="even"><td>!~</td><td>不匹配运算</td></tr></tbody></table><h4 id="正则表达式"><strong>2) 正则表达式</strong></h4><p><code>awk</code>支持以正则表达式为匹配模式，其基本语法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs vala has-numbering&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;#regexp 表示正则表达式&lt;/span&gt;<br>/regexp/&lt;/code&gt;<br></code></pre></td></tr></table></figure><p>例如：输出以字符u开头的文本行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;&lt;span class=&quot;hljs-shebang&quot;&gt;#! /bin/bash&lt;/span&gt;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#filename:test.sh&lt;/span&gt;<br><br>result=`awk &lt;span class=&quot;hljs-string&quot;&gt;&#x27;/^u/ &#123;print&#125;&#x27;&lt;/span&gt; shell.md`<br><br>&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$result&lt;/span&gt;&quot;&lt;/span&gt;<br><br>&lt;span class=&quot;hljs-comment&quot;&gt;#输出结果：&lt;/span&gt;<br>$ sh test.sh <br>&lt;span class=&quot;hljs-built_in&quot;&gt;unset&lt;/span&gt; variable_name<br>&lt;span class=&quot;hljs-built_in&quot;&gt;unset&lt;/span&gt; var<br>until<br>until<br>&lt;span class=&quot;hljs-built_in&quot;&gt;unset&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;-f&lt;/span&gt; 函数名&lt;/code&gt;<br></code></pre></td></tr></table></figure><h4 id="混合模式"><strong>3) 混合模式</strong></h4><p>在<code>awk</code>命令的匹配模式中，可以通过逻辑运算符使用多个表达式组成命令；基本逻辑运算符如下表所示：</p><table><thead><tr class="header"><th>运算符</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>&amp;&amp;</td><td>逻辑与</td></tr><tr class="even"><td>||</td><td>逻辑或</td></tr><tr class="odd"><td>!</td><td>逻辑非</td></tr></tbody></table><h4 id="区间模式"><strong>4) 区间模式</strong></h4><p><code>awk</code>命令支持区间模式，其语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs  has-numbering&quot;&gt;pattern1, pattern2&lt;/code&gt;<br></code></pre></td></tr></table></figure><p>例如：第一个匹配模式是：以字符串<code>one</code>开头的文本行；第二个匹配模式是：第<code>3</code>字段等于<code>14</code>的文本行；所有符合这两个匹配模式之间的文本行都会被输出；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;&lt;span class=&quot;hljs-shebang&quot;&gt;#!/bin/bash&lt;/span&gt;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#filename:test.sh&lt;/span&gt;<br><br>result=`awk &lt;span class=&quot;hljs-string&quot;&gt;&#x27;/^one/ , $3==14 &#123;print&#125;&#x27;&lt;/span&gt; test.txt`<br><br>&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$result&lt;/span&gt;&quot;&lt;/span&gt;<br><br>&lt;span class=&quot;hljs-comment&quot;&gt;#执行结果：&lt;/span&gt;<br>$ sh test.sh <br>one     &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;<br>two     &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;25&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;<br>three   &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;31&lt;/span&gt;<br>four    &lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;26&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;35&lt;/span&gt;<br>five    &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;40&lt;/span&gt;<br>&lt;/code&gt;<br></code></pre></td></tr></table></figure><h4 id="begin模式"><strong>5) BEGIN模式</strong></h4><p><code>BEGIN</code>模式是<code>awk</code>命令一种特殊的内置模式，在<code>awk</code>读取数据之前对执行的操作；</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs livecodeserver has-numbering&quot;&gt;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#! /usr/bin/awk -f&lt;/span&gt;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#filename:test.sh&lt;/span&gt;<br><br>BEGIN &#123; print &lt;span class=&quot;hljs-string&quot;&gt;&quot;Beging operator.&quot;&lt;/span&gt; &#125;<br>/^&lt;span class=&quot;hljs-constant&quot;&gt;one&lt;/span&gt;/ , $&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;==&lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt; &#123;print&#125;<br><br>&lt;span class=&quot;hljs-comment&quot;&gt;#执行结果：&lt;/span&gt;<br>$ ./test.sh test.txt<br>Beging operator.<br>&lt;span class=&quot;hljs-constant&quot;&gt;one&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;<br>&lt;span class=&quot;hljs-constant&quot;&gt;two&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;25&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;<br>&lt;span class=&quot;hljs-constant&quot;&gt;three&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;31&lt;/span&gt;<br>&lt;span class=&quot;hljs-constant&quot;&gt;four&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;26&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;35&lt;/span&gt;<br>&lt;span class=&quot;hljs-constant&quot;&gt;five&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;40&lt;/span&gt;<br>&lt;/code&gt;<br></code></pre></td></tr></table></figure><h4 id="end模式"><strong>6) END模式</strong></h4><p><code>END</code>模式是在处理完数据之后执行的操作；例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs asciidoc has-numbering&quot;&gt;#! /usr/bin/awk -f<br># /usr/bin/env awk -f<br>#filename:test.sh<br><br>BEGIN &#123;<br>&lt;span class=&quot;hljs-code&quot;&gt;    print &quot;Beging operator.&quot;&lt;/span&gt;<br>&lt;span class=&quot;hljs-code&quot;&gt;    print &quot;====================&quot;&lt;/span&gt;<br>&#125;<br>/^one/ , $3==14 &#123;print&#125;<br><br>END &#123;<br>&lt;span class=&quot;hljs-code&quot;&gt;    print &quot;====================&quot;&lt;/span&gt;<br>&lt;span class=&quot;hljs-code&quot;&gt;    print &quot;Ending operator.&quot;&lt;/span&gt;<br>&#125;<br><br><br>#执行结果：<br>$ ./test.sh test.txt<br>&lt;span class=&quot;hljs-header&quot;&gt;Beging operator.<br>====================&lt;/span&gt;<br>one     10  20  30<br>two     15  25  20<br>three   20  15  31<br>four    16  26  35<br>&lt;span class=&quot;hljs-header&quot;&gt;five    11  14  40<br>====================&lt;/span&gt;<br>Ending operator.<br>&lt;/code&gt;<br></code></pre></td></tr></table></figure><h3 id="awk-变量">awk 变量</h3><p><code>awk</code>中的用户自定义的变量一般在<code>BEGIN</code>模式中定义；</p><h4 id="系统内置变量">系统内置变量</h4><p><code>awk</code>的常用系统内置变量如下表所示：</p><table><colgroup><col style="width: 11%" /><col style="width: 88%" /></colgroup><thead><tr class="header"><th>变量</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>$0</td><td>当前记录（存放着整个行的内容）</td></tr><tr class="even"><td><span class="math inline">\(1~\)</span>n</td><td>当前记录的第n个字段，字段间由FS分隔</td></tr><tr class="odd"><td>FS</td><td>输入字段分隔符 默认是空格或Tab</td></tr><tr class="even"><td>NF</td><td>当前记录中的字段个数，就是有多少列</td></tr><tr class="odd"><td>NR</td><td>已经读出的记录数，就是行号，从1开始，如果有多个文件话，这个值也是不断累加中</td></tr><tr class="even"><td>FNR</td><td>当前记录数，与NR不同的是，这个值会是各个文件自己的行号</td></tr><tr class="odd"><td>RS</td><td>输入的记录分隔符， 默认为换行符</td></tr><tr class="even"><td>OFS</td><td>输出字段分隔符， 默认也是空格</td></tr><tr class="odd"><td>ORS</td><td>输出的记录分隔符，默认为换行符</td></tr><tr class="even"><td>FILENAME</td><td>当前输入文件的名字</td></tr></tbody></table><h4 id="运算符">运算符</h4><p><code>awk</code>命令支持常用的运算符：算术运算符、赋值运算符、条件运算符、逻辑运算法、关系运算符等操作；</p><p><strong>算术运算符</strong></p><p><code>awk</code>命令直接支持的算术运算符有：加+、减-、乘*、除/、模运算%、指数运算^；</p><p><strong>赋值运算符</strong></p><p><code>awk</code>命令常用的赋值运算符有：=、+=、-=、*=、/=、%=、^=；</p><p><strong>条件运算符</strong></p><p><code>awk</code>命令的条件运算符语法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs  has-numbering&quot;&gt;表达式?值1:值2&lt;/code&gt;<br></code></pre></td></tr></table></figure><p><strong>逻辑运算法</strong></p><p><code>awk</code>命令支持的逻辑运算符：&amp;&amp;、||、！；</p><p><strong>关系运算符</strong></p><p><code>awk</code>命令支持的关系运算符：&gt;、&gt;=、&lt;、&lt;=、==、！=、<sub>、!</sub>；</p><h4 id="awk-函数"><strong>awk 函数</strong></h4><p><code>awk</code>提供了许多系统函数，用户也可以自定义函数；</p><p><strong>字符串函数</strong></p><p>常用的字符串函数有：</p><table><colgroup><col style="width: 34%" /><col style="width: 65%" /></colgroup><thead><tr class="header"><th>函数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>index(string1, string2)</td><td>返回 string2 在string1中第一次出现的位置</td></tr><tr class="even"><td>length(string)</td><td>返回string的长度</td></tr><tr class="odd"><td>match(string,regexp)</td><td>返回string中符合regexp的子字符串</td></tr><tr class="even"><td>split(string,array,seperator)</td><td>根据分隔符seperator，将字符串string分隔成多个字段，并存储到数组array中</td></tr><tr class="odd"><td>sub(regexp,replacement,string)</td><td>将字符串string第一个符合regexp的子字符串替换成replacement</td></tr><tr class="even"><td>gsub(regexp,replacement,string)</td><td>将字符串string中符合regexp的全部子字符串都替换成replacement</td></tr><tr class="odd"><td>substr(string,start,[length])</td><td>从字符串string的start位置开始截取长度为length(若指定了length，否则一直截取到字符串string结束)字串</td></tr></tbody></table><p><strong>算术函数</strong></p><p>常用的算术函数有：int(x)、sqrt(x)、exp(x)、log(x)、sin(x)、cos(x)、rand(x)、srand(x)；2)</p><p>实例：</p><ul><li>$ awk '/^(no|so)/' test-----打印所有以模式no或so开头的行。</li><li>$ awk '/<a href="#fn1" class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a>/{print $1}'test-----如果记录以n或s开头，就打印这个记录。</li><li>$ awk '<span class="math inline">\(1 ~/[0-9][0-9]\)</span>/(print$1}' test-----如果第一个域以两个数字结束就打印这个记录。</li><li>$ awk '$1 == 100 || $2 &lt; 50'test-----如果第一个或等于100或者第二个域小于50，则打印该行。</li><li>$ awk '$1 != 10' test-----如果第一个域不等于10就打印该行。</li><li>$ awk '/test/{print $1 + 10}'test-----如果记录包含正则表达式test，则第一个域加10并打印出来。</li><li>$ awk '{print ($1 &gt; 5 ? "ok "$1: "error"$1)}'test-----如果第一个域大于5则打印问号后面的表达式值，否则打印冒号后面的表达式值。</li><li>$ awk '/<sup>root/,/</sup>mysql/'test----打印以正则表达式root开头的记录到以正则表达式mysql开头的记录范围内的所有记录。如果找到一个新的正则表达式root开头的记录，则继续打印直到下一个以正则表达式mysql开头的记录为止，或到文件末尾。</li></ul><h2 id="可执行文件elf">11. 可执行文件ELF</h2><h3 id="elf简介">ELF简介</h3><p>ELF文件除了包含程序本身的<strong>代码</strong>和<strong>静态数据</strong>之外，还包括一些用来<strong>描述它们的信息</strong>，否则我们连代码和数据之间的分界线在哪里都不知道。这些信息描述了可执行文件的组织形式,不同组织形式形成了不同格式的可执行文件,</p><p>Windows主流的可执行文件是PE(Portable Executable)格式</p><p>GNU/Linux主要使用ELF(Executable and LinkableFormat)格式。ELF是GNU/Linux可执行文件的标准格式,这是因为GNU/Linux遵循System V ABI(Application Binary Interface).</p><p><strong>为什么堆和栈的内容没有放入可执行文件里面?程序运行时刻用到的堆和栈又是怎么来的?</strong></p><p>ELF文件提供了两个视角来组织一个可执行文件。</p><p>一是面向链接过程的section视角，这个视角提供了用于链接与重定位的信息(例如符号表)。</p><p>二是面向执行的segment视角，这个视角提供了用于加载可执行文件的信息。</p><p>通过readelf命令,我们还可以看到section和segment之间的映射关系：一个segment可能由0个或多个section组成,但一个section可能不被包含于任何segment中。</p><p>ELF中采用<strong>program header table</strong>来管理segment, programheadertable的一个表项描述了一个segment的所有属性，包括<strong>类型</strong>,<strong>虚拟地址</strong>，<strong>标志</strong>，<strong>对齐方式</strong>，以及<strong>文件内偏移量</strong>和<strong>segment大小</strong>。根据这些信息,我们就可以知道需要加载可执行文件的哪些字节了，同时我们也可以看到，加载一个可执行文件并不是加载它所包含的所有内容，只要加载那些与运行时刻相关的内容就可以了,例如调试信息和符号表就不必加载。我们可以通过判断segment的Type属性是否为<strong>PT_LOAD</strong>来判断一个segment是否需要加载。更多与ELF文件相关的信息,请参考</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">man 5 elf<br></code></pre></td></tr></table></figure><h3 id="readelf命令">readelf命令</h3><p>readelf命令，一般用于查看ELF格式的文件信息，常见的文件如在Linux上的可执行文件，动态库(<em>.so)或者静态库(</em>.a)等包含ELF格式的文件。</p><p><strong>选项 -h</strong>(elfheader)，显示elf文件开始的文件头信息，如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">ELF Header:<br>  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 <br>  Class:                             ELF64<br>  Data:                              2<span class="hljs-string">&#x27;s complement, little endian</span><br><span class="hljs-string">  Version:                           1 (current)</span><br><span class="hljs-string">  OS/ABI:                            UNIX - System V</span><br><span class="hljs-string">  ABI Version:                       0</span><br><span class="hljs-string">  Type:                              EXEC (Executable file)</span><br><span class="hljs-string">  Machine:                           RISC-V</span><br><span class="hljs-string">  Version:                           0x1</span><br><span class="hljs-string">  Entry point address:               0x80000000</span><br><span class="hljs-string">  Start of program headers:          64 (bytes into file)</span><br><span class="hljs-string">  Start of section headers:          50496 (bytes into file)</span><br><span class="hljs-string">  Flags:                             0x4, double-float ABI</span><br><span class="hljs-string">  Size of this header:               64 (bytes)</span><br><span class="hljs-string">  Size of program headers:           56 (bytes)</span><br><span class="hljs-string">  Number of program headers:         2</span><br><span class="hljs-string">  Size of section headers:           64 (bytes)</span><br><span class="hljs-string">  Number of section headers:         13</span><br><span class="hljs-string">  Section header string table index: 12</span><br></code></pre></td></tr></table></figure><p><strong>选项 -l</strong>(program headers),segments显示程序头（段头）信息(如果有数据的话)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">Elf file <span class="hljs-built_in">type</span> is EXEC (Executable file)<br>Entry point 0x80000000<br>There are 2 program headers, starting at offset 64<br><br>Program Headers:<br>  Type           Offset             VirtAddr           PhysAddr<br>                 FileSiz            MemSiz              Flags  Align<br>  LOAD           0x0000000000001000 0x0000000080000000 0x0000000080000000<br>                 0x000000000000a6c8 0x0000000000014028  RWE    0x1000<br>  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000<br>                 0x0000000000000000 0x0000000000000000  RW     0x10<br><br> Section to Segment mapping:<br>  Segment Sections...<br>   00     .text .rodata .sdata2.__func__.1497 .sdata2.mainargs .data .data.heap .data.lut .bss <br>   01     <br></code></pre></td></tr></table></figure><p>找出每一个需要加载的segment的<strong>Offset</strong>，<strong>VirtAddr</strong>，<strong>FileSiz</strong>和<strong>MemSiz</strong>这些参数。<strong>相对文件偏移Offset指出相应segment的内容从ELF文件的第Offset字节开始,在文件中的大小为FileSiz, 它需要被分配到以VirtAddr为首地址的虚拟内存位置,在内存中它占用大小为MemSiz。</strong>也就是说，这个segment使用的内存就是[VirtAddr, VirtAddr +MemSiz)这一连续区间，然后将segment的内容从ELF文件中读入到这一内存区间，<strong>并将[VirtAddr+ FileSiz, VirtAddr + MemSiz)对应的物理区间清零。</strong></p><p>关于程序从何而来, 可以参考一篇文章: <ahref="https://www.tenouk.com/ModuleW.html">COMPILER, ASSEMBLER, LINKERAND LOADER: A BRIEF STORY</a></p><section id="footnotes" class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"><p>ns<a href="#fnref1" class="footnote-back"role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;添加环境变量&quot;&gt;&lt;strong&gt;1.添加环境变量&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;https://www.cnblogs.com/youyoui/p/10680329.html&lt;/p&gt;
&lt;p&gt;1、Linux的环境变量是保存在变量PATH中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;export&lt;/strong&gt;命令显示当前系统定义的所有环境变量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;echo $PATH&lt;/strong&gt;命令输出当前的PATH环境变量的值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、Linux环境变量值之间是通过冒号分隔的( : )&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;临时添加环境变量PATH：&lt;/strong&gt;可通过export命令，如将/usr/local/nginx/sbin/目录临时添加到环境变量中&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;export&lt;/span&gt; PATH=/usr/local/nginx/sbin/:&lt;span class=&quot;hljs-variable&quot;&gt;$PATH&lt;/span&gt;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://zmailee.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>DPI学习笔记</title>
    <link href="https://zmailee.github.io/2022/10/30/DPI/"/>
    <id>https://zmailee.github.io/2022/10/30/DPI/</id>
    <published>2022-10-30T14:39:30.544Z</published>
    <updated>2022-10-31T04:20:01.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dpi学习笔记">DPI学习笔记</h1><h2 id="一dpi前世-pli">一、DPI前世-PLI</h2><p>首先思考几个问题：</p><ul><li><p>用户如何获得Verilog描述的电路的内部<strong>数据结构信息</strong>?</p></li><li><p>EDA仿真器在仿真verilog的tb时，FSDB波形是如何生成的？</p></li><li><p>$display，$stop，$finish等系统函数,如何被不同EDA仿真器识别?</p></li></ul><p>除了底层描述硬件的能力，Verilog同样应该具有与上层交互的能力，基于此<strong>VerilogPLI</strong>(Programming LanguageInterface)应运而生，它是一种从Verilog代码调用C/C++函数的机制。可以说PLI的出现是Verilog语言在硬件设计方面如此成功的原因之一。使用PLI，第三方公司和最终用户可以扩展商业Verilog仿真器的功能。在Verilog代码中调用的函数称为<strong>系统调用</strong>。内置系统函数的一个示例是$display，$stop，$finish等。PLI允许用户创建自定义系统调用，这是Verilog语法不允许我们做的事情。基于PLI其实我们可以做的更多：</p><span id="more"></span><ul><li>功耗分析</li><li>代码覆盖率工具</li><li>修改Verilog仿真数据结构 - 更准确的延迟。</li><li>自定义输出显示</li><li>协同仿真。</li><li>设计调试工具。</li><li>仿真结果分析</li><li>C模型接口加速仿真</li><li>Testbench建模</li></ul><p>为了实现PLI的这些应用，C代码应该可以访问Verilog仿真器的内部数据结构。为方便起见，VerilogPLI提供了一些称为acc例程或简单访问例程的东西。还有第二组例程，称为tf例程，或简称为任务和函数例程。tf和acc是PLI 1.0例程，并且非常庞大且陈旧。</p><h3 id="vpi">VPI</h3><p>Verilog程序接口（VPI），最初称为PLI2.0，主要用于C编程语言的接口。它允许行为Verilog代码调用C函数，C函数调用标准Verilog系统任务。Verilog程序接口是IEEE1364编程语言接口标准的一部分;该标准的最新版本是从2005年开始的。VPI也取代了已弃用的PLI。</p><p>虽然PLI1被弃用而支持VPI（又名PLI2），但由于其广泛记录的tf_put，tf_get函数接口在许多verilog参考书中有所描述，因此PLI1仍常用于VPI。</p><p>综上所述：PLI有三个libraries, TF(task/function) interface,ACC(access) interface, 以及VPI(Verilog ProceduralInterface)，三者的时间先后顺序是1985-1989-1995而前面两个已经在IEEE1364-2005中被删除。</p><h3 id="pli的应用和维护问题">PLI的应用和维护问题</h3><p>写PLI例程，是件痛苦的事情，不仅需要好几个步骤，更让人头痛的是PLI三个库中提供的一大堆难记的标准例程名字。写完了，还必须再用checktf例程，calltf例程包一层，才能在verilog中调用。另外一个问题，就是谁来负责写这些PLI例程，通常情况下，不管是设计者还是验证人员通常都不需要了解仿真器生成的verilog数据结构。我们只是使用者，不是生产者。</p><p>编写PLI应用程序很难</p><ul><li>必须学习奇怪的PLI术语</li><li>必须了解PLI库中的内容</li><li>必须创建checktf例程，calltf例程等</li></ul><p>将PLI应用程序链接到仿真器很难</p><ul><li>涉及多个步骤</li><li>每个仿真器都不同</li><li>谁链接？设计工程师 or EDA工程师？</li><li>管理多个PLI应用程序很困难</li><li>PLI代码很少与二进制兼容</li><li>必须为每个仿真器重新编译</li></ul><p>综上，PLI的缺点它严重阻碍着设计者和验证者使用更高级的语言来加强verilog语言的功力，尤其是日益复杂的设计和验证工作迫切需要一种新的编程语言接口，为我们提供强大的生产力的时候。</p><p>SystemVerilog引入了<strong>DPI(Direct ProgrammingInterface</strong>)，能够更简洁的连接C/C++或者其他非<ahref="https://so.csdn.net/so/search?q=Verilog&amp;spm=1001.2101.3001.7020">Verilog</a>的编程语言。</p><h2 id="二dpi横空出世">二、DPI横空出世</h2><p>在2003年IEEE 1800 SV LRM3.1a中提出了一种直接的编程语言接口DPI。SystemVerilogDPI是将SystemVerilog与外部语言连接的一个接口。理论上外部语言可以是C，C++，SystemC以及其他语言。但是现在，SystemVerilog仅为C语言定义了一个外部语言层。</p><p>DPI由两层组成：SystemVerilog层和外部语言层。两层都彼此隔离。实际使用哪种编程语言作为外语是透明的，与此接口的SystemVerilog端无关。</p><p>DPI标准源自两个专有接口，一个来自Synopsys公司的VCSDirectC接口，另一个是来自Co-Design公司（已被Synopsys收购）的SystemSimCblend接口。这两个专有接口起初是为他们各自的仿真器开发的，而不是一个能够工作在任何仿真器上的标准。后来Synopsys公司将这两个技术捐献给了Accellera组织，Accellera的SystemVerilog标准委员会把这两个捐献技术合并在一起，并定义了DPI接口的语义，使得DPI能够与任何Verilog仿真器一起工作。</p><h3 id="两者之间的关系">两者之间的关系</h3><p>DPI不是PLI的替代品。相反，他们的角色是互补的。PLI和VPI将来会继续存在并蓬勃发展，这主要有两个原因。</p><ul><li>PLI和VPI是经过时间考验的方法确保了对仿真器数据库的保护。PLI和VPI将继续提供访问设计数据的安全机制，同时保持仿真器数据库的完整性。</li><li>对于许多人来说，PLI在未来几年仍将是首选接口语言。有许多应用程序使用PLI和VPI编写。将维护这些遗留应用程序，创建新的附加组件，并且将出现全新的应用程序-全部使用PLI和VPI。在Accellera决定对整个SystemVerilog语言提供完整的VPI支持时，PLI也就证明了其顽强的生命力。你熟悉和喜爱的VPI方法现在将适用于SystemVerilog的整个对象集。</li></ul><h2 id="三为什么需要dpi">三、为什么需要DPI？</h2><p>DPI出现的动机是双重的。</p><p>方法论要求接口应该允许<strong>构建异构系统</strong>（设计或测试平台），其中一些组件可以用除SystemVerilog之外的语言（或更多语言）编写。</p><p>另一方面，需要一种简单有效的方法来连接通常用C或C++编写的现有代码，而不需要PLI或VPI的知识开销。</p><p><strong>DPI遵循黑盒的原则</strong>：组件的规范和实现明确分开，实际实现对系统的其余部分是透明的。因此，实现的实际编程语言也是透明的，尽管该标准仅定义了C链接语义。SystemVerilog代码与外部语言之间的分离基于使用函数作为SystemVerilog中的自然封装单元。总的来说，任何函数都可以被视为一个黑盒子，并以透明的方式在SystemVerilog或外部语言中实现，而无需更改其调用。</p><p>现实世界中，C和C++应该是IC世界，最被广泛使用的高级编程语言，而且有很多开源的代码和工具都是C或者C++代码编写。按照DPI的方法论，我们理应为C和C++世界通往SV世界打开一扇门。</p><p>DPI是在SystemVerilog LRM 3.1a 2003中定义的关键字DPI-C是在SystemVerilog IEEE 1800-2012中定义的关键字</p><p>目前DPI已弃用，应替换为DPI-C</p><p>DPI-C的出现使得SV和C之间的互动变得简单直接</p><ul><li>使用C函数作为SV函数/任务，反之亦然</li><li>直接调用C/C++库中的函数</li><li>直接将输入传递给函数</li><li>直接从C/C++函数接收返回值</li></ul><p>其是在验证领域，使用C/C++代码作为参考模型很普遍</p><ul><li>使用功能强大的OpenSSL、OpenCV等开源库</li><li>参考模型是由设计师或软件团队使用C/C++编写的</li><li>使用MATLAB生成DPI组件</li></ul><p>SystemVerilog可以调用C，C可以调用SV</p><ul><li>支持函数和任务</li><li>在协同仿真中很有用</li></ul><p>（1）在模块级乃至子系统级的验证，使用SV就完全够用了，而在更上面的层级，例如系统级，多采用大量的C代码组成。那么<strong>为了完成测试用例从子系统到系统级的复用</strong>，我们最好在子系统级开始就有意识地建立支持C测试的环境，并且使用一些基于C的测试用例，这样才能使得整体具有更好的复用性。</p><p>（2）处理器的需要。子系统测试时，不一定本身自带了处理器的硬件实例(Verilog编写的)，因此在构建子系统时还要考虑如何模拟外部处理器对子系统的访问行为。当然，我们直接加上一个外部的处理器实例是完全可以的，等验证完子系统的功能后再撤掉就行。注意，这个处理器实例也是verilog编写的。但是，这种方法也存在了一些弊端：即使这个外部处理器再小巧，但硬件体积还是过大了，肯定会影响整个仿真的速度；针对不同子系统的预留接口(APB/AHB/AXI等)，处理器子系统也要进行对应的调整吧；这种真实的处理器，必然要处理C代码，所以要进行编译、转换成二进制bin文件以及下载到memory中，还是太麻烦；还需要额外的启动配置文件，而且仿真时需要额外的额时间进行初始化。总结一下真实处理器的弊端，那就是麻烦，处理C代码也繁琐，影响了仿真速度。</p><h2 id="四dpi基础">四、DPI基础</h2><h3 id="数据类型转换">4.1数据类型转换</h3><h4 id="数据映射关系">数据映射关系</h4><p>当SV与C环境交互时，会发生数据交换。数据需要在两端以完全相同的方式解释，否则通信将失败。SystemVerilog和C之间的数据交换通常使用DPI-C接口完成，该接口标准化类型对应关系和基本API（另请参见仿真器安装路径下的svdpi.h）。</p><p>大多数SystemVerilog数据类型在C语言中具有直接的对应关系，而其他（例如，4值类型，数组）需要DPI-C定义的类型和API。</p><p>通过DPI传递的每个变量都有两个相匹配的定义，一个在SV中，一个在C语言中。在使用中必须，确认使用的是兼容的数据类型。<strong>C输出数据给SV，只能通过指针的方式输出</strong>。所以输出数据也是在SV中建立空间，然后在C中得到指针，将值写进去，这样C的内存空间的控制不会影响到SV端。</p><table><colgroup><col style="width: 37%" /><col style="width: 32%" /><col style="width: 30%" /></colgroup><thead><tr class="header"><th style="text-align: left;">SystemVerilog</th><th>C(input)</th><th>C(output)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">byte</td><td>char</td><td>char*</td></tr><tr class="even"><td style="text-align: left;">shortint</td><td>short int</td><td>short int*</td></tr><tr class="odd"><td style="text-align: left;">int</td><td>int</td><td>int*</td></tr><tr class="even"><td style="text-align: left;">longint</td><td>long int</td><td>long int*</td></tr><tr class="odd"><td style="text-align: left;">shortreal</td><td>float</td><td>float*</td></tr><tr class="even"><td style="text-align: left;">real</td><td>double</td><td>double*</td></tr><tr class="odd"><td style="text-align: left;">string</td><td>const char*</td><td>char**</td></tr><tr class="even"><td style="text-align: left;">string[n]</td><td>const char**</td><td>char**</td></tr><tr class="odd"><td style="text-align: left;">bit</td><td>svBit(unsigned char)</td><td>svBit*(unsigned char)</td></tr><tr class="even"><td style="text-align: left;">logic, reg</td><td>svLogic</td><td>svLogic*</td></tr><tr class="odd"><td style="text-align: left;">bit[N:0]</td><td>const svBitVecVal*</td><td>svBitVecVal*</td></tr><tr class="even"><td style="text-align: left;">logic[N:0], reg[N:0]</td><td>const svLogicVecVal*</td><td>svLogicVecVal*</td></tr><tr class="odd"><td style="text-align: left;">Open array[] (import only)</td><td>const svOpenArrayHandle</td><td>svOpenArrayHandle</td></tr><tr class="even"><td style="text-align: left;">chandle</td><td>const void*</td><td>void*</td></tr></tbody></table><p>DPI调入C函数返回值，SV LRM推荐使用<strong>small values</strong>：void,byte,shortint,int,longint,real,shortreal,chandle,string,bit,logic</p><p>不推荐使用bit[6:0]或者logic[6:0]这样的值，因为这样需要返回一个svBitVecVal或者svLogicVecVal的指针。</p><h4 id="四值逻辑变量转换关系"><strong>四值逻辑变量转换关系</strong></h4><p>假设SV一侧有一个logicf，那么它在C一侧，会用一个无符号的字节来保存。分为aval和bval，其中aval保存在最低位，bval保存在紧邻的高位。</p><table><thead><tr class="header"><th>四状态值</th><th>bval</th><th>aval</th></tr></thead><tbody><tr class="odd"><td>0</td><td>0</td><td>0</td></tr><tr class="even"><td>1</td><td>0</td><td>1</td></tr><tr class="odd"><td>Z</td><td>1</td><td>0</td></tr><tr class="even"><td>X</td><td>1</td><td>1</td></tr></tbody></table><p>1’b0 -&gt; 0x0，1’b1 -&gt; 0x1，1’bz -&gt; 0x2，1’bx -&gt; 0x3</p><p>logic[31:0]word，采用一对32bit的变量来表示，aval[31:0]与bval[31:0]。</p><p>在导入数组时，需要同时赋值aval和bval，如data[31:0]，例如要将data[0]=1，那么需要data[0].aval=1,data[0].bval=0;</p><h3 id="接口调用">4.2接口调用</h3><p>通过import声明C任务和函数的原型：</p><ul><li><strong>带有返回值</strong>的C函数被映射成一个sv的<strong>function</strong></li><li><strong>void类型</strong>的C函数被映射为一个sv的<strong>task</strong>或<strong>voidfunction</strong></li></ul><p>如果C函数名和SV中的命名冲突，可以在import导入时，赋予新的函数名。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> test(); <br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> test=<span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_test(); <span class="hljs-comment">//将C中的test-&gt;my_test</span><br></code></pre></td></tr></table></figure><h4 id="参数传递">参数传递</h4><p>在C和SV中有两种传递参数的方法：</p><ul><li>按值传递：被调用者函数将使用来自调用者的参数的副本</li><li>通过引用传递：被调用者函数将使用来自调用者的参数的指针/引用</li></ul><p>如果函数正在更改其参数的值，则仅当参数通过引用传递时，更改才会在函数外部可见。当参数按值传递时，对函数内部完成的参数的任何更改都不会在其外部可见。</p><p>在SystemVerilog中，按值或按引用传递由参数方向确定。在C中，通过值或引用传递是由参数类型是否为指针确定的。默认情况下，SV和C都按值传递参数。</p><p>导入的C函数参数可以作为输入，输出或inout（双向）</p><ul><li>输入的行为就像在调用时复制到C函数中一样，C函数不应修改输入参数</li><li>当函数返回时，输出的行为就像复制到Verilog中一样</li><li>Inouts的行为就像在调用中复制一样，并在返回时复制出来</li></ul><p>除非另有说明，否则假定参数为输入</p><p>SV提供了丰富的数据类型可以作为参数：</p><ul><li>void, byte, shortint, int, longint, real, shortreal, chandle, time,integer, and string</li><li>Scalar values of type bit and logic</li><li>Packed arrays, structs, and unions composed of types bit andlogic</li><li>Types constructed from the supported types with the help of theconstructs: struct , union , Unpacked array , typedef</li></ul><p>返回值数据类型：</p><ul><li>void, byte, shortint, int, longint, real, shortreal, chandle, andstring</li><li>Scalar values of type bit and logic</li><li>Restrictions apply for import and export functions</li></ul><h4 id="参数方向">参数方向</h4><blockquote><p>对于参数方向，支持<strong>input,output以及inout</strong>。<strong>Ref则不被支持</strong>。<strong>默认是input</strong></p><p>例子：Import “DPI-C” function int add(input int a, b, output intsum);</p></blockquote><h4 id="导入方式"><strong>导入方式</strong></h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">import</span> “DPI-C” <span class="hljs-keyword">context</span> <span class="hljs-keyword">task</span> core0_thread();<br></code></pre></td></tr></table></figure><ul><li><p>pure：函数严格根据输入来计算输出，跟外部环境没有其它交互。作为pure函数，函数的结果必须仅仅依赖于通过形参传递进来的数值。优点在于仿真器可以执行优化以改进仿真性能。Pure函数不能使用全局或者静态变量，不能执行文件I/O操作，不能访问操作系统环境变量，不能调用来自VerilogPLI库的函数。<strong>只有没有输出或者inout的非void函数（必须有return值）可以被指定成pure。Pure函数不能作为Verilog任务导入。</strong></p></li><li><p>context：表示的是<strong>关联导入</strong>，关联类型会导致额外的开销。contextC函数明确函数声明所在工作域的Verilog的层次。可以是void函数，可以有输出和inout参数，可以从C库调用函数（用于文件I/O等)，可以调用PLI库中的许多函数，这使得被导入的C函数能够调用来自PLI或者VPI库的函数，从而DPI函数可以充分利用PLI的优势特性，比如写仿真器的log文件以及Verilog源代码打开的文件。</p></li><li><p>generic：函数使用了全局变量，但没有调用任何的PLI（缺省下为此类型）。本文把那些既没有明确声明为pure，也没有声明为context的函数称为generic函数(SystemVerilog标准没有给除了pure或context之外的函数特定的称呼)。genericC函数可以作为Verilog函数或者Verilog任务导入。任务或者函数可以由输入、输出以及inout的参数。函数可以有一个返回值，或者声明为void。genericC函数不允许调用VerilogPLI函数，不能访问除了参数以外的任何数据，只能修改这些参数。</p></li></ul><p><strong>正确的声明导入的函数为pure还是context是用户的责任</strong>。缺省情况下，DPI函数假定是generic函数。调用一个不正确声明成pure的C函数可能返回不正确或者不一致的结果，导致不可预测的运行时错误，甚至于让仿真崩溃。同样，如果一个C函数访问VerilogPLI库或者其他API库，却没有声明为context函数，会导致不可预见的仿真结果甚至仿真崩溃。</p><h4 id="导出方式"><strong>导出方式</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">export “DPI-C” function sv_display;<br></code></pre></td></tr></table></figure><p>注意后面不需要加括号和参数，如果需要改变名字，则可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">export “DPI-C” dpi_writew = task writew;<br></code></pre></td></tr></table></figure><p>而在C一侧，则只需要extern void sv_display();</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> dpi_writew(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> addr, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> data);<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> dpi_readw(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> addr, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *data);<br></code></pre></td></tr></table></figure><h4 id="绑定别名">绑定别名</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> gloval_name_space;<br>    <span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span>  <span class="hljs-keyword">context</span> <span class="hljs-keyword">task</span> sv_import_task ();<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> gloval_name_space1;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span>  <span class="hljs-keyword">context</span> C_task1=<span class="hljs-keyword">task</span> sv_import_task ();<br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-keyword">module</span> gloval_name_space2;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span>  <span class="hljs-keyword">context</span> C_task2=<span class="hljs-keyword">task</span> sv_import_task ();<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">export</span> <span class="hljs-string">&quot;DPI-C&quot;</span> f_plus = <span class="hljs-keyword">function</span> f ; <span class="hljs-comment">// &quot;f&quot; exported as &quot;f_plus&quot;</span><br><span class="hljs-keyword">export</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-keyword">function</span> f; <span class="hljs-comment">// &quot;f&quot; exported under its own name</span><br></code></pre></td></tr></table></figure><p>C的命名空间是全局可见的。sv_import_task中的声明变为等于C的链接名称。对于所有模块，名称必须是唯一的。 C的链接是全局性的。因此，上面是一种别名C链接名称的方法。SV上的名称相同，但在C上，使用别名C_task1和C_task2执行链接。</p><h4 id="dpi-各种使用方式">DPI 各种使用方式</h4><ul><li>通过import定义的函数可以在任何位置</li><li>在Verilog模块中</li><li>在SystemVerilog interface中</li><li>在SystemVerilog package中</li><li>在SystemVerilog“编译单元”中</li><li>import声明必须具有参数的原型</li><li>必须与C函数中的参数数完全匹配</li><li>必须指定兼容的数据类型</li><li>可以在多个位置导入相同的C功能</li><li>每个原型必须完全相同</li><li>更好的方法是在包中定义一个导入</li></ul><h3 id="常用数据类型映射">4.3常用数据类型映射</h3><ul><li>SV byte -&gt; C char</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_byte(input byte i_value, output byte result);<br>import &quot;DPI-C&quot; function byte get_byte(input byte i_value);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_byte</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> i_value, <span class="hljs-type">char</span>* result)</span>;<br><span class="hljs-type">char</span> <span class="hljs-title function_">get_byte</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> i_value)</span>;<br></code></pre></td></tr></table></figure><ul><li>SV shortint -&gt; C short int</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_shortint(input shortint i_value, output shortint result);<br>import &quot;DPI-C&quot; function shortint get_shortint(input shortint i_value);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_shortint</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> i_value, <span class="hljs-type">short</span> <span class="hljs-type">int</span>* result)</span>;<br><span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_shortint</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> i_value)</span>;<br></code></pre></td></tr></table></figure><ul><li>SV int -&gt; C int</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_int(input int i_value, output int result);<br>import &quot;DPI-C&quot; function int get_int(input int i_value);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_int</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> i_value, <span class="hljs-type">int</span>* result)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">get_int</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> i_value)</span>;<br></code></pre></td></tr></table></figure><ul><li>SV longint -&gt; C long int</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_longint(input longint i_value, output longint result);<br>import &quot;DPI-C&quot; function longint get_longint(input longint i_value);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_longint</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> i_value, <span class="hljs-type">long</span> <span class="hljs-type">int</span>* result)</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_longint</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> i_value)</span>;<br></code></pre></td></tr></table></figure><ul><li>SV real -&gt; C double</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_real(input real i_value, output real result);<br>import &quot;DPI-C&quot; function real get_real(input real i_value);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_real</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> i_value, <span class="hljs-type">double</span>* result)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">get_real</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> i_value)</span>;<br></code></pre></td></tr></table></figure><ul><li>SV string -&gt; C char*</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_string(input string i_value, output string result);<br>import &quot;DPI-C&quot; function string get_string(input string i_value);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_string</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* i_value, <span class="hljs-type">char</span>** result)</span>;<br><span class="hljs-type">char</span>* <span class="hljs-title function_">get_string</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* i_value)</span>;<br></code></pre></td></tr></table></figure><ul><li>SV chandle -&gt; C void*</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_chandle(output chandle result);<br>import &quot;DPI-C&quot; function chandle get_chandle();<br>import &quot;DPI-C&quot; function void call_chandle(input chandle i_value, output int result);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_chandle</span><span class="hljs-params">(<span class="hljs-type">void</span>** result)</span>;<br><span class="hljs-type">void</span>** <span class="hljs-title function_">get_chandle</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">call_chandle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* i_value, <span class="hljs-type">int</span>* o_value)</span>;<br></code></pre></td></tr></table></figure><ul><li>SV bit -&gt; C svbit</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_bit(input bit i_value, output bit result);<br>import &quot;DPI-C&quot; function bit get_bit(input bit i_value);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_bit</span><span class="hljs-params">(<span class="hljs-type">const</span> svBit i_value, svBit* result)</span>;<br>svBit <span class="hljs-title function_">get_bit</span><span class="hljs-params">(<span class="hljs-type">const</span> svBit i_value)</span>;<br></code></pre></td></tr></table></figure><ul><li>SV bit[n:0] -&gt; C svBitVecVal</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_bit_vector(input bit[`BIT_ARRAY_SIZE - 1 : 0] i_val, output bit[`BIT_ARRAY_SIZE - 1 : 0] result);<br>import &quot;DPI-C&quot; function bit[`BIT_ARRAY_SIZE - 1 : 0] get_bit_vector(input bit[`BIT_ARRAY_SIZE - 1 : 0] i_val);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_bit_vector</span><span class="hljs-params">(<span class="hljs-type">const</span> svBitVecVal* i_value, svBitVecVal* result)</span>;<br>svBitVecVal <span class="hljs-title function_">get_bit_vector</span><span class="hljs-params">(<span class="hljs-type">const</span> svBitVecVal* i_value)</span>;<br></code></pre></td></tr></table></figure><ul><li>SV logic -&gt; C svLogic</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_logic(input logic i_value, output logic result);<br>import &quot;DPI-C&quot; function logic get_logic(input logic i_value);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_logic</span><span class="hljs-params">(<span class="hljs-type">const</span> svLogic i_value, svLogic* result)</span>;<br>svLogic <span class="hljs-title function_">get_logic</span><span class="hljs-params">(<span class="hljs-type">const</span> svLogic i_value)</span>;<br></code></pre></td></tr></table></figure><ul><li>SV reg -&gt; C svLogic</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_reg(input reg i_value, output reg result);<br>import &quot;DPI-C&quot; function reg  get_reg(input reg i_value);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_reg</span><span class="hljs-params">(<span class="hljs-type">const</span> svLogic i_value, svLogic* result)</span>;<br>svLogic <span class="hljs-title function_">get_reg</span><span class="hljs-params">(<span class="hljs-type">const</span> svLogic i_value)</span>;<br></code></pre></td></tr></table></figure><ul><li>SV logic[n:0] -&gt; C svLogicVecVal</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_logic_vector(input logic[`LOGIC_ARRAY_SIZE - 1 : 0] i_val, output logic[`LOGIC_ARRAY_SIZE - 1 : 0] result, input int asize);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br>svLogicVecVal*  <span class="hljs-title function_">get_logic_vector</span><span class="hljs-params">(<span class="hljs-type">const</span> svLogicVecVal* i_value, <span class="hljs-type">int</span> asize)</span>;<br></code></pre></td></tr></table></figure><ul><li>SV reg[n:0] -&gt; C svLogicVecVal</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_reg_vector(input reg[\`REG_ARRAY_SIZE - 1 : 0] i_val, output reg[\`REG_ARRAY_SIZE - 1 : 0] result, input int asize);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_reg_vector</span><span class="hljs-params">(<span class="hljs-type">const</span> svLogicVecVal* i_value, svLogicVecVal* result, <span class="hljs-type">int</span> asize)</span>;<br></code></pre></td></tr></table></figure><ul><li>SV int[] -&gt; C svOpenArrayHandle</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_unsized_int_array(input int i_value[], output int result[]);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_unsized_int_array</span><span class="hljs-params">(<span class="hljs-type">const</span> svOpenArrayHandle i_value, svOpenArrayHandle result)</span>;<br></code></pre></td></tr></table></figure><ul><li>SV struct -&gt; C struct</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>`define BIT_ARRAY_SIZE 16<br>typedef struct &#123;<br>byte aByte;<br>int anInt;<br>bit aBit;<br>longint aLongInt;<br>bit[`BIT_ARRAY_SIZE-1:0] aBitVector;<br>&#125; dpi_c_ex_s;<br>import &quot;DPI-C&quot; function void compute_struct(input dpi_c_ex_s i_value, output dpi_c_ex_s result);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dpi_c_ex_s</span> &#123;</span><br><span class="hljs-type">char</span> aChar;<br><span class="hljs-type">int</span> anInt;<br>svBit aBit;<br><span class="hljs-type">long</span> <span class="hljs-type">int</span> aLongInt;<br>svBitVecVal aBitVector;<br>&#125; dpi_c_ex_s;<br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_struct</span><span class="hljs-params">(<span class="hljs-type">const</span> dpi_c_ex_s* i_value, dpi_c_ex_s* output)</span>;<br></code></pre></td></tr></table></figure><h2 id="五dpi进阶">五、DPI进阶</h2><h4 id="压缩数组packed-arrays">5.1压缩数组（Packed arrays）</h4><p>压缩数组被视为数组和单个值，既可以访问整个值，也可以将其分成更小的元素。与非压缩的数组不同，它存储为一组连续的没有未使用空间的位。可以方便地将其作为数组元素进行访问。</p><p><strong>压缩数组：在数据类型标识符名称之前声明的维度</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">bit [7:0] p; // packed array of scalar bit types<br>bit [3:0][7:0] bytes // 4 bytes packed into 32-bits<br></code></pre></td></tr></table></figure><p>具有预定义宽度的整数类型不能声明为带维度的压缩数组。这些类型是byte，shortint，int，longint，integer和time。虽然是具有预定义宽度n的整数类型，它不是一个打包数组，但其自身是可以分解为子字段的，可以理解为一个具有单个[n-1:0]维度的压缩数组类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">byte c2; // same as bit signed [7:0] c2;`<br>integer i1; // same as logic signed [31:0] i1;<br></code></pre></td></tr></table></figure><h4 id="非压缩数组unpacked-arrays">5.2非压缩数组（Unpacked arrays）</h4><p>非压缩数组可以由任何数据类型组成。每个固定大小的维度应由地址范围[0:size-1]或单个正数[size]表示，以指定固定大小的非压缩数组的大小。</p><p><strong>非压缩数组：在数据类型标识符名称后声明的维度</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">bit u [7:0];<br>int Array[0:7][0:31]; // array declaration using ranges<br>int Array[8][32]; // array declaration using sizes<br></code></pre></td></tr></table></figure><p>SV 索引 [min：max] -&gt; C端数组索引从0开始</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">SV: a[1:7] -&gt; C: a[7]<br>SV: a[1] -&gt; C: a[0], SV a[7] -&gt; C: a[6]<br></code></pre></td></tr></table></figure><p>SV压缩数组被当做一维数组对待</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">//SV: a[l][m][n] -&gt; C: a[n+m*k+l*j*k]<br>bit[5:2]a; a[5]=1 a[4]=0 a[3]=1 a[2]=0; -&gt; C: a=10<br></code></pre></td></tr></table></figure><p><strong>所有数据类型最终都等同于最多32位的压缩数组</strong> SV byte-&gt; C int，只使用低8位 <strong>C char数组无法映射到SVbyte类型的非压缩数组</strong></p><h4 id="混合压缩和非压缩的数组">5.3混合压缩和非压缩的数组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">bit [3:0] Bytes [0:2] [0:5]<br></code></pre></td></tr></table></figure><figure><img src="DPI.assets/bfa1d0786bdd9d9435609c5734afe49a.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4id="sv_packed_data_nelemswidth">5.4SV_PACKED_DATA_NELEMS（width）</h4><p>该宏将位转换为元素数，在bit和word之间转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">include <span class="hljs-string">&quot;svdpi.h&quot;</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">packet_C</span><span class="hljs-params">(<span class="hljs-type">const</span> svLogicVecVal* packet)</span> &#123;<br>   <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span>  elements=SV_PACKED_DATA_NELEMS(<span class="hljs-number">128</span>);<br>   svLogicVecVal mem[elements];<br><br>   <span class="hljs-built_in">memcpy</span>(mem,packet,<span class="hljs-keyword">sizeof</span>(mem));<br>   io_printf(“C: data from SV side\n<span class="hljs-string">&quot;);</span><br><span class="hljs-string">   for (unsigned i=0;i&lt; elements;i++)&#123;</span><br><span class="hljs-string">      io_printf(&quot;</span>mem[%<span class="hljs-number">2</span>d]=&#123;%<span class="hljs-number">4</span>x,%<span class="hljs-number">4</span>x&#125;\n<span class="hljs-string">&quot;,i,mem[i].aval,mem[i].bval);</span><br><span class="hljs-string">   &#125;    </span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">module test;<br>import &quot;DPI-C&quot; function void packet_C( input logic [127:0]);<br><br>   logic [127:0] packet;<br>   initial　begin<br>      packet=128&#x27;h1234_5678_aaaa_bbbb_cccc_dddd_eeee_ffff;<br>      $display(“SV: data sent to C side: %x&quot;,packet);<br>      packet_C(packet);<br>   end<br><br>endmodule<br></code></pre></td></tr></table></figure><h4 id="bit和logic标量和矢量的使用">5.5bit和logic标量和矢量的使用</h4><p>在svdpi.h的头文件中，有如下自定义类型声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint8_t</span> svScalar;<br><span class="hljs-keyword">typedef</span> svScalar svBit; <span class="hljs-comment">/* scalar */</span><br><span class="hljs-keyword">typedef</span> svScalar svLogic; <span class="hljs-comment">/* scalar */</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> svBitVecVal;<br><br>Typedef <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>     <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> aval;<br>     <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bval;<br>&#125; svLogicVecVal;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;svdpi.h&gt;</span> </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(svLogic a)</span>&#123; <br><span class="hljs-keyword">if</span>(a == <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; a is 0 \n&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a == <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; a is 1 \n&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a == <span class="hljs-number">2</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; a is x \n&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a == <span class="hljs-number">3</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; a is z \n&quot;</span>);<br>&#125; <br><span class="hljs-type">void</span>  <span class="hljs-title function_">displaylogicvec</span><span class="hljs-params">(svLogicVecVal *n)</span> &#123;<br>       <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot; data = %d control = %d\n&quot;</span>, n-&gt;aval, n-&gt;bval) ; <br>&#125;<br><br><span class="hljs-type">void</span>  <span class="hljs-title function_">displaybitvec</span><span class="hljs-params">(<span class="hljs-type">const</span> svBitVecVal *k)</span> &#123; <br>       <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot; data = %d\n &quot;</span>, k) ; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="在dpi中使用压缩数组packed-arrays">5.6在DPI中使用压缩数组（PackedArrays）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;svdpi.h&quot;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_nums</span> <span class="hljs-params">(svLogicVecVal nums[<span class="hljs-number">10</span>])</span>&#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;<br>    nums[i] = i ;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">program main; <br>import &quot;DPI-C&quot; function void get_nums(output logic [15:0] nums[10]); <br>logic [15:0] nums[10]; <br><br>initial begin <br>get_nums(nums); <br>foreach (nums[i]) <br>$display(i,nums[i]); <br>end <br>  <br>endprogram <br></code></pre></td></tr></table></figure><h4 id="dpi中使用开放数组open-arrays">5.7DPI中使用开放数组（Openarrays）</h4><p>压缩数组维度，非压缩维度或两个维度的大小可以保持未指定，这种情况称为开放数组（或未定义大小的数组）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">include &lt;stdio.h&gt;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;svdpi.h&gt;</span> </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">pass_array</span><span class="hljs-params">(<span class="hljs-type">const</span> svOpenArrayHandle dy_ar )</span> &#123; <br>  <span class="hljs-type">int</span> i; <br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Array Pointer is %x \n&quot;</span>, svGetArrayPtr(dyn_arr) ); <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Lower index %d \n&quot;</span>, svLow(dyn_arr,<span class="hljs-number">1</span>)); <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Higher index %d \n&quot;</span>, svHigh(dyn_arr, <span class="hljs-number">1</span>) ); <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Left index %d \n&quot;</span>, svLeft(dyn_arr,<span class="hljs-number">1</span>)); <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Right index %d \n&quot;</span>, svRight(dyn_arr, <span class="hljs-number">1</span>) ); <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Length of array %d \n&quot;</span>, svLength(dyn_arr,<span class="hljs-number">1</span>) ); <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Incremental %d \n&quot;</span>,svIncrement(dyn_arr,<span class="hljs-number">1</span>)); <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Dimentions of Array %d \n&quot;</span>, svDimensions(dyn_arr )); <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Size of Array in bytes %d \n&quot;</span>, svSizeOfArray(dyn_arr) ); <br>  <span class="hljs-keyword">for</span> (i= svRight(dy_ar,<span class="hljs-number">1</span>); i &lt;= svLeft(dy_ar,<span class="hljs-number">1</span>); i++) &#123; <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;C: %d %d \n&quot;</span>, i, *(<span class="hljs-type">int</span>*)svGetArrElemPtr1(dy_ar, i) ); <br>  &#125; <br>&#125; <br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">program main; <br>int fxd_arr_1[8:3]; <br>int fxd_arr_2[12:1]; <br>import &quot;DPI-C&quot; context function void pass_array(input int dyn_arr[] ); <br><br>initial begin <br>for (int i = 3; i&lt;=8 ; i++) begin <br>fxd_arr_1[i] = $random(); <br>$display(&quot;SV:fxd_arr_1 %0d %d &quot;,i, fxd_arr_1[i] ); <br>end <br>pass_array( fxd_arr_1 ); <br><br>for (int i = 1; i&lt;=12 ; i++) begin <br>fxd_arr_2[i] = $random() ; <br>$display(&quot;SV: fxd_arr_2 %0d %d &quot;,i, fxd_arr_2[i] ); <br>end <br>pass_array( fxd_arr_2 ); <br><br>end <br>endprogram<br></code></pre></td></tr></table></figure><ul><li>Passing fxd_arr_1 to C Array Pointer is 80fdc58 Lower index 3 Higherindex 8 Left index 8 Right index 3 Length of array 6 Incremental 1Dimentions of Array 1 Size of Array in bytes 24</li><li>Passing fxd_arr_2 to C Array Pointer is 80fdc70 Lower index 1 Higherindex 13 Left index 1 Right index 13 Length of array 13 Incremental -1Dimentions of Array 1 Size of Array in bytes 52</li></ul><p><strong>开放数组提供了一系列查询和访问数组的方法</strong></p><table><colgroup><col style="width: 54%" /><col style="width: 45%" /></colgroup><thead><tr class="header"><th>function</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>int svLeft(const svOpenArrayHandle h, int d);</td><td>Left bound for dimension d</td></tr><tr class="even"><td>int svRight(h, d)</td><td>Right bound for dimension d</td></tr><tr class="odd"><td>int svLow(h, d)</td><td>Low bound for dimension d</td></tr><tr class="even"><td>int svHigh(h, d)</td><td>High bound for dimension d</td></tr><tr class="odd"><td>int svIncrement(h, d)</td><td>If left &gt;= right 1 else -1</td></tr><tr class="even"><td>int svSize(h, d)</td><td>Number of elements in dimension d: svHigh−svLow+1</td></tr><tr class="odd"><td>int svDimensions(h)</td><td>Number of dimensions in open array</td></tr><tr class="even"><td>int svSizeOfArray(h)</td><td>Total size of array in bytes</td></tr><tr class="odd"><td>void *svGetArrayPtr(const svOpenArrayHandle h)</td><td>storage for the entire array</td></tr><tr class="even"><td>void svGetArrElemPtr(const svOpenArrayHandle h, int i1, …)</td><td>an element in the array</td></tr><tr class="odd"><td>void *svGetArrElemPtr1(h, i1)</td><td>an element in a 1-D array</td></tr><tr class="even"><td>void *svGetArrElemPtr2(h, i1, i2)</td><td>an element in a 2-D array</td></tr><tr class="odd"><td>void *svGetArrElemPtr3(h, i1, i2, i3)</td><td>an element in a 3-D array</td></tr></tbody></table><h4 id="在dpi中使用结构体">5.8在DPI中使用结构体</h4><p>在传递<code>struct</code>数据类型时，数据被打包到数组中并从SV传递到C，然后数组被解码回到C中的<code>struct</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;svdpi.h&quot;</span> </span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123; <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span> <br>  <span class="hljs-type">int</span> a; <br>  <span class="hljs-type">int</span> b; <br>  <span class="hljs-type">char</span> c; <br>&#125; C_struct; <br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">export_func</span><span class="hljs-params">(svBitVecVal x[<span class="hljs-number">3</span>])</span>; <br><span class="hljs-type">void</span> <span class="hljs-title function_">import_func</span><span class="hljs-params">()</span> &#123; <br>  C_struct s_data; <br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>]; <br><br>  s_data.a = <span class="hljs-number">51</span>; <br>  s_data.b = <span class="hljs-number">242</span>; <br>  s_data.c = <span class="hljs-number">35</span>; <br>  <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;C : s_data.a = %d\n&quot;</span>, s_data.a ); <br>  <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;C : s_data.b = %d\n&quot;</span>, s_data.b ); <br>  <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;C : s_data.c = %d\n&quot;</span>, s_data.c ); <br><br>  arr[<span class="hljs-number">0</span>] = s_data.a ; <br>  arr[<span class="hljs-number">1</span>] = s_data.b ; <br>  arr[<span class="hljs-number">2</span>] = s_data.c ; <br>  export_func(arr); <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">program main; <br><br>export &quot;DPI-C&quot; function export_func; <br>import &quot;DPI-C&quot; function void import_func(); <br><br>typedef struct packed&#123; <br>  int a; <br>  int b; <br>  byte c; <br>&#125; SV_struct; <br><br>function void export_func(input int arr[3]); <br>SV_struct s_data; <br><br>  s_data.a = arr[0]; <br>  s_data.b = arr[1]; <br>  s_data.c = arr[2]; <br>  $display(&quot; SV: s_data.a = %0d&quot;, s_data.a ); <br>  $display(&quot; SV: s_data.b = %0d&quot;, s_data.b ); <br>  $display(&quot; SV: s_data.c = %0d \n&quot;, s_data.c ); <br>endfunction <br><br>initial begin <br>import_func(); <br>end <br><br>endprogram<br></code></pre></td></tr></table></figure><p>在SV和C/C++代码使用定义的未压缩的结构体数据类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;svdpi.h&quot;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> b;<br>&#125;mystruct;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">mydisplay</span><span class="hljs-params">(mystruct *s1)</span>&#123;<br><span class="hljs-type">int</span> s2;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;C: gets values from SV, s1.a=%d, s1.b=%d\\\\\\\\\\\\\\\\n&quot;</span>,s1-&gt;a,s1-&gt;b);<br>s1-&gt;a = <span class="hljs-number">100</span>;<br>s1-&gt;b = <span class="hljs-number">200</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;C: set values,  s1.a=%d, s1.b=%d\\\\\\\\\\\\\\\\n&quot;</span>,s1-&gt;a,s1-&gt;b);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">program p1;<br>typedef struct &#123;<br>int a;<br>int b;<br>&#125; mystruct;<br><br>import &quot;DPI-C&quot; function void mydisplay(inout mystruct s1);<br>mystruct s1;<br>initial begin<br>s1.a =10;<br>s1.b =20;<br>$display(&quot;SV: s1.a=%0d,s1.b=%0d&quot;,s1.a,s1.b);<br><br>mydisplay(s1);<br>$display(&quot;SV after DPI call: s1.a=%0d,s1.b=%0d&quot;,s1.a,s1.b);<br>end <br><br>endprogram<br></code></pre></td></tr></table></figure><p>试着将上面例子中sv端结构体，改为packed类型，试试看C端打印信息会是什么样的？</p><p>压缩的结构体是包含packed保留字的结构体。 在结构内，保证了位连续性。因此，成员也必须是矢量类型。 （不要混合real /shortreal。）如果混合使用2值或者4值逻辑，它们将在内存布局方面生成4个值，因此不要混用它们。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;svdpi.h&quot;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(svBitVecVal*)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">struct_operation</span><span class="hljs-params">()</span>&#123;<br>   svBitVecVal rgb;<br>   svPutPartselBit(&amp;rgb,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>);<span class="hljs-comment">//b</span><br>   svPutPartselBit(&amp;rgb,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>);<span class="hljs-comment">//g</span><br>   svPutPartselBit(&amp;rgb,<span class="hljs-number">3</span>,<span class="hljs-number">16</span>,<span class="hljs-number">8</span>);<span class="hljs-comment">//r</span><br>   func(&amp;rgb);<br>   svBitVecVal blue=<span class="hljs-number">0</span>;<br>   svBitVecVal red=<span class="hljs-number">0</span>;<br>   svBitVecVal green=<span class="hljs-number">0</span>;<br>   svGetPartselBit(&amp;blue,&amp;rgb,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>);<br>   svGetPartselBit(&amp;green,&amp;rgb,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>);<br>   svGetPartselBit(&amp;red,&amp;rgb,<span class="hljs-number">16</span>,<span class="hljs-number">8</span>);<br><br>   io_printf(<span class="hljs-string">&quot;C: data from SV side. red %3d green %3d blue %3d.\\\\\\\\\\\\\\\\n&quot;</span>,red,green,blue);<br><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">module root_scope;<br>    export &quot;DPI-C&quot; function func;<br>    import &quot;DPI-C&quot; context task struct_operation();<br><br>   typedef struct packed &#123;<br>      byte red;//MSB<br>      byte green;<br>      byte blue;//LSB ↑<br>   &#125; RGB_TYPE;<br><br>   function void func(inout RGB_TYPE A);<br>      $display(&quot;SV: data from C side. red=%3d blue=%3d green=%3d.&quot;,A.red,A.green,A.blue);<br>      A.blue=101;<br>      A.green=102;<br>      A.red=103;<br>      $display(&quot;SV: data change for C side read.&quot;);<br>          <br>   endfunction<br><br>   initial begin<br>      struct_operation();<br>   end<br><br>endmodule<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;dpi学习笔记&quot;&gt;DPI学习笔记&lt;/h1&gt;
&lt;h2 id=&quot;一dpi前世-pli&quot;&gt;一、DPI前世-PLI&lt;/h2&gt;
&lt;p&gt;首先思考几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;用户如何获得Verilog描述的电路的内部&lt;strong&gt;数据结构信息&lt;/strong&gt;?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;EDA仿真器在仿真verilog的tb时，FSDB波形是如何生成的？&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;$display，$stop，$finish等系统函数,如何被不同EDA仿真器识别?&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了底层描述硬件的能力，Verilog同样应该具有与上层交互的能力，基于此&lt;strong&gt;Verilog
PLI&lt;/strong&gt;(Programming Language
Interface)应运而生，它是一种从Verilog代码调用C/C++函数的机制。可以说PLI的出现是Verilog语言在硬件设计方面如此成功的原因之一。
使用PLI，第三方公司和最终用户可以扩展商业Verilog仿真器的功能。在Verilog代码中调用的函数称为&lt;strong&gt;系统调用&lt;/strong&gt;。内置系统函数的一个示例是$display，$stop，$finish等。
PLI允许用户创建自定义系统调用，这是Verilog语法不允许我们做的事情。基于PLI其实我们可以做的更多：&lt;/p&gt;</summary>
    
    
    
    <category term="基础课程" scheme="https://zmailee.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="SystemVerilog" scheme="https://zmailee.github.io/tags/SystemVerilog/"/>
    
    <category term="DPI-C" scheme="https://zmailee.github.io/tags/DPI-C/"/>
    
  </entry>
  
  <entry>
    <title>智能计算系统</title>
    <link href="https://zmailee.github.io/2022/10/19/%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E7%B3%BB%E7%BB%9F/"/>
    <id>https://zmailee.github.io/2022/10/19/%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-10-19T12:40:32.173Z</published>
    <updated>2022-11-04T05:25:24.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章概述">第一章：概述</h1><p><strong>智能计算系统是智能的物质载体</strong></p><p>学习目标：学习人工智能系统的设计与研究，掌握对智能计算的完整软硬件技术栈。</p><h2 id="人工智能三个流派">人工智能三个流派</h2><p><strong>行为主义</strong>：基于控制论，构建感知-动作型控制系统<strong>符号主义</strong>：基于符号逻辑的方法，用逻辑表示知识和求解问题<strong>连接主义</strong>：基于大脑中神经元细胞连接的计算模型，用<strong>人工神经网络</strong>来<strong>拟合</strong>智能行为</p><span id="more"></span><h2 id="深度学习的局限性">深度学习的局限性</h2><p>深度学习是一把梯子，而不是火箭</p><ul><li>泛化能力有限</li><li>缺乏推理能力</li><li>缺乏可解释性</li><li>鲁棒性欠佳</li></ul><h2 id="异构智能计算系统">异构智能计算系统</h2><p>满足智能计算的算力增长需求，降低能耗比</p><h1 id="第二章神经网络基础">第二章：神经网络基础</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;第一章概述&quot;&gt;第一章：概述&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;智能计算系统是智能的物质载体&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;学习目标：学习人工智能系统的设计与研究，掌握对智能计算的完整软硬件技术栈。&lt;/p&gt;
&lt;h2 id=&quot;人工智能三个流派&quot;&gt;人工智能三个流派&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;行为主义&lt;/strong&gt;：基于控制论，构建感知-动作型控制系统
&lt;strong&gt;符号主义&lt;/strong&gt;：基于符号逻辑的方法，用逻辑表示知识和求解问题
&lt;strong&gt;连接主义&lt;/strong&gt;：基于大脑中神经元细胞连接的计算模型，用&lt;strong&gt;人工神经网络&lt;/strong&gt;来&lt;strong&gt;拟合&lt;/strong&gt;智能行为&lt;/p&gt;</summary>
    
    
    
    <category term="基础课程" scheme="https://zmailee.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="人工智能" scheme="https://zmailee.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="计算机体系结构" scheme="https://zmailee.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="https://zmailee.github.io/2022/10/19/Git/"/>
    <id>https://zmailee.github.io/2022/10/19/Git/</id>
    <published>2022-10-19T12:40:32.168Z</published>
    <updated>2022-10-31T02:31:51.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git">Git</h1><p>用git执行下面语句时报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push -u origin master<br>error: failed to push some refs to ‘xxxxx’<br>hint: Updates were rejected because the tip of your current branch is behind<br>hint: its remote counterpart. Integrate the remote changes (e.g.<br>hint: ‘git pull …’) before pushing again.<br>hint: See the ‘Note about fast-forwards’ <span class="hljs-keyword">in</span> ‘git push --<span class="hljs-built_in">help</span>’ <span class="hljs-keyword">for</span> details.<br></code></pre></td></tr></table></figure><p>原因：<strong>Github端已经产生了commit没有同步到本地端</strong></p><span id="more"></span><p>1.使用强制push的方法，这样会使远程修改丢失</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push -u origin master -f<br></code></pre></td></tr></table></figure><p>2.先将远程repository修改pull下来再push</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull origin master<br>git push -u origin master<br></code></pre></td></tr></table></figure><p>结果又报refusing to merge unrelated histories</p><p>解决方案</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull origin master --allow-unrelated-histories<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;git&quot;&gt;Git&lt;/h1&gt;
&lt;p&gt;用git执行下面语句时报错&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;git push -u origin master&lt;br&gt;error: failed to push some refs to ‘xxxxx’&lt;br&gt;hint: Updates were rejected because the tip of your current branch is behind&lt;br&gt;hint: its remote counterpart. Integrate the remote changes (e.g.&lt;br&gt;hint: ‘git pull …’) before pushing again.&lt;br&gt;hint: See the ‘Note about fast-forwards’ &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; ‘git push --&lt;span class=&quot;hljs-built_in&quot;&gt;help&lt;/span&gt;’ &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; details.&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;原因：&lt;strong&gt;Github端已经产生了commit没有同步到本地端&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="https://zmailee.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
</feed>
