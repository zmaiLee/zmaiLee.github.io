<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mai&#39;s blog</title>
  
  <subtitle>try my best</subtitle>
  <link href="https://zmailee.github.io/atom.xml" rel="self"/>
  
  <link href="https://zmailee.github.io/"/>
  <updated>2022-11-19T08:28:20.229Z</updated>
  <id>https://zmailee.github.io/</id>
  
  <author>
    <name>zmaiLee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Makefile学习笔记</title>
    <link href="https://zmailee.github.io/2022/11/19/Makefile/"/>
    <id>https://zmailee.github.io/2022/11/19/Makefile/</id>
    <published>2022-11-19T08:26:36.585Z</published>
    <updated>2022-11-19T08:28:20.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="makefile学习笔记">Makefile学习笔记</h1><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># Check for sanity to avoid later confusion</span><br><span class="hljs-keyword">ifneq</span> (<span class="hljs-variable">$(words <span class="hljs-variable">$(CURDIR)</span>)</span>,1)<br> <span class="hljs-variable">$(<span class="hljs-built_in">error</span> Unsupported: GNU Make cannot build in directories containing spaces, build elsewhere: &#x27;<span class="hljs-variable">$(CURDIR)</span>&#x27;)</span><br><span class="hljs-keyword">endif</span><br><br><span class="hljs-comment"># This is intended to be a minimal example.  Before copying this to start a</span><br><span class="hljs-comment"># real project, it is better to start with a more complete example,</span><br><span class="hljs-comment"># e.g. examples/make_tracing_c.</span><br><br><span class="hljs-comment"># If $VERILATOR_ROOT isn&#x27;t in the environment, we assume it is part of a</span><br><span class="hljs-comment"># package install, and verilator is in your path. Otherwise find the</span><br><span class="hljs-comment"># binary relative to $VERILATOR_ROOT (such as when inside the git sources).</span><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(VERILATOR_ROOT)</span>,)<br>VERILATOR = verilator<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">export</span> VERILATOR_ROOT<br>VERILATOR = <span class="hljs-variable">$(VERILATOR_ROOT)</span>/bin/verilator<br><span class="hljs-keyword">endif</span><br><br><span class="hljs-section">default:</span><br>@echo <span class="hljs-string">&quot;-- Verilator hello-world simple example&quot;</span><br>@echo <span class="hljs-string">&quot;-- VERILATE &amp; BUILD --------&quot;</span><br><span class="hljs-variable">$(VERILATOR)</span> -cc --exe --build -j top.v sim_main.cpp<br>@echo <span class="hljs-string">&quot;-- RUN ---------------------&quot;</span><br>obj_dir/Vtop<br>@echo <span class="hljs-string">&quot;-- DONE --------------------&quot;</span><br>@echo <span class="hljs-string">&quot;Note: Once this example is understood, see examples/make_tracing_c.&quot;</span><br>@echo <span class="hljs-string">&quot;Note: Also see the EXAMPLE section in the verilator manpage/document.&quot;</span><br><br></code></pre></td></tr></table></figure><p><code>$@</code>目标文件，<code>$^</code>所有的依赖文件，<code>$&lt;</code>第一个依赖文件</p><p>这个规则表示所有的 .o文件都是依赖与相应的.c文件的</p><h1 id="basename-names">$(basename NAMES…)</h1><p>函数名称：取前缀函数—basename。函数功能：从文件名序列“NAMES…”中取出各个文件名的前缀部分。前缀部分指的是文件名中最后一个点号之前的部分。返回值：空格分割的文件名序列“NAMES…”中各个文件的前缀序列。如果文件没有前缀，则返回空字串。</p><h1 id="notdir-names">$(notdir NAMES…)</h1><p>剥离文件的绝对路径，只保留文件名</p><h1 id="addprefix-前缀-待加前缀的">$(addprefix 前缀 待加前缀的)。</h1><p>函数功能：为“NAMES…”中的每一个文件名添加前缀“PREFIX”。参数“NAMES…”是空格分割的文件名序列，将“SUFFIX”添加到此序列的每一个文件名之前。</p><p>返回值：以单空格分割的添加了前缀“PREFIX”的文件名序列。</p><p>示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> src/,foo bar)</span><br></code></pre></td></tr></table></figure><p>返回值为“src/foo src/bar”</p><h1id="makefile使用-d选项更改宏定义记得要clean">Makefile使用-D选项更改宏定义，记得要clean</h1><p>1、Makefile文件，如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CC_OPTS += -DMakefle_D=2<br><br><span class="hljs-section">all:testD</span><br>    echo <span class="hljs-string">&quot;done&quot;</span><br><span class="hljs-section">testD:testD.c</span><br>    gcc testD.c -o testD <span class="hljs-variable">$(CC_OPTS)</span><br></code></pre></td></tr></table></figure><p>2、testD.c文件，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Makefle_D = %d\n&quot;</span>, Makefle_D);<br>&#125;<br></code></pre></td></tr></table></figure><p>改动-DMakefle_D=2为-DMakefle_D=3或者-DMakefle_D=4，编译测试.发现改动后，testD.c并不会重新编译。所以在Makefile里面改宏定义，记得要clean</p><h1 id="makefile调用函数">Makefile调用函数</h1><p>调用GNU make的内置函数：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(function arguments)</span><br></code></pre></td></tr></table></figure><p>想调用用户自定义的函数，则只能使用call函数来间接调用：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">PHONY: all</span><br><span class="hljs-keyword">define</span> func    <br>@echo <span class="hljs-string">&quot;pram1 = $(0)&quot;</span>    <br>@echo <span class="hljs-string">&quot;pram2 = $(1)&quot;</span><br><span class="hljs-keyword">endef</span><br><span class="hljs-section">all:    </span><br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> func, hello zhaixue.cc)</span><br></code></pre></td></tr></table></figure><p>给函数传递的参数，在函数内部可以使用<spanclass="math inline">\((0)、\)</span>(1)…直接使用。call函数是唯一一个可以用来创建新的参数化的函数。call函数不仅可以用来调用一个用户自定义函数并传参，还可以向一个表达式传参：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">call</span> &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;...)</span><br></code></pre></td></tr></table></figure><p>当 make 执行这个函数时，expression表达式中的参数变量，如<spanclass="math inline">\((1)，\)</span>(2)，$(3)等，会被参数parm1，parm2，parm3依次取代。而expression的返回值就是call 函数的返回值。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: all</span><br>param = $(1) $(2)<br>reverse_param = $(2) $(1)<br>str1 = <span class="hljs-variable">$(<span class="hljs-built_in">call</span> param, hello, zhaixue.cc)</span><br>str2 = <span class="hljs-variable">$(<span class="hljs-built_in">call</span> reverse_param, hello, zhaixue.cc)</span><br><span class="hljs-section">all:    </span><br>@echo <span class="hljs-string">&quot;str1 = <span class="hljs-variable">$(str1)</span>&quot;</span>    <br>@echo <span class="hljs-string">&quot;str2 = <span class="hljs-variable">$(str2)</span>&quot;</span><br></code></pre></td></tr></table></figure><p>执行make命令，运行结果为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># make</span><br>str1 =  hello  zhaixue.cc<br>str2 =  zhaixue.cc  hello<br></code></pre></td></tr></table></figure><h1 id="跟我一起写-makefile"><strong>跟我一起写 Makefile</strong></h1><p>https://blog.csdn.net/haoel/article/details/2886</p><h2 id="一.基础使用">一.基础使用</h2><h3id="关于程序的编译和链接"><strong>1.关于程序的编译和链接</strong></h3><p><strong>编译(compile):</strong>把源文件编译成中间代码文件，在Windows.obj 文件，UNIX .o 文件，即 ObjectFile。一般来说，每个源文件都应该对应于一个中间目标文件</p><p><strong>编译:</strong>把源文件编译成中间代码文件,Windows是 .obj文件，UNIX是 .o 文件，即 Object File，每个源文件都对应o文件</p><p><strong>链接(link):</strong>把大量的Object File合成执行文件</p><p>链接时，主要是链接函数和全局变量，可以使用o文件来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的ObjectFile，在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，要给o文件打个包，在Windows下这种包叫“库文件”.lib（LibraryFile) ，在UNIX下，是Archive File， .a 文件</p><p>源文件首先生成.o，再由.o生成执行文件</p><p>在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成ObjectFile。而在链接程序时，链接器会在所有的ObjectFile中找寻函数的实现，如果找不到，会报链LinkerError，链接器未能找到函数的实现。你需要指定函数的Object File.</p><h3 id="基本目标">2.基本目标</h3><p>1）如果这个工程没有编译过，那么所有C文件都要编译并被链接2）如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序3）如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">target ... : prerequisites ...<br>    command<br>    ...<br>    ...<br></code></pre></td></tr></table></figure><p>target:目标文件，可以是ObjectFile，也可以是执行文件。还可以是一个标签Label</p><p>prerequisites:要生成target所需要的文件或是目标。</p><p>command:make需要执行的命令。（任意的Shell命令）</p><p>prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行</p><h3 id="一个示例">3.一个示例</h3><p>执行文件edit</p><p>依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。</p><p>clean不是一个文件，代表makefile中定义的一个操作，有点像C语言中的lable一样，其冒号后什么也没有，make不会自动去找文件的依赖性，不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字如“makeclean”。我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs makefile">edit : main.o kbd.o command.o display.o /<br>    insert.o search.o files.o utils.o<br>    cc -o edit main.o kbd.o command.o display.o /<br>          insert.o search.o files.o utils.o<br>main.o : main.c defs.h<br>    cc -c main.c<br>kbd.o : kbd.c defs.h command.h<br>    cc -c kbd.c<br>command.o : command.c defs.h command.h<br>    cc -c command.c<br>display.o : display.c defs.h buffer.h<br>    cc -c display.c<br>insert.o : insert.c defs.h buffer.h<br>    cc -c insert.c<br>search.o : search.c defs.h buffer.h<br>    cc -c search.c<br>files.o : files.c defs.h buffer.h command.h<br>    cc -c files.c<br>utils.o : utils.c defs.h<br>    cc -c utils.c<br>clean :<br>    rm edit main.o kbd.o command.o display.o /<br>      insert.o search.o files.o utils.o<br></code></pre></td></tr></table></figure><h3 id="make是如何工作的">4.make是如何工作的</h3><p>1、make会在当前目录下找名字叫“Makefile”或“makefile”的文件。2、如果找到，它会找文件中的第一个目标文件（target），如“edit”，并把这个文件作为最终的目标文件。3、如果edit文件不存在，或是edit所依赖的后面的 .o文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。4、如果edit所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。</p><p>make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。make只管文件的依赖性，如果找了依赖关系之后，冒号后面的文件还是不在，那么对不起，make就不工作啦。</p><p>像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——“makeclean”，以此来清除所有的目标文件，以便重编译。</p><p>于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如file.c，那么根据我们的依赖性，我们的目标file.o会被重编译（也就是在这个依性关系后面所定义的命令），于是file.o的文件也是最新的啦，于是file.o的文件修改时间要比edit要新，所以edit也会被重新链接了</p><p>规则的顺序是很重要的，Makefile中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的，所以一定要让make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。</p><p>一般来说，make会以UNIX的标准Shell，也就是/bin/sh来执行命令</p><h3 id="makefile中使用变量">5.makefile中使用变量</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">edit : main.o kbd.o command.o display.o insert.o search.o files.o utils.o<br>   cc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o<br></code></pre></td></tr></table></figure><p>为了makefile的易维护，在makefile中可以使用变量。makefile的变量也就是一个字符串，理解成C语言中的宏</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o<br>edit : <span class="hljs-variable">$(objects)</span><br>     cc -o edit <span class="hljs-variable">$(objects)</span><br></code></pre></td></tr></table></figure><h3 id="让make自动推导">6.让make自动推导</h3><p>GNU的make可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。</p><p>只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且cc -c whatever.c 也会被推导出来</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile">main.o : defs.h<br>kbd.o : defs.h command.h<br>command.o : defs.h command.h<br>display.o : defs.h buffer.h<br>insert.o : defs.h buffer.h<br>search.o : defs.h buffer.h<br>files.o : defs.h buffer.h command.h<br>utils.o : defs.h<br><br>.PHONY : clean<br>clean :<br>    -rm edit <span class="hljs-variable">$(objects)</span><br></code></pre></td></tr></table></figure><p><strong>“.PHONY”表示，clean是个伪目标文件</strong>，在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。</p><p>我们并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。</p><p>当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。</p><p>伪目标一般没有依赖的文件，<strong>但也可以为伪目标指定所依赖的文件</strong>。伪目标同样可以作为“默认目标”，只要将其放在第一个。如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile">all : prog1 prog2 prog3<br>.PHONY : all<br><br>prog1 : prog1.o utils.o<br>    cc -o prog1 prog1.o utils.o<br><br>prog2 : prog2.o<br>    cc -o prog2 prog2.o<br><br>prog3 : prog3.o sort.o utils.o<br>    cc -o prog3 prog3.o sort.o utils.o<br></code></pre></td></tr></table></figure><p>我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于伪目标的特性是，总是被执行的，所以其依赖的那三个目标就总是不如“all”这个目标新。所以，其它三个目标的规则总是会被决议。</p><p>目标也可以成为依赖。所以，<strong>伪目标同样也可成为依赖</strong>。看下面的例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: cleanall cleanobj cleandiff</span><br><br>cleanall : cleanobj cleandiff<br>    rm program<br><br>cleanobj :<br>    rm *.o<br><br>cleandiff :<br>    rm *.diff<br></code></pre></td></tr></table></figure><h3 id="另类风格的makefile">7.另类风格的makefile</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o<br>edit : <span class="hljs-variable">$(objects)</span><br>    cc -o edit <span class="hljs-variable">$(objects)</span><br><br><span class="hljs-variable">$(objects)</span> : defs.h<br>kbd.o command.o files.o : command.h<br>display.o insert.o search.o files.o : buffer.h<br><br>.PHONY : clean<br>clean :<br>    rm edit <span class="hljs-variable">$(objects)</span><br></code></pre></td></tr></table></figure><p>这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得凌乱了。</p><h3 id="makefile里有什么">8.Makefile里有什么？</h3><p>Makefile里主要包含了五个东西：<strong>显式规则、隐晦规则、变量定义、文件指示和注释</strong>。</p><p>1、显式规则：如何生成一个或多的的目标文件。要生成的文件，文件的依赖文件，生成的命令。</p><p>2、隐晦规则：由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书Makefile</p><p>3、变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。</p><p>4、文件指示：</p><ul><li><p>在一个Makefile中引用另一个Makefile，<code>include &lt;filename&gt;</code>,被包含的文件会原模原样的放在当前文件的包含位置</p></li><li><p>指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if；</p></li><li><p>定义一个多行的命令。</p></li></ul><p>5、注释。Makefile中只有行注释。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“/#”。</p><p><strong>在Makefile中的命令，必须要以[Tab]键开始</strong></p><p>如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，make还会在下面的几个目录下找：</p><p>1、如果make执行时，有<code>-I</code>或<code>--include-dir</code>参数，那么make就会在这个参数所指定的目录下去寻找。2、如果目录<prefix>/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。</p><p>如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：</p><p><code>-include &lt;filename&gt;</code></p><h3 id="通配符">9.通配符</h3><p>定义一系列比较类似的文件，make支持三各通配符：<code>*</code>，<code>?</code>和<code>[...]</code>。这是和Unix的B-Shell是相同的。</p><p>通配符代替了一系列的文件，如“*.c”表示所以后缀为c的文件。如果我们的文件名中有通配符，如：<code>*</code>，那么可以用<code>/*</code>来表示真实的<code>*</code>字符，而不是任意长度的字符串。</p><p><code>objects = *.o</code>通符同样可以用在变量中。并不是说[*.o]会展开，不！objects的值就是“*.o”。Makefile中的变量其实就是C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有[.o]的文件名的集合，可以这样：<code>objects := $(wildcard *.o)</code></p><h2 id="二.文件搜寻">二.文件搜寻</h2><p>把源文件分类，并存放在不同的目录中。当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让mak在自动去找。</p><p>Makefile文件中的特殊变量<code>VPATH</code>就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当前目录找不到的情况下，到所指定的目录中去找。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">VPATH = src : ../headers<br></code></pre></td></tr></table></figure><p><code>src</code>和<code>../headers</code>，make会按照这个顺序进行搜索。目录由“冒号”分隔。</p><p>另一个设置文件搜索路径的方法是使用<code>make</code>的<code>vpath</code>关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，它可以指定不同的文件在不同的搜索目录中。</p><p>1、<code>vpath &lt;pattern&gt; &lt;directories&gt;</code><code>vpath %.h ../headers</code></p><p>为符合模式<pattern>的文件指定搜索目录<directories>。</p><p>2、<code>vpath &lt;pattern&gt;</code></p><p>清除符合模式<pattern>的文件的搜索目录。</p><p>3、<code>vpath</code></p><p>清除所有已被设置好了的文件搜索目录。</p><p>vapth使用方法中的<pattern>需要包含<code>%</code>字符。<code>%</code>的意思是匹配零或若干字符，例如，<code>%.h</code>表示所有以<code>.h</code>结尾的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">vpath %.c foo:bar<br>vpath %  blish<br></code></pre></td></tr></table></figure><p>而上面的语句则表示“.c”结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。</p><h2 id="三.多目标"><strong>三.多目标</strong></h2><p>Makefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令是同一个，可以使用一个自动化变量<code>$@</code>，表示目前规则中所有的目标的集合</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile">bigoutput littleoutput : text.g<br>    generate text.g -<span class="hljs-variable">$(<span class="hljs-built_in">subst</span> output,,<span class="hljs-variable">$@</span>)</span> &gt; <span class="hljs-variable">$@</span><br><span class="hljs-comment">#上述规则等价于：</span><br>bigoutput : text.g<br>    generate text.g -big &gt; bigoutput<br>littleoutput : text.g<br>    generate text.g -little &gt; littleoutput<br></code></pre></td></tr></table></figure><p>其中，<code>-$(subst  output,,$@)</code>中的<code>$</code>表示执行一个Makefile的函数，函数名为subst，后面的为参数。这里的这个函数是截取字符串的意思，<code>$@</code>表示目标的集合，就像一个数组，<code>$@</code>依次取出目标，并执于命令。</p><p><strong>静态模式</strong>可以更加容易地定义多目标的规则</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">&lt;targets ...&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt;<br>    &lt;commands&gt;<br></code></pre></td></tr></table></figure><p>targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。</p><p>target-parrtern是指明了targets的模式，也就是的目标集模式。</p><p>prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。</p><p>如果我们的<target-parrtern>定义成<code>%.o</code>，意思是我们的<target>集合中都是以<code>.o</code>结尾的，而如果我们的<prereq-parrterns>定义成<code>%.c</code>，意思是对<target-parrtern>所形成的目标集进行二次定义，其计算方法是，取<target-parrtern>模式中的“%”（也就是去掉了[.o]这个结尾），并为其加上[.c]这个结尾，形成的新集合。</p><p>所以，我们的“目标模式”或是“依赖模式”中都应该有“%”这个字符</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile">  objects = foo.o bar.o<br>  all: <span class="hljs-variable">$(objects)</span><br>  <span class="hljs-variable">$(objects)</span>: %.o : %.c<br>      <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br><span class="hljs-comment"># 等价于:</span><br>  foo.o : foo.c<br>      <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> foo.c -o foo.o<br>  bar.o : bar.c<br>      <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> bar.c -o bar.o<br></code></pre></td></tr></table></figure><p>上面的例子中，指明了我们的目标从<code>$object</code>中获取，<code>%.o</code>表明要所有以“.o”结尾的目标，也就是<code>foo.o bar.o</code>，也就是变量<code>$object</code>集合的模式，而依赖模式<code>%.c</code>则取模式<code>%.o</code>的<code>%</code>，也就是<code>foo  bar</code>，并为其加下<code>.c</code>的后缀，于是，我们的依赖目标就是<code>foo.c  bar.c</code>。而命令中的<code>$&lt;</code>和<code>$@</code>则是<strong>自动化变量</strong>，<code>$&lt;</code>表示所有的依赖目标集（也就是“foo.cbar.c”），<code>$@</code>表示目标集（也就是“foo.o bar.o”）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">files = foo.elc bar.o lose.o<br><br><span class="hljs-variable">$(<span class="hljs-built_in">filter</span> %.o,<span class="hljs-variable">$(files)</span>)</span>: %.o: %.c<br>    <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br><span class="hljs-variable">$(<span class="hljs-built_in">filter</span> %.elc,<span class="hljs-variable">$(files)</span>)</span>: %.elc: %.el<br>    emacs -f batch-byte-compile <span class="hljs-variable">$&lt;</span><br></code></pre></td></tr></table></figure><p><code>$(filter %.o,$(files))</code>表示调用Makefile的filter函数，过滤<code>$files</code>集，只要其中模式为<code>%.o</code>的内容。</p><h2 id="四.自动生成依赖性"><strong>四.自动生成依赖性</strong></h2><p>在Makefile中，我们的依赖关系可能会需要包含一系列的头文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">main.o : main.c  defs.h<br></code></pre></td></tr></table></figure><p>你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个<code>-M</code>的选项，即<strong>自动找寻源文件中包含的头文件</strong>，并生成一个依赖关系。</p><p>如果使用GNU的C/C++编译器，用<code>-MM</code>参数，<code>-M”</code>参数会把一些标准库的头文件也包含进来。</p><p>gcc -M main.c的输出是：</p><p>main.o: main.c defs.h /usr/include/stdio.h /usr/include/features.h //usr/include/sys/cdefs.h /usr/include/gnu/stubs.h //usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stddef.h //usr/include/bits/types.h /usr/include/bits/pthreadtypes.h //usr/include/bits/sched.h /usr/include/libio.h //usr/include/_G_config.h /usr/include/wchar.h //usr/include/bits/wchar.h /usr/include/gconv.h //usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stdarg.h //usr/include/bits/stdio_lim.h</p><p>gcc -MM main.c的输出则是：</p><p>main.o: main.c defs.h</p><p>GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个<code>name.c</code>的文件都生成一个<code>name.d</code>的Makefile文件，[.d]文件中就存放对应[.c]文件的依赖关系。</p><p>我们可以写出[.c]文件和[.d]文件的依赖关系，并让make自动更新或自成[.d]文件，并把其包含在我们的主Makefile中，我们给出了一个模式规则来产生[.d]文件：</p><p>%.d: %.c <span class="citation" data-cites="set">@set</span> -e; rm-f $@; / $(CC) -M $(CPPFLAGS) <span class="math inline">\(&lt; &gt;[\)</span>@.](mailto:<span class="math inline">\(@.\)</span><spanclass="math display">\[$); /       sed &#39;s,/($*/)/.o[ :]*,/1.o $@ : ,g&#39; &lt;[$@.](mailto:$@.\]</span><span class="math display">\[) &gt; $@; /       rm -f [$@.](mailto:$@.\]</span>$$)</p><p>这个规则的意思是，所有的[.d]文件依赖于[.c]文件，<code>rm -f  $@</code>的意思是删除所有的目标，也就是[.d]文件，第二行的意思是，为每个依赖文件<code>$&lt;</code>，也就是[.c]文件生成依赖文件，<code>$@</code>表示模式<code>%.d</code>文件，如果有一个C文件是name.c，那么<code>%</code>就是<code>name</code>，意为一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。</p><p>总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入[.d]文件的依赖，即把依赖关系：</p><p>main.o : main.c defs.h</p><p>转成：</p><p>main.o main.d : main.c defs.h</p><p>于是，我们的[.d]文件也会自动更新了，并会自动生成了，当然，你还可以在这个[.d]文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个[.d]文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。</p><p>sources = foo.c bar.c</p><p>include $(sources: .c = .d)</p><p>上述语句中的<code>$(sources:.c=.d)</code>中的<code>.c=.d</code>的意思是做一个替换，把变量<code>$(sources)</code>所有[.c]的字串都替换成[.d]，关于这个“替换”的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为include是按次来载入文件，最先载入的[.d]文件中的目标会成为默认目标。</p><h2 id="五.书写命令">五.书写命令</h2><h3 id="显示命令"><strong>显示命令</strong></h3><p>通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用<code>@</code>字符在命令行前，<strong>这个命令将不被make显示出来</strong>，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如：</p><p><span class="citation" data-cites="echo">@echo</span>"正在编译XXX模块......"</p><p>当make执行时，会输出“正在编译XXX模块......”字串，但不会输出命令</p><p>如果make执行时，带入make参数<code>-n</code>或<code>--just-print</code>，那么其<strong>只是显示命令，但不会执行命令</strong>，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。</p><p>而make参数<code>-s</code>或<code>--slient</code>则是全面禁止命令的显示。</p><h3 id="命令执行"><strong>命令执行</strong></h3><p>当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：</p><p>示例一： exec: cd /home/hchen pwd</p><p>示例二： exec: cd /home/hchen; pwd</p><p>当我们执行“makeexec”时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出“/home/hchen”。</p><h3 id="命令出错"><strong>命令出错</strong></h3><p>每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。</p><p>有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。为了做到忽略命令的出错，我们可以在Makefile的命令行前加一个减号<code>-</code>（在Tab键之后），标记为不管命令出不出错都认为是成功的。如：</p><p>clean: -rm -f *.o</p><p>还有一个全局的办法是，给make加上<code>-i</code>或是<code>--ignore-errors</code>参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以<code>.IGNORE</code>作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。</p><p>make的参数<code>-k</code>或是<code>--keep-going</code>，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。</p><h3 id="嵌套执行make"><strong>嵌套执行make</strong></h3><p>在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。</p><p>例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么总控的Makefile可以这样书写：</p><p>subsystem: cd subdir &amp;&amp; $(MAKE)</p><p>其等价于：</p><p>subsystem: $(MAKE) -C subdir</p><p>定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行make命令。</p><p>总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了<code>-e</code>参数。</p><p>传递变量到下级Makefile中</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">export</span> &lt;variable ...&gt;<br><br><span class="hljs-keyword">export</span> variable = value<br><br><span class="hljs-comment"># 其等价于：</span><br><br><span class="hljs-keyword">export</span> variable := value<br><br><span class="hljs-comment"># 不让某些变量传递到下级Makefile中</span><br><br><span class="hljs-keyword">unexport</span> &lt;variable ...&gt;<br></code></pre></td></tr></table></figure><p>如果要传递所有的变量，只要一个export就行了。</p><p>SHELL和MAKEFLAGS，这两个变量不管你是否export，其总是要传递到下层Makefile中，特别是MAKEFILES变量，其中包含了make的参数信息，如果我们执行“总控Makefile”时有make参数或是在上层Makefile中定义了这个变量</p><p>但是make命令中的有几个参数并不往下传递，它们是<code>-C</code>,<code>-f</code>,<code>-h</code>,<code>-o</code>和<code>-W</code>，如果你不想往下层传递参数，那么，你可以：</p><p>subsystem: cd subdir &amp;&amp; $(MAKE) MAKEFLAGS=</p><p>如果你定义了环境变量MAKEFLAGS，那么你得确信其中的选项是大家都会用到的，如果其中有“-t”,“-n”,和“-q”参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。</p><p>还有一个在“嵌套执行”中比较有用的参数，<code>-w</code>或是<code>--print-directory</code>会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是<code>/home/hchen/gnu/make</code>，如果我们使用<code>make -w</code>来执行，那么当进入该目录时，我们会看到：</p><p>make: Entering directory `/home/hchen/gnu/make'.</p><p>而在完成下层make后离开目录时，我们会看到：</p><p>make: Leaving directory `/home/hchen/gnu/make'</p><p>当你使用“-C”参数来指定make下层Makefile时，“-w”会被自动打开的。如果参数中有“-s”（“--slient”）或是“--no-print-directory”，那么，“-w”总是失效的。</p><h3 id="定义命令包"><strong>定义命令包</strong></h3><p>如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">define</span> run-yacc<br>yacc <span class="hljs-variable">$(<span class="hljs-built_in">firstword</span> <span class="hljs-variable">$^</span>)</span><br>mv y.tab.c <span class="hljs-variable">$@</span><br><span class="hljs-keyword">endef</span><br></code></pre></td></tr></table></figure><p>这里，<code>run-yacc</code>是这个命令包的名字，其不要和Makefile中的变量重名。在“define”和“endef”中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">foo.c : foo.y<br>    $(run-yacc)<br></code></pre></td></tr></table></figure><p>我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包<code>run-yacc</code>中的<code>$^</code>就是<code>foo.y</code>，<code>$@</code>就是<code>foo.c</code>,make在执行命令包时，命令包中的每个命令会被依次独立执行。</p><h2 id="六.使用变量">六.使用变量</h2><p>可以在Makefile中改变变量值。在Makefile中，变量可以使用在“目标”，“依赖目标”，“命令”或是Makefile的其它部分中。</p><p>变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有<code>:</code>、<code>#</code>、<code>=</code>或是空字符（空格、回车等）。变量是大小写敏感的，<code>foo</code>、<code>Foo</code>和<code>FOO</code>是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。</p><h3 id="变量的基础"><strong>变量的基础</strong></h3><p>变量在声明时需要给予初值，在使用时，需要给在变量名前加上<code>$</code>符号，但最好用<code>()</code>或是<code>&#123;&#125;</code>把变量给包括起来。要使用真实的<code>$</code>字符，那么你需要用<code>$$</code>来表示。</p><p>变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。</p><h3 id="变量中的变量"><strong>变量中的变量</strong></h3><p>在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。</p><p>先看第一种方式左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">foo = <span class="hljs-variable">$(bar)</span><br>bar = <span class="hljs-variable">$(ugh)</span><br>ugh = Huh?<br><br><span class="hljs-section">all:</span><br>    echo <span class="hljs-variable">$(foo)</span><br></code></pre></td></tr></table></figure><p>这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，不好的地方是递归定义</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CFLAGS = <span class="hljs-variable">$(include_dirs)</span> -O<br>include_dirs = -Ifoo -Ibar<br></code></pre></td></tr></table></figure><p>当“CFLAGS”在命令中被展开时，会是“-Ifoo -Ibar -O”</p><p>如果在变量中使用函数，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数“wildcard”和“shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。</p><p>为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是“:=”操作符，</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">x := foo<br>y := <span class="hljs-variable">$(x)</span> bar<br>x := later<br><span class="hljs-comment"># 其等价于：</span><br>y := foo bar<br>x := later<br></code></pre></td></tr></table></figure><p>这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifeq</span> (0,$&#123;MAKELEVEL&#125;)<br>cur-dir  := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span><br>whoami  := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> whoami)</span><br>host-type := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> arch)</span><br>MAKE := $&#123;MAKE&#125; host-type=$&#123;host-type&#125; whoami=$&#123;whoami&#125;<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>系统变量“MAKELEVEL”，其意思是，如果我们的make有一个嵌套执行的动作，那么这个变量会记录了我们的当前Makefile的调用层数。</p><p>如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：</p><p>nullstring := space := $(nullstring) # end of the line</p><p>nullstring是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个Empty变量来标明变量的值开始了，而后面<strong>采用“#”注释符来表示变量定义的终止</strong>，这样，我们可以定义出其值是一个空格的变量。请注意这里关于“#”的使用，注释符“#”的这种特性值得我们注意，如果我们这样定义一个变量：</p><p><code>dir := /foo/bar  # directory to put the frobs in</code></p><p>dir这个变量的值是<code>/foo/bar</code>，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录就完蛋了。还有一个比较有用的操作符是<code>?=</code>，先看示例：</p><p><code>FOO ?= bar</code></p><p>其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(<span class="hljs-built_in">origin</span> FOO)</span>, undefined)<br> FOO = bar<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><h3 id="变量高级用法"><strong>变量高级用法</strong></h3><p>第一种是变量值的替换。</p><p>我们可以替换变量中的共有的部分，其格式是<code>$(var:a=b)</code>或是<code>$&#123;var:a=b&#125;</code></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">foo := a.o b.o c.o<br>bar := $(foo: .o=.c)<br></code></pre></td></tr></table></figure><p>另外一种变量替换的技术是以“静态模式”定义的，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">foo := a.o b.o c.o<br>bar := $(foo:%.o=%.c)<br></code></pre></td></tr></table></figure><p>这依赖于被替换字串中的有相同的模式，模式中必须包含一个“%”字符</p><p>第二种高级用法是——“把变量的值再当成变量”。先看一个例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">x = y<br>y = z<br>a := $(<span class="hljs-variable">$(x)</span>)<br></code></pre></td></tr></table></figure><p>在这个例子中，<spanclass="math inline">\((x)的值是“y”，所以\)</span>(<spanclass="math inline">\((x))就是\)</span>(y)，于是$(a)的值就是“z”。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">x = <span class="hljs-variable">$(y)</span><br>y = z<br>z = Hello<br>a := $(<span class="hljs-variable">$(x)</span>)<br></code></pre></td></tr></table></figure><p>这里的<span class="math inline">\((\)</span>(x))被替换成了<spanclass="math inline">\((\)</span>(y))，因为<spanclass="math inline">\((y)值是“z”，所以，最终结果是：a:=\)</span>(z)，也就是“Hello”。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">x = variable1<br>variable2 := Hello<br>y = <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> 1,2,<span class="hljs-variable">$(x)</span>)</span><br>z = y<br>a := $($(<span class="hljs-variable">$(z)</span>))<br></code></pre></td></tr></table></figure><p>这个例子中，“<span class="math inline">\((\)</span>(<spanclass="math inline">\((z)))”扩展为“\)</span>(<spanclass="math inline">\((y))”，而其再次被扩展为“\)</span>(<spanclass="math inline">\((subst 1,2,\)</span>(x)))”。<spanclass="math inline">\((x)的值是“variable1”，subst函数把“variable1”中的所有“1”字串替换成“2”字串，再取其值，\)</span>(a)的值就是$(variable2)的值——“Hello”。</p><p>在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">first_second = Hello<br>a = first<br>b = second<br>all = $($a_$b)<br></code></pre></td></tr></table></figure><p>这里的“<spanclass="math inline">\(a_\)</span>b”组成了“first_second”，于是，$(all)的值就是“Hello”。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">a_objects := a.o b.o c.o<br>1_objects := 1.o 2.o 3.o<br>sources := $(<span class="hljs-variable">$(a1)</span>_objects:.o=.c)<br></code></pre></td></tr></table></figure><p>这个例子中，如果<spanclass="math inline">\((a1)的值是“a”的话，那么，\)</span>(sources)的值就是“a.cb.c c.c”；如果<spanclass="math inline">\((a1)的值是“1”，那么\)</span>(sources)的值是“1.c2.c 3.c”。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifdef</span> do_sort<br>func := sort<br><span class="hljs-keyword">else</span><br>func := strip<br><span class="hljs-keyword">endif</span><br>bar := a d b g q c<br>foo := $(<span class="hljs-variable">$(func)</span> <span class="hljs-variable">$(bar)</span>)<br></code></pre></td></tr></table></figure><p>这个示例中，如果定义了“do_sort”，那么：foo := <spanclass="math inline">\((sort a d b g q c)，于是\)</span>(foo)的值就是“a bc d g q”，而如果没有定义“do_sort”，那么：foo := $(sort a d b g qc)，调用的就是strip函数。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">dir = foo<br><span class="hljs-variable">$(dir)</span>_sources := <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dir)</span>/*.c)</span><br><span class="hljs-keyword">define</span> <span class="hljs-variable">$(dir)</span>_print<br>lpr $(<span class="hljs-variable">$(dir)</span>_sources)<br><span class="hljs-keyword">endef</span><br></code></pre></td></tr></table></figure><h3 id="追加变量值"><strong>追加变量值</strong></h3><p>使用<code>+=</code>操作符给变量追加值，如：</p><p>objects = main.o foo.o bar.o utils.o objects += another.o</p><p><code>$(objects)</code>值变成：<code>main.o foo.o bar.o utils.o another.o</code></p><p>如果变量之前没有定义过，那么，“+=”会自动变成“=”，如果前面有变量定义，那么“+=”会继承于前次操作的赋值符。如果前一次的是“:=”，那么“+=”会以“:=”作为其赋值符，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">variable := value<br>variable += more<br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">variable := value<br>variable := <span class="hljs-variable">$(variable)</span> more<br></code></pre></td></tr></table></figure><p>但如果是这种情况：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">variable = value<br>variable += more<br></code></pre></td></tr></table></figure><p>由于前次的赋值符是“=”，所以“+=”也会以“=”来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。</p><h3 id="override-指示符"><strong>override 指示符</strong></h3><p>如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是：</p><p>override <variable> = <value></p><p>override <variable> := <value></p><p>override <variable> += <more text></p><h3 id="多行变量"><strong>多行变量</strong></h3><p>使用define关键字设置变量的值可以有换行。define后面跟的是变量的名字，重起一行定义变量的值，以endef关键字结束。</p><p>变量的值可以包含<strong>函数、命令、文字，或是其它变量</strong>。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以[Tab]键开头，那么make就不会把其认为是命令。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">define</span> two-lines<br>echo foo<br>echo <span class="hljs-variable">$(bar)</span><br><span class="hljs-keyword">endef</span><br></code></pre></td></tr></table></figure><h3 id="环境变量"><strong>环境变量</strong></h3><p>make运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）</p><p>因此，如果我们在环境变量中设置了<code>CFLAGS</code>环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。<strong>如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量</strong>，如果没有定义则使用系统环境变量的值。</p><p>当make嵌套调用时，上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层Makefile传递，则需要使用exprot关键字来声明。</p><h3 id="目标变量"><strong>目标变量</strong></h3><p>Makefile中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量。“自动化变量”除外，如<code>$&lt;</code>等这种类量的自动化变量就属于“规则型变量”，这种变量的值<strong>依赖于规则的目标和依赖目标的定义</strong>。</p><p>当然，同样可以为某个目标设置局部变量，这种变量被称为“Target-specificVariable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。</p><p>其语法是：</p><p>&lt;target ...&gt; : <variable-assignment></p><p>&lt;target ...&gt; : overide <variable-assignment></p><p><variable-assignment>可以是前面讲过的各种赋值表达式，如<code>=</code>、<code>:=</code>、<code>+=</code>或是<code>？=</code>。第二个语法是针对于make命令行带入的变量，或是系统环境变量。</p><p>这个特性非常的有用，当我们设置了这样一个变量，<strong>这个变量会作用到由这个目标所引发的所有的规则中</strong>去。如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile">prog : CFLAGS = -g<br>prog : prog.o foo.o bar.o<br>    <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> prog.o foo.o bar.o<br>prog.o : prog.c<br>    <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> prog.c<br>foo.o : foo.c<br>    <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> foo.c<br>bar.o : bar.c<br>    <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> bar.c<br></code></pre></td></tr></table></figure><p>在这个示例中，不管全局的<spanclass="math inline">\((CFLAGS)的值是什么，在prog目标，以及其所引发的所有规则中（prog.ofoo.o bar.o的规则），\)</span>(CFLAGS)的值都是“-g”</p><h3 id="模式变量"><strong>模式变量</strong></h3><p>模式变量（Pattern-specificVariable）。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。</p><p>我们知道，make的“模式”一般是至少含有一个“%”的，所以，我们可以以如下方式给所有以[.o]结尾的目标定义目标变量：</p><p>%.o : CFLAGS = -O</p><p>同样，模式变量的语法和“目标变量”一样：</p><p>&lt;pattern ...&gt; : <variable-assignment></p><p>&lt;pattern ...&gt; : override <variable-assignment></p><p>override同样是针对于系统环境传入的变量，或是make命令行指定的变量。</p><h2 id="七.使用条件判断">七.使用条件判断</h2><p>使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。</p><h3 id="示例"><strong>示例</strong></h3><p>下面的例子，判断$(CC)变量是否“gcc”，如果是的话，则使用GNU函数编译目标。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile">libs_for_gcc = -lgnu<br>normal_libs =<br><br><span class="hljs-section">foo: <span class="hljs-variable">$(objects)</span></span><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(CC)</span>,gcc)<br>    <span class="hljs-variable">$(CC)</span> -o foo <span class="hljs-variable">$(objects)</span> <span class="hljs-variable">$(libs_for_gcc)</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-variable">$(CC)</span> -o foo <span class="hljs-variable">$(objects)</span> <span class="hljs-variable">$(normal_libs)</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><h3 id="语法"><strong>语法</strong></h3><p>条件表达式的语法为：</p><p><conditional-directive> <text-if-true> endif</p><p>以及：</p><p><conditional-directive> <text-if-true> else <text-if-false> endif</p><p>其中<conditional-directive>表示条件关键字，如“ifeq”。这个关键字有四个。</p><p>第一个是我们前面所见过的“ifeq”</p><p>ifeq (<arg1>, <arg2>) ifeq '<arg1>' '<arg2>' ifeq "<arg1>" "<arg2>"ifeq "<arg1>" '<arg2>' ifeq '<arg1>' "<arg2>"</p><p>比较参数“arg1”和“arg2”的值是否相同。当然，参数中我们还可以使用make的函数。如：</p><p>ifeq ($(strip $(foo)),) <text-if-empty> endif</p><p>这个示例中使用了“strip”函数，如果这个函数的<strong>返回值是空（Empty）</strong>，那么<text-if-empty>就生效。</p><p>第二个条件关键字是“ifneq”。语法是：</p><p>ifneq (<arg1>, <arg2>) ifneq '<arg1>' '<arg2>' ifneq "<arg1>""<arg2>" ifneq "<arg1>" '<arg2>' ifneq '<arg1>' "<arg2>"</p><p>其比较参数“arg1”和“arg2”的值是否相同，如果不同，则为真。和“ifeq”类似。</p><p>第三个条件关键字是“ifdef”。语法是：</p><p>ifdef <variable-name></p><h1 id="看到这里了">看到这里了</h1><p>如果变量<variable-name>的值<strong>非空</strong>，那到表达式为真。否则，表达式为假。当然，<variable-name>同样可以是一个函数的返回值。注意，ifdef只是测试一个变量是否有值，其并不会把变量扩展到当前位置。</p><p>示例一： bar = foo = $(bar) ifdef foo frobozz = yes else frobozz = noendif</p><p>示例二： foo = ifdef foo frobozz = yes else frobozz = no endif</p><p>第一个例子中，<code>$(frobozz)</code>值是<code>yes</code>，第二个则是<code>no</code>。</p><p>第四个条件关键字是“ifndef”。其语法是：</p><p>ifndef <variable-name></p><p>特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如<code>$@</code>等）放入条件表达式中，因为自动化变量是在运行时才有的。而且，为了避免混乱，make不允许把整个条件语句分成两部分放在不同的文件中。</p><h2 id="八.使用函数">八.使用函数</h2><p>在Makefile中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使用。</p><h3 id="函数的调用语法"><strong>函数的调用语法</strong></h3><p>函数调用，很像变量的使用，也是以“$”来标识的，其语法如下：</p><p>$(<function> <arguments>)</p><p>或是</p><p>${<function> <arguments>}</p><p>这里，<function>就是函数名，make支持的函数不多。<arguments>是函数的参数，参数间以逗号“,”分隔，而<strong>函数名和参数之间以“空格”分隔</strong>。函数调用以“$”开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？函数中的参数可以使用变量</p><p>comma:= , empty:= space:= $(empty) $(empty) foo:= a b c bar:= $(subst<span class="math inline">\((space),\)</span>(comma),$(foo))</p><p>在这个示例中，<spanclass="math inline">\((comma)的值是一个逗号。\)</span>(space)使用了<spanclass="math inline">\((empty)定义了一个空格，\)</span>(foo)的值是“a bc”，<spanclass="math inline">\((bar)的定义用，调用了函数“subst”，这是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是把\)</span>(foo)中的空格替换成逗号，所以$(bar)的值是“a,b,c”。</p><h3 id="字符串处理函数"><strong>字符串处理函数</strong></h3><p><strong>$(subst <from>,<to>,<text>)</strong></p><p>名称：字符串替换函数——subst。功能：把字串<text>中的<from>字符串替换成<to>。返回：函数返回被替换过后的字符串。</p><p>示例： $(subst ee,EE,feet on the street)，</p><pre><code>把“feet on the street”中的“ee”替换成“EE”，返回结果是“fEEt on the strEEt”。</code></pre><p><strong>$(patsubst <pattern>,<replacement>,<text>)</strong></p><p>名称：模式字符串替换函数——patsubst。功能：查找<text>中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式<pattern>，如果匹配的话，则以<replacement>替换。这里，<pattern>可以包括通配符“%”，表示任意长度的字串。如果<replacement>中也包含“%”，那么，<replacement>中的这个“%”将是<pattern>中的那个“%”所代表的字串。（可以用“/”来转义，以“/%”来表示真实含义的“%”字符）返回：函数返回被替换过后的字符串。</p><p>示例：</p><p>​ $(patsubst %.c,%.o,x.c.c bar.c)</p><p>​ 把字串“x.c.c bar.c”符合模式[%.c]的单词替换成[%.o]，返回结果是“x.c.obar.o”</p><p>备注：</p><p>​ 这和我们前面“变量章节”说过的相关知识有点相似。如：</p><p>​ “<spanclass="math inline">\((var:&lt;pattern&gt;=&lt;replacement&gt;)” ​ 相当于​“\)</span>(patsubst <pattern>,<replacement>,$(var))”，</p><p>​ 而“<span class="math inline">\((var:&lt;suffix&gt;=&lt;replacement&gt;)” ​ 则相当于 ​ “\)</span>(patsubst%<suffix>,%<replacement>,$(var))”。</p><p>​ 例如有：objects = foo.o bar.o baz.o， ​ 那么，“<spanclass="math inline">\((objects:.o=.c)”和“\)</span>(patsubst%.o,%.c,$(objects))”是一样的。</p><p><strong>$(strip <string>)</strong></p><p>名称：去空格函数——strip。功能：去掉<string>字串中开头和结尾的空字符。返回：返回被去掉空格的字符串值。 示例：</p><pre><code>$(strip a b c )</code></pre><p>​ 把字串“a b c ”去到开头和结尾的空格，结果是“a b c”。</p><p><strong>$(findstring <find>,<in>)</strong></p><p>名称：查找字符串函数——findstring。 功能：在字串<in>中查找<find>字串。返回：如果找到，那么返回<find>，否则返回空字符串。 示例：</p><p>​ $(findstring a,a b c) ​ $(findstring a,b c)</p><p>​ 第一个函数返回“a”字符串，第二个返回“”字符串（空字符串）</p><p><strong>$(filter &lt;pattern...&gt;,<text>)</strong></p><p>名称：过滤函数——filter。功能：以<pattern>模式过滤<text>字符串中的单词，保留符合模式<pattern>的单词。可以有多个模式。返回：返回符合模式<pattern>的字串。 示例：</p><p>​ sources := foo.c bar.c baz.s ugh.h ​ foo: $(sources) ​ cc <spanclass="math inline">\((filter %.c %.s,\)</span>(sources)) -o foo</p><p>​ <span class="math inline">\((filter %.c%.s,\)</span>(sources))返回的值是“foo.c bar.c baz.s”。</p><p><strong>$(filter-out &lt;pattern...&gt;,<text>)</strong></p><p>名称：反过滤函数——filter-out。功能：以<pattern>模式过滤<text>字符串中的单词，去除符合模式<pattern>的单词。可以有多个模式。返回：返回不符合模式<pattern>的字串。 示例：</p><p>​ objects=main1.o foo.o main2.o bar.o ​ mains=main1.o main2.o ​<br />​$(filter-out <span class="math inline">\((mains),\)</span>(objects))返回值是“foo.o bar.o”。 ​<br /><strong>$(sort <list>)</strong></p><p>名称：排序函数——sort。 功能：给字符串<list>中的单词排序（升序）。返回：返回排序后的字符串。 示例：$(sort foo bar lose)返回“bar foo lose”。 备注：sort函数会去掉<list>中相同的单词。</p><p><strong>$(word <n>,<text>)</strong></p><p>名称：取单词函数——word。功能：取字符串<text>中第<n>个单词。（从一开始）返回：返回字符串<text>中第<n>个单词。如果<n>比<text>中的单词数要大，那么返回空字符串。示例：$(word 2, foo bar baz)返回值是“bar”。</p><p><strong>$(wordlist <s>,<e>,<text>)</strong></p><p>名称：取单词串函数——wordlist。功能：从字符串<text>中取从<s>开始到<e>的单词串。<s>和<e>是一个数字。返回：返回字符串<text>中从<s>到<e>的单词字串。如果<s>比<text>中的单词数要大，那么返回空字符串。如果<e>大于<text>的单词数，那么返回从<s>开始，到<text>结束的单词串。示例： $(wordlist 2, 3, foo bar baz)返回值是“bar baz”。</p><p><strong>$(words <text>)</strong></p><p>名称：单词个数统计函数——words。功能：统计<text>中字符串中的单词个数。 返回：返回<text>中的单词数。示例：<span class="math inline">\((words, foo barbaz)返回值是“3”。  备注：如果我们要取&lt;text&gt;中最后的一个单词，我们可以这样：\)</span>(word$(words <text>),<text>)。</p><p><strong>$(firstword <text>)</strong></p><p>名称：首单词函数——firstword。 功能：取字符串<text>中的第一个单词。返回：返回字符串<text>的第一个单词。 示例：<spanclass="math inline">\((firstword foobar)返回值是“foo”。  备注：这个函数可以用word函数来实现：\)</span>(word1,<text>)。</p><p>以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，举一个现实中应用的例子。我们知道，make使用“VPATH”变量来指定“依赖文件”的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数CFLAGS，如：</p><p>override CFLAGS += <span class="math inline">\((patsubst%,-I%,\)</span>(subst :, ,$(VPATH)))</p><p>如果我们的“<spanclass="math inline">\((VPATH)”值是“src:../headers”，那么“\)</span>(patsubst%,-I%,<span class="math inline">\((subst :,,\)</span>(VPATH)))”将返回“-Isrc-I../headers”，这正是cc或gcc搜索头文件路径的参数。</p><h3 id="文件名操作函数"><strong>文件名操作函数</strong></h3><p>下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是一系列的文件名来对待。</p><p><strong>$(dir &lt;names...&gt;)</strong></p><p>名称：取目录函数——dir。功能：从文件名序列<names>中取出目录部分。目录部分是指最后一个反斜杠（“/”）之前的部分。如果没有反斜杠，那么返回“./”。返回：返回文件名序列<names>的目录部分。 示例： $(dir src/foo.chacks)返回值是“src/ ./”。</p><p><strong>$(notdir &lt;names...&gt;)</strong></p><p>名称：取文件函数——notdir。功能：从文件名序列<names>中取出非目录部分。非目录部分是指最后一个反斜杠（“/”）之后的部分。返回：返回文件名序列<names>的非目录部分。 示例： $(notdir src/foo.chacks)返回值是“foo.c hacks”。</p><p><strong>$(suffix &lt;names...&gt;)</strong></p><p>名称：取后缀函数——suffix。功能：从文件名序列<names>中取出各个文件名的后缀。返回：返回文件名序列<names>的后缀序列，如果文件没有后缀，则返回空字串。示例：$(suffix src/foo.c src-1.0/bar.c hacks)返回值是“.c .c”。</p><p><strong>$(basename &lt;names...&gt;)</strong></p><p>名称：取前缀函数——basename。功能：从文件名序列<names>中取出各个文件名的前缀部分。返回：返回文件名序列<names>的前缀序列，如果文件没有前缀，则返回空字串。示例：$(basename src/foo.c src-1.0/bar.c hacks)返回值是“src/foosrc-1.0/bar hacks”。</p><p><strong>$(addsuffix <suffix>,&lt;names...&gt;)</strong></p><p>名称：加后缀函数——addsuffix。功能：把后缀<suffix>加到<names>中的每个单词后面。返回：返回加过后缀的文件名序列。 示例：$(addsuffix .c,foobar)返回值是“foo.c bar.c”。</p><p><strong>$(addprefix <prefix>,&lt;names...&gt;)</strong></p><p>名称：加前缀函数——addprefix。功能：把前缀<prefix>加到<names>中的每个单词后面。返回：返回加过前缀的文件名序列。 示例：$(addprefix src/,foobar)返回值是“src/foo src/bar”。</p><p><strong>$(join <list1>,<list2>)</strong></p><p>名称：连接函数——join。功能：把<list2>中的单词对应地加到<list1>的单词后面。如果<list1>的单词个数要比<list2>的多，那么，<list1>中的多出来的单词将保持原样。如果<list2>的单词个数要比<list1>多，那么，<list2>多出来的单词将被复制到<list2>中。返回：返回连接过后的字符串。 示例：$(join aaa bbb , 111 222333)返回值是“aaa111 bbb222 333”。</p><h3 id="foreach-函数">foreach 函数</h3><p>foreach函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的foreach函数几乎是仿照于Unix标准Shell（/bin/sh）中的for语句，或是C-Shell（/bin/csh）中的foreach语句而构建的。它的语法是：</p><p>​</p><p>$(foreach <var>,<list>,<text>)</p><p>​</p><p>这个函数的意思是，把参数<list>中的单词逐一取出放到参数<var>所指定的变量中，然后再执行<text>所包含的表达式。每一次<text>会返回一个字符串，循环过程中，<text>的所返回的每个字符串会以空格分隔，最后当整个循环结束时，<text>所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。</p><p>​</p><p>所以，<var>最好是一个变量名，<list>可以是一个表达式，而<text>中一般会使用<var>这个参数来依次枚举<list>中的单词。举个例子：</p><p>​</p><p>names := a b c d</p><p>files := <span class="math inline">\((foreachn,\)</span>(names),$(n).o)</p><p>​</p><p>上面的例子中，<spanclass="math inline">\((name)中的单词会被挨个取出，并存到变量“n”中，“\)</span>(n).o”每次根据“<spanclass="math inline">\((n)”计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以，\)</span>(files)的值是“a.ob.o c.o d.o”。</p><p>​</p><p>注意，foreach中的<var>参数是一个临时的局部变量，foreach函数执行完后，参数<var>的变量将不在作用，其作用域只在foreach函数当中。</p><p>​</p><p>​</p><h3 id="if-函数">if 函数</h3><p>if函数很像GNU的make所支持的条件语句——ifeq（参见前面所述的章节），if函数的语法是：</p><p>$(if <condition>,<then-part>)</p><p>$(if <condition>,<then-part>,<else-part>)</p><p>可见，if函数可以包含“else”部分，或是不含。即if函数的参数可以是两个，也可以是三个。<condition>参数是if的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，<then-part>会被计算，否则<else-part>会被计算。</p><p>而if函数的返回值是，如果<condition>为真（非空字符串），那个<then-part>会是整个函数的返回值，如果<condition>为假（空字符串），那么<else-part>会是整个函数的返回值，此时如果<else-part>没有被定义，那么，整个函数返回空字串。</p><p>​</p><p>所以，<then-part>和<else-part>只会有一个被计算。</p><p>​</p><h3 id="call函数">call函数</h3><p>​</p><p>call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用call函数来向这个表达式传递参数。其语法是：</p><p>​</p><p>$(call <expression>,<parm1>,<parm2>,<parm3>...)</p><p>​</p><p>当make执行这个函数时，<expression>参数中的变量，如<spanclass="math inline">\((1)，\)</span>(2)，$(3)等，会被参数<parm1>，<parm2>，<parm3>依次取代。而<expression>的返回值就是call函数的返回值。例如：</p><p>reverse = $(1) $(2)</p><p>foo = $(call reverse,a,b)</p><p>那么，foo的值就是“ab”。当然，参数的次序是可以自定义的，不一定是顺序的，如：</p><p>​</p><p>reverse = $(2) $(1)</p><p>foo = $(call reverse,a,b)</p><p>此时的foo的值就是“b a”。</p><p>​</p><p>​</p><h3 id="origin函数">origin函数</h3><p>origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是：</p><p>​</p><p>$(origin <variable>)</p><p>​</p><p>注意，<variable>是变量的名字，不应该是引用。所以你最好不要在<variable>中使用“$”字符。Origin函数会以其返回值来告诉你这个变量的“出生情况”，下面，是origin函数的返回值:</p><p>​</p><p>“undefined”</p><p>如果<variable>从来没有定义过，origin函数返回这个值“undefined”。</p><p>​</p><p>“default”</p><p>如果<variable>是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。</p><p>​</p><p>“environment”</p><p>如果<variable>是一个环境变量，并且当Makefile被执行时，“-e”参数没有被打开。</p><p>​</p><p>“file”</p><p>如果<variable>这个变量被定义在Makefile中。</p><p>​</p><p>“command line”</p><p>如果<variable>这个变量是被命令行定义的。</p><p>​</p><p>“override”</p><p>如果<variable>是被override指示符重新定义的。</p><p>​</p><p>“automatic”</p><p>如果<variable>是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。</p><p>​</p><p>这些信息对于我们编写Makefile是非常有用的，例如，假设我们有一个Makefile其包了一个定义文件Make.def，在Make.def中定义了一个变量“bletch”，而我们的环境中也有一个环境变量“bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的Makefile中，我们可以这样写：</p><p>​</p><p>ifdef bletch</p><p>ifeq "$(origin bletch)" "environment"</p><p>bletch = barf, gag, etc.</p><p>endif</p><p>endif</p><p>​</p><p>当然，你也许会说，使用override关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用override是可以达到这样的效果，可是override过于粗暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的。</p><p>​</p><p>​</p><h3 id="shell函数">shell函数</h3><p>​</p><p>shell函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号“`”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：</p><p>​</p><p>contents := $(shell cat foo)</p><p>​</p><p>files := $(shell echo *.c)</p><p>​</p><p>注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。</p><p>​</p><p>​</p><h3 id="控制make的函数">控制make的函数</h3><p>​</p><p>make提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。</p><p>​</p><p><strong>$(error &lt;text ...&gt;)</strong></p><p>​</p><p>产生一个致命的错误，&lt;text...&gt;是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。例如：</p><p>​</p><p>示例一：</p><p>ifdef ERROR_001</p><p>$(error error is $(ERROR_001))</p><p>endif</p><p>​</p><p>示例二：</p><p>ERR = $(error found an error!)</p><p>.PHONY: err</p><p>err: ; $(ERR)</p><p>​</p><p>示例一会在变量ERROR_001定义了后执行时产生error调用，而示例二则在目录err被执行时才发生error调用。</p><p>​</p><p><strong>$(warning &lt;text ...&gt;)</strong></p><p>​</p><p>这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。</p><h2 id="九.make-的运行">九.make 的运行</h2><p>一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的makefile来执行，一切都是自动的。但也有时你也许只想让make重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。本章节就是讲述如何使用make命令的。</p><h3 id="make的退出码"><strong>make的退出码</strong></h3><p>make命令执行后有三个退出码：</p><p>0 —— 表示成功执行。 1 —— 如果make运行时出现任何错误，其返回1。 2 ——如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。</p><p>Make的相关参数我们会在后续章节中讲述。</p><h3 id="指定makefile"><strong>指定Makefile</strong></h3><p>前面我们说过，GNUmake找寻默认的Makefile的规则是在当前目录下依次找三个文件——“GNUmakefile”、“makefile”和“Makefile”。其按顺序找这三个文件，一旦找到，就开始读取这个文件并执行。</p><p>当前，我们也可以给make命令指定一个特殊名字的Makefile。要达到这个功能，我们要使用make的“-f”或是“--file”参数（“--makefile”参数也行）。例如，我们有个makefile的名字是“hchen.mk”，那么，我们可以这样来让make来执行这个文件：</p><p>make –f hchen.mk</p><p>如果在make的命令行是，你不只一次地使用了“-f”参数，那么，所有指定的makefile将会被连在一起传递给make执行。</p><h3 id="指定目标"><strong>指定目标</strong></h3><p>一般来说，make的最终目标是makefile中的第一个目标，而其它目标一般是由这个目标连带出来的。这是make的默认行为。当然，一般来说，你的makefile中的第一个目标是由许多个目标组成，你可以指示make，让其完成你所指定的目标。要达到这一目的很简单，需在make命令后直接跟目标的名字就可以完成（如前面提到的“makeclean”形式）</p><p>任何在makefile中的目标都可以被指定成终极目标，但是除了以“-”打头，或是包含了“=”的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。甚至没有被我们明确写出来的目标也可以成为make的终极目标，也就是说，只要make可以找到其隐含规则推导规则，那么这个隐含目标同样可以被指定成终极目标。</p><p>有一个make的环境变量叫“MAKECMDGOALS”，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子：</p><p>sources = foo.c bar.c ifneq ( $(MAKECMDGOALS),clean) include$(sources:.c=.d) endif</p><p>基于上面的这个例子，只要我们输入的命令不是“makeclean”，那么makefile会自动包含“foo.d”和“bar.d”这两个makefile。</p><p>使用指定终极目标的方法可以很方便地让我们编译我们的程序，例如下面这个例子：</p><p>.PHONY: all all: prog1 prog2 prog3 prog4</p><p>从这个例子中，我们可以看到，这个makefile中有四个需要编译的程序——“prog1”，“prog2”， “prog3”和 “prog4”，我们可以使用“makeall”命令来编译所有的目标（如果把all置成第一个目标，那么只需执行“make”），我们也可以使用“makeprog2”来单独编译目标“prog2”。</p><p>即然make可以指定所有makefile中的目标，那么也包括“伪目标”，于是我们可以根据这种性质来让我们的makefile根据指定的不同的目标来完成不同的事。在Unix世界中，软件发布时，特别是GNU这种开源软件的发布时，其makefile都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的makefile中的目标。</p><p>“all” 这个伪目标是所有目标的目标，其功能一般是编译所有的目标。“clean” 这个伪目标功能是删除所有被make创建的文件。 “install”这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。“print” 这个伪目标的功能是例出改变过的源文件。 “tar”这个伪目标功能是把源程序打包备份。也就是一个tar文件。 “dist”这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。“TAGS” 这个伪目标功能是更新所有的目标，以备完整地重编译使用。“check”和“test” 这两个伪目标一般用来测试makefile的流程。</p><p>当然一个项目的makefile中也不一定要书写这样的目标，这些东西都是GNU的东西，但是我想，GNU搞出这些东西一定有其可取之处（等你的UNIX下的程序文件一多时你就会发现这些功能很有用了），这里只不过是说明了，如果你要书写这种功能，最好使用这种名字命名你的目标，这样规范一些，规范的好处就是——不用解释，大家都明白。而且如果你的makefile中有这些功能，一是很实用，二是可以显得你的makefile很专业（不是那种初学者的作品）。</p><h3 id="检查规则"><strong>检查规则</strong></h3><p>有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用make命令的下述参数：</p><p>“-n” “--just-print” “--dry-run” “--recon”不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试makefile很有用处。</p><p>“-t” “--touch”这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。</p><p>“-q” “--question”这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。</p><p>“-W <file>” “--what-if=<file>” “--assume-new=<file>”“--new-file=<file>”这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令。</p><p>另外一个很有意思的用法是结合“-p”和“-v”来输出makefile被执行时的信息（这个将在后面讲述）。</p><h3 id="make的参数"><strong>make的参数</strong></h3><p>下面列举了所有GNU make3.80版的参数定义。其它版本和产商的make大同小异，不过其它产商的make的具体参数还是请参考各自的产品文档。</p><p>“-b” “-m” 这两个参数的作用是忽略和其它版本make的兼容性。</p><p>“-B” “--always-make” 认为所有的目标都需要更新（重编译）。</p>“-C<dir>” “--directory=<dir><p>”指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make–C ~hchen/test –C prog”等价于“make –C ~hchen/test/prog”。</p><p>“—debug[=<options>]”输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是<options>的取值：a —— 也就是all，输出所有的调试信息。（会非常的多） b ——也就是basic，只输出简单的调试信息。即输出不需要重编译的目标。 v ——也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等。i —— 也就是implicit，输出所以的隐含规则。 j ——也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等。 m ——也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息。</p><p>“-d” 相当于“--debug=a”。</p><p>“-e” “--environment-overrides”指明环境变量的值覆盖makefile中定义的变量的值。</p><p>“-f=<file>” “--file=<file>” “--makefile=<file>”指定需要执行的makefile。</p><p>“-h” “--help” 显示帮助信息。</p><p>“-i” “--ignore-errors” 在执行时忽略所有的错误。</p>“-I<dir>” “--include-dir=<dir><p>”指定一个被包含makefile的搜索目标。可以使用多个“-I”参数来指定多个目录。</p><p>“-j [<jobsnum>]” “--jobs[=<jobsnum>]”指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的“-j”参数，那么仅最后一个“-j”才是有效的。（注意这个参数在MS-DOS中是无用的）</p><p>“-k” “--keep-going”出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。</p><p>“-l <load>” “--load-average[=&lt;load]” “—max-load[=<load>]”指定make运行命令的负载。</p><p>“-n” “--just-print” “--dry-run” “--recon”仅输出执行过程中的命令序列，但并不执行。</p><p>“-o <file>” “--old-file=<file>” “--assume-old=<file>”不重新生成的指定的<file>，即使这个目标的依赖文件新于它。</p><p>“-p” “--print-data-base”输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。如果你只是想输出信息而不想执行makefile，你可以使用“make-qp”命令。如果你想查看执行makefile前的预设变量和规则，你可以使用“make –p–f/dev/null”。这个参数输出的信息会包含着你的makefile文件的文件名和行号，所以，用这个参数来调试你的makefile会是很有用的，特别是当你的环境变量很复杂的时候。</p><p>“-q” “--question”不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说明有错误发生。</p><p>“-r” “--no-builtin-rules” 禁止make使用任何隐含规则。</p><p>“-R” “--no-builtin-variabes”禁止make使用任何作用于变量上的隐含规则。</p><p>“-s” “--silent” “--quiet” 在命令运行时不输出命令的输出。</p><p>“-S” “--no-keep-going” “--stop”取消“-k”选项的作用。因为有些时候，make的选项是从环境变量“MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效。</p><p>“-t” “--touch”相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。</p><p>“-v” “--version” 输出make程序的版本、版权等关于make的信息。</p><p>“-w” “--print-directory”输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。</p><p>“--no-print-directory” 禁止“-w”选项。</p><p>“-W <file>” “--what-if=<file>” “--new-file=<file>”“--assume-file=<file>”假定目标<file>需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得<file>的修改时间为当前时间。</p><p>“--warn-undefined-variables”只要make发现有未定义的变量，那么就输出警告信息。</p><h2 id="十.隐含规则">十.隐含规则</h2><p>在我们使用Makefile时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译C/C++的源程序为中间目标文件（Unix下是[.o]文件，Windows下是[.obj]文件）。本章讲述的就是一些在Makefile中的“隐含的”，早先约定了的，不需要我们再写出来的规则。</p><p>“隐含规则”也就是一种惯例，make会按照这种“惯例”心照不喧地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把[.c]文件编译成[.o]文件这一规则，你根本就不用写出来，make会自动推导出这种规则，并生成我们需要的[.o]文件。</p><p>“隐含规则”会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量“CFLAGS”可以控制编译时的编译器参数。</p><p>我们还可以通过“模式规则”的方式写下自己的隐含规则。用“后缀规则”来定义隐含规则会有许多的限制。使用“模式规则”会更回得智能和清楚，但“后缀规则”可以用来保证我们Makefile的兼容性。我们了解了“隐含规则”，可以让其为我们更好的服务，也会让我们知道一些“约定俗成”了的东西，而不至于使得我们在运行Makefile时出现一些我们觉得莫名其妙的东西。当然，任何事物都是矛盾的，水能载舟，亦可覆舟，所以，有时候“隐含规则”也会给我们造成不小的麻烦。只有了解了它，我们才能更好地使用它。</p><h3 id="使用隐含规则">使用隐含规则</h3><p>如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是make事先约定好的一些东西。例如，我们有下面的一个Makefile：</p><p>foo : foo.o bar.o cc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)</p><p>我们可以注意到，这个Makefile中并没有写下如何生成foo.o和bar.o这两目标的规则和命令。因为make的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。</p><p>make会在自己的“隐含规则”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make调用的隐含规则是，把[.o]的目标的依赖文件置成[.c]，并使用C的编译命令“cc–c $(CFLAGS)[.c]”来生成[.o]的目标。也就是说，我们完全没有必要写下下面的两条规则：</p><p>foo.o : foo.c cc –c foo.c $(CFLAGS) bar.o : bar.c cc –c bar.c$(CFLAGS)</p><p>因为，这已经是“约定”好了的事了，make和我们约定好了用C编译器“cc”生成[.o]文件的规则，这就是隐含规则。</p><p>当然，如果我们为[.o]文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。</p><p>还有，在make的“隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则（没有命令）：</p><p>foo.o : foo.p</p><p>依赖文件“foo.p”（Pascal程序的源文件）有可能变得没有意义。如果目录下存在了“foo.c”文件，那么我们的隐含规则一样会生效，并会通过“foo.c”调用C的编译器生成foo.o文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后，所以，make找到可以生成foo.o的C的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出“依赖规则”，而不写命令。</p><h3 id="隐含规则一览">隐含规则一览</h3><p>这里我们将讲述所有预先设置（也就是make内建）的隐含规则，如果我们不明确地写下规则，那么，make就会在这些规则中寻找所需要规则和命令。当然，我们也可以使用make的参数“-r”或“--no-builtin-rules”选项来取消所有的预设置的隐含规则。</p><p>当然，即使是我们指定了“-r”参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了“后缀规则”来定义的，所以，只要隐含规则中有“后缀列表”（也就一系统定义在目标.SUFFIXES的依赖目标），那么隐含规则就会生效。默认的后缀列表是：.out,.a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym,.def, .h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web,.sh, .elc, .el。具体的细节，我们会在后面讲述。</p><p>还是先来看一看常用的隐含规则吧。</p><p><strong>1、编译C程序的隐含规则。</strong>“<n>.o”的目标的依赖目标会自动推导为“<n>.c”，并且其生成命令是“$(CC) –c$(CPPFLAGS) $(CFLAGS)”</p><p><strong>2、编译C++程序的隐含规则。</strong>“<n>.o”的目标的依赖目标会自动推导为“<n>.cc”或是“<n>.C”，并且其生成命令是“$(CXX)–c $(CPPFLAGS)$(CFLAGS)”。（建议使用“.cc”作为C++源文件的后缀，而不是“.C”）</p><p><strong>3、编译Pascal程序的隐含规则。</strong>“<n>.o”的目标的依赖目标会自动推导为“<n>.p”，并且其生成命令是“$(PC)–c $(PFLAGS)”。</p><p><strong>4、编译Fortran/Ratfor程序的隐含规则。</strong>“<n>.o”的目标的依赖目标会自动推导为“<n>.r”或“<n>.F”或“<n>.f”，并且其生成命令是:“.f” “$(FC) –c <span class="math inline">\((FFLAGS)”  “.F”“\)</span>(FC) –c $(FFLAGS) <spanclass="math inline">\((CPPFLAGS)”  “.f” “\)</span>(FC) –c $(FFLAGS)$(RFLAGS)”</p><p><strong>5、预处理Fortran/Ratfor程序的隐含规则。</strong>“<n>.f”的目标的依赖目标会自动推导为“<n>.r”或“<n>.F”。这个规则只是转换Ratfor或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：“.F” “$(FC) –F $(CPPFLAGS) <span class="math inline">\((FFLAGS)”  “.r”“\)</span>(FC) –F $(FFLAGS) $(RFLAGS)”</p><p><strong>6、编译Modula-2程序的隐含规则。</strong>“<n>.sym”的目标的依赖目标会自动推导为“<n>.def”，并且其生成命令是：“$(M2C)$(M2FLAGS) <span class="math inline">\((DEFFLAGS)”。“&lt;n.o&gt;”的目标的依赖目标会自动推导为“&lt;n&gt;.mod”，并且其生成命令是：“\)</span>(M2C)$(M2FLAGS) $(MODFLAGS)”。</p><p><strong>7、汇编和汇编预处理的隐含规则。 </strong>“<n>.o”的目标的依赖目标会自动推导为“<n>.s”，默认使用编译品“as”，并且其生成命令是：“$(AS)<span class="math inline">\((ASFLAGS)”。“&lt;n&gt;.s”的目标的依赖目标会自动推导为“&lt;n&gt;.S”，默认使用C预编译器“cpp”，并且其生成命令是：“\)</span>(AS)$(ASFLAGS)”。</p><p><strong>8、链接Object文件的隐含规则。</strong>“<n>”目标依赖于“<n>.o”，通过运行C的编译器来运行链接程序生成（一般是“ld”），其生成命令是：“$(CC)$(LDFLAGS) <n>.o $(LOADLIBES)$(LDLIBS)”。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则：</p><p>x : y.o z.o</p><p>并且“x.c”、“y.c”和“z.c”都存在时，隐含规则将执行如下命令：</p><p>cc -c x.c -o x.o cc -c y.c -o y.o cc -c z.c -o z.o cc x.o y.o z.o -ox rm -f x.o rm -f y.o rm -f z.o</p><p>如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。</p><p><strong>9、Yacc C程序时的隐含规则。</strong>“<n>.c”的依赖文件被自动推导为“n.y”（Yacc生成的文件），其生成命令是：“$(YACC)$(YFALGS)”。（“Yacc”是一个语法分析器，关于其细节请查看相关资料）</p><p><strong>10、Lex C程序时的隐含规则。</strong>“<n>.c”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX)$(LFALGS)”。（关于“Lex”的细节请查看相关资料）</p><p><strong>11、Lex Ratfor程序时的隐含规则。</strong>“<n>.r”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX)$(LFALGS)”。</p><p><strong>12、从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。</strong>“<n>.ln”（lint生成的文件）的依赖文件被自动推导为“n.c”，其生成命令是：“$(LINT)$(LINTFALGS) $(CPPFLAGS) -i”。对于“<n>.y”和“<n>.l”也是同样的规则。</p><h3 id="隐含规则使用的变量">隐含规则使用的变量</h3><p>在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的“-R”或“--no–builtin-variables”参数来取消你所定义的变量对隐含规则的作用。</p><p>例如，第一条隐含规则——编译C程序的隐含规则的命令是“$(CC) –c $(CFLAGS)<spanclass="math inline">\((CPPFLAGS)”。Make默认的编译命令是“cc”，如果你把变量“\)</span>(CC)”重定义成“gcc”，把变量“$(CFLAGS)”重定义成“-g”，那么，隐含规则中的命令全部会以“gcc–c -g $(CPPFLAGS)”的样子来执行了。</p><p>我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如“CC”；一种是参数相的关，如“CFLAGS”。下面是所有隐含规则中会用到的变量：</p><p><strong>1、关于命令的变量。</strong></p><p>AR 函数库打包程序。默认命令是“ar”。 AS汇编语言编译程序。默认命令是“as”。 CC C语言编译程序。默认命令是“cc”。CXX C++语言编译程序。默认命令是“g++”。 CO 从RCS文件中扩展文件程序。默认命令是“co”。 CPPC程序的预处理器（输出是标准输出设备）。默认命令是“$(CC) –E”。 FC Fortran和 Ratfor 的编译器和预处理程序。默认命令是“f77”。 GET从SCCS文件中扩展文件的程序。默认命令是“get”。 LEXLex方法分析器程序（针对于C或Ratfor）。默认命令是“lex”。 PCPascal语言编译程序。默认命令是“pc”。 YACCYacc文法分析器（针对于C程序）。默认命令是“yacc”。 YACCRYacc文法分析器（针对于Ratfor程序）。默认命令是“yacc –r”。 MAKEINFO转换Texinfo源文件（.texi）到Info文件程序。默认命令是“makeinfo”。 TEX从TeX源文件创建TeX DVI文件的程序。默认命令是“tex”。 TEXI2DVI从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是“texi2dvi”。 WEAVE转换Web到TeX的程序。默认命令是“weave”。 CWEAVE 转换C Web 到TeX的程序。默认命令是“cweave”。 TANGLE转换Web到Pascal语言的程序。默认命令是“tangle”。 CTANGLE 转换C Web 到C。默认命令是“ctangle”。 RM 删除文件命令。默认命令是“rm –f”。</p><p><strong>2、关于命令参数的变量 </strong>下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。</p><p>ARFLAGS 函数库打包程序AR命令的参数。默认值是“rv”。 ASFLAGS汇编语言编译器参数。（当明显地调用“.s”或“.S”文件时）。 CFLAGSC语言编译器参数。 CXXFLAGS C++语言编译器参数。 COFLAGS RCS命令参数。CPPFLAGS C预处理器参数。（ C 和 Fortran 编译器也会用到）。 FFLAGSFortran语言编译器参数。 GFLAGS SCCS “get”程序参数。 LDFLAGS链接器参数。（如：“ld”） LFLAGS Lex文法分析器参数。 PFLAGSPascal语言编译器参数。 RFLAGS Ratfor 程序的Fortran 编译器参数。 YFLAGSYacc文法分析器参数。</p><h3 id="隐含规则链">隐含规则链</h3><p>有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个[.o]的文件生成，可能会是先被Yacc的[.y]文件先成[.c]，然后再被C的编译器生成。我们把这一系列的隐含规则叫做“隐含规则链”。</p><p>在上面的例子中，如果文件[.c]存在，那么就直接调用C的编译器的隐含规则，如果没有[.c]文件，但有一个[.y]文件，那么Yacc的隐含规则会被调用，生成[.c]文件，然后，再调用C编译的隐含规则最终由[.c]生成[.o]文件，达到目标。</p><p>我们把这种[.c]的文件（或是目标），叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少，其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成？怎么我的makefile发疯了？</p><p>在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以“rm-f”删除。</p><p>通常，一个被makefile指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标“.INTERMEDIATE”来强制声明。（如：.INTERMEDIATE： mid ）</p><p>你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标“.SECONDARY”来强制声明（如：.SECONDARY:sec）。你还可以把你的目标，以模式的方式来指定（如：%.o）成伪目标“.PRECIOUS”的依赖目标，以保存被隐含规则所生成的中间文件。</p><p>在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。</p><p>Make会优化一些特殊的隐含规则，而不生成中间文件。如，从文件“foo.c”生成目标程序“foo”，按道理，make会编译生成中间文件“foo.o”，然后链接成“foo”，但在实际情况下，这一动作可以被一条“cc”的命令完成（cc–o foo foo.c），于是优化过的规则就不会生成中间文件。</p><h3 id="定义模式规则">定义模式规则</h3><p>你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有<code>%</code>字符。<code>%</code>的意思是表示一个或多个任意字符。在依赖目标中同样可以使用<code>%</code>，只是依赖目标中的<code>%</code>的取值，取决于其目标。</p><p>有一点需要注意的是，<code>%</code>的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入Makefile时，而模式规则中的<code>%</code>则发生在运行时。</p><p><strong>1、模式规则介绍</strong></p><p>模式规则中，至少在规则的目标定义中要包含<code>%</code>，否则，就是一般的规则。目标中的<code>%</code>定义表示对文件名的匹配，<code>%</code>表示长度任意的非空字符串。例如：<code>%.c</code>表示以<code>.c</code>结尾的文件名（文件名的长度至少为3），而<code>s.%.c</code>则表示以<code>s.</code>开头，<code>.c</code>结尾的文件名（文件名的长度至少为5）。</p><p>如果<code>%</code>定义在目标中，那么，目标中的<code>%</code>的值决定了依赖目标中的<code>%</code>的值，也就是说，目标中的模式的<code>%</code>决定了依赖目标中<code>%</code>的样子。例如有一个模式规则如下：</p><p>%.o : %.c ; &lt;command ......&gt;</p><p>其含义是，指出了怎么从所有的[.c]文件生成相应的[.o]文件的规则。如果要生成的目标是<code>a.o b.o</code>，那么<code>%c</code>就是<code>a.c b.c</code>。</p><p>一旦依赖目标中的<code>%</code>模式被确定，那么，make会被要求去匹配当前目录下所有的文件名，一旦找到，make就会规则下的命令，所以，在模式规则中，目标可能会是多个的，如果有模式匹配出多个目标，make就会产生所有的模式目标，此时，make关心的是依赖的文件名和生成目标的命令这两件事。</p><p><strong>2、模式规则示例</strong></p><p>下面这个例子表示了,把所有的[.c]文件都编译成[.o]文件.</p><p>%.o : %.c $(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@</p><p>其中，<code>$@</code>表示所有的目标的挨个值，<code>$&lt;</code>表示了所有依赖目标的挨个值。这些奇怪的变量我们叫<code>自动化变量</code>，后面会详细讲述。</p><p>下面的这个例子中有两个目标是模式的：</p><p>%.tab.c %.tab.h: %.y bison -d $&lt;</p><p>这条规则告诉make把所有的[.y]文件都以<code>bison -d  &lt;n&gt;.y</code>执行，然后生成<code>&lt;n&gt;.tab.c</code>和<code>&lt;n&gt;.tab.h</code>文件。（其中，<code>&lt;n&gt;</code>表示一个任意字符串）。如果我们的执行程序<code>foo</code>依赖于文件<code>parse.tab.o</code>和<code>scan.o</code>，并且文件<code>scan.o</code>依赖于文件<code>parse.tab.h</code>，如果<code>parse.y</code>文件被更新了，那么根据上述的规则，<code>bison -d  parse.y</code>就会被执行一次，于是，<code>parse.tab.o</code>和<code>scan.o</code>的依赖文件就齐了。（假设，<code>parse.tab.o</code>由<code>parse.tab.c</code>生成，和<code>scan.o</code>由<code>scan.c</code>生成，而<code>foo</code>由<code>parse.tab.o</code>和<code>scan.o</code>链接生成，而且foo和其[.o]文件的依赖关系也写好，那么，所有的目标都会得到满足）</p><p><strong>3、自动化变量</strong></p><p>在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。</p><p>自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。</p><p>下面是所有的自动化变量及其说明：</p><p>**<spanclass="math inline">\(@**  表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，`\)</span>@`就是匹配于目标中模式定义的集合。</p><p>**<spanclass="math inline">\(%**  仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是`foo.a(bar.o)`，那么，`\)</span>%<code>就是</code>bar.o<code>，</code>$@<code>就是</code>foo.a`。如果目标不是函数库文件（Unix下是[.a]，Windows下是[.lib]），那么，其值为空。</p><p>**<spanclass="math inline">\(&lt;**  依赖目标中的第一个目标名字。如果依赖目标是以模式（即`%`）定义的，那么`\)</span>&lt;`将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</p><p><strong>$?</strong> 所有比目标新的依赖目标的集合。以空格分隔。</p><p><strong>$^</strong>所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。</p><p>**<spanclass="math inline">\(+**  这个变量很像`\)</span>^`，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</p><p>**<spanclass="math inline">\(\***  这个变量表示目标模式中`%`及其之前的部分。如果目标是`dir/a.foo.b`，并且目标的模式是`a.%.b`，那么，`\)</span><em><code>的值就是</code>dir/a.foo<code>。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么</code><spanclass="math inline">\(*`也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么`\)</span></em><code>就是除了后缀的那一部分。例如：如果目标是</code>foo.c<code>，因为</code>.c<code>是make所能识别的后缀名，所以，</code><spanclass="math inline">\(*`的值就是`foo`。这个特性是GNUmake的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用`\)</span><em><code>，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么</code>$</em>`就是空值。</p><p>当你希望只对更新过的依赖文件进行操作时，<code>$?</code>在显式规则中很有用，例如，假设有一个函数库文件叫<code>lib</code>，其由其它几个object文件更新。那么把object文件打包的比较有效率的Makefile规则是：</p><p>lib : foo.o bar.o lose.o win.o ar r lib $?</p><p>在上述所列出来的自动量变量中。四个变量（<spanclass="math inline">\(@、\)</span>&lt;、<spanclass="math inline">\(%、\)</span>*）在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上<code>D</code>或<code>F</code>字样。这是GNUmake中老版本的特性，在新版本中，我们使用函数<code>dir</code>或<code>notdir</code>就可以做到了。<code>D</code>的含义就是Directory，就是目录，<code>F</code>的含义就是File，就是文件。</p><p>下面是对于上面的七个变量分别加上<code>D</code>或是<code>F</code>的含义：</p><p>**<spanclass="math inline">\((@D)**  表示`\)</span>@<code>的目录部分（不以斜杠作为结尾），如果</code><spanclass="math inline">\(@`值是`dir/foo.o`，那么`\)</span>(<spanclass="citation"data-cites="D">@D</span>)<code>就是</code>dir<code>，而如果</code>$@<code>中没有包含斜杠的话，其值就是</code>.`（当前目录）。</p><p>**<spanclass="math inline">\((@F)**  表示`\)</span>@<code>的文件部分，如果</code><spanclass="math inline">\(@`值是`dir/foo.o`，那么`\)</span>(<spanclass="citation"data-cites="F">@F</span>)<code>就是</code>foo.o<code>，</code><spanclass="math inline">\((@F)`相当于函数`\)</span>(notdir $@)`。</p><p><strong><code>$(\*D)</code> <code>$(\*F)</code></strong>和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子，<code>$(*D)</code>返回<code>dir</code>，而<code>$(*F)</code>返回<code>foo</code></p><p><strong><code>$(%D)</code> <code>$(%F)</code></strong>分别表示了函数包文件成员的目录部分和文件部分。这对于形同<code>archive(member)</code>形式的目标中的<code>member</code>中包含了不同的目录很有用。</p><p><strong><code>$(&lt;D)</code> <code>$(&lt;F)</code></strong>分别表示依赖文件的目录部分和文件部分。</p><p><strong><code>$(^D)</code> <code>$(^F)</code></strong>分别表示所有依赖文件的目录部分和文件部分。（无相同的）</p><p><strong><code>$(+D)</code> <code>$(+F)</code></strong>分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）</p><p><strong><code>$(?D)</code> <code>$(?F)</code></strong>分别表示被更新的依赖文件的目录部分和文件部分。</p><p>最后想提醒一下的是，对于<code>$&lt;</code>，为了避免产生不必要的麻烦，我们最好给<spanclass="math inline">\(后面的那个特定字符都加上圆括号，比如，`\)</span>(&lt;)<code>就要比</code>$&lt;`要好一些。</p><p>还得要注意的是，这些变量只使用在规则的命令中，而且一般都是<code>显式规则</code>和<code>静态模式规则</code>（参见前面<code>书写规则</code>一章）。其在隐含规则中并没有意义。</p><p><strong>4、模式的匹配</strong></p><p>一般来说，一个目标的模式有一个有前缀或是后缀的<code>%</code>，或是没有前后缀，直接就是一个<code>%</code>。因为<code>%</code>代表一个或多个字符，所以在定义好了的模式中，我们把<code>%</code>所匹配的内容叫做<code>茎</code>，例如<code>%.c</code>所匹配的文件<code>test.c</code>中<code>test</code>就是<code>茎</code>。因为在目标和依赖目标中同时有<code>%</code>时，依赖目标的<code>茎</code>会传给目标，当做目标中的<code>茎</code>。</p><p>当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行<code>茎</code>的传递时，我们需要知道这个步骤。例如有一个模式<code>e%t</code>，文件<code>src/eat</code>匹配于该模式，于是<code>src/a</code>就是其<code>茎</code>，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式<code>c%r</code>，那么，目标就是<code>src/car</code>。（<code>茎</code>被传递）</p><p><strong>5、重载内建隐含规则</strong></p><p>你可以重载内建的隐含规则（或是定义一个全新的），例如你可以重新构造和内建隐含规则不同的命令，如：</p><p>%.o : %.c $(CC) -c $(CPPFLAGS) <span class="math inline">\((CFLAGS)-D\)</span>(date)</p><p>你可以取消内建的隐含规则，只要不在后面写命令就行。如：</p><p>%.o : %.s</p><p>同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。</p><h3 id="老式风格的后缀规则">老式风格的后缀规则</h3><p>后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规则更强更清晰。为了和老版本的Makefile兼容，GNUmake同样兼容于这些东西。后缀规则有两种方式：<code>双后缀</code>和<code>单后缀</code>。</p><p>双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如<code>.c.o</code>相当于<code>%o : %c</code>。单后缀规则只定义一个后缀，也就是源文件的后缀。如<code>.c</code>相当于<code>% : %.c</code>。</p><p>后缀规则中所定义的后缀应该是make所认识的，如果一个后缀是make所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被make所认识，那就是双后缀规则。例如：<code>.c</code>和<code>.o</code>都是make所知道。因而，如果你定义了一个规则是<code>.c.o</code>那么其就是双后缀规则，意义就是<code>.c</code>是源文件的后缀，<code>.o</code>是目标文件的后缀。如下示例：</p><p>.c.o: $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;</p><p>后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如：</p><p>.c.o: foo.h $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;</p><p>这个例子，就是说，文件<code>.c.o</code>依赖于文件<code>foo.h</code>，而不是我们想要的这样：</p><p>%.o: %.c foo.h $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;</p><p>后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。</p><p>而要让make知道一些特定的后缀，我们可以使用伪目标<code>.SUFFIXES</code>来定义或是删除，如：</p><p>.SUFFIXES: .hack .win</p><p>把后缀.hack和.win加入后缀列表中的末尾。</p><p>.SUFFIXES: # 删除默认的后缀 .SUFFIXES: .c .o .h # 定义自己的后缀</p><p>先清楚默认后缀，后定义自己的后缀列表。</p><p>make的参数<code>-r</code>或<code>-no-builtin-rules</code>也会使用得默认的后缀列表为空。而变量<code>SUFFIXE</code>被用来定义默认的后缀列表，你可以用<code>.SUFFIXES</code>来改变后缀列表，但请不要改变变量<code>SUFFIXE</code>的值。</p><h3 id="隐含规则搜索算法">隐含规则搜索算法</h3><p>比如我们有一个目标叫T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是<code>archive(member)</code>的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把<code>member</code>当作T来搜索。</p><p>1、把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是<code>src/foo.o</code>，那么，D就是<code>src/</code>，N就是<code>foo.o</code>）</p><p>2、创建所有匹配于T或是N的模式规则列表。</p><p>3、如果在模式规则列表中有匹配所有文件的模式，如<code>%</code>，那么从列表中移除其它的模式。</p><p>4、移除列表中没有命令的规则。</p><p>5、对于第一个在列表中的模式规则：1）推导其<code>茎</code>S，S应该是T或是N匹配于模式中<code>%</code>非空的部分。2）计算依赖文件。把依赖文件中的<code>%</code>都替换成<code>茎</code>S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。3）测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫<code>理当存在</code>）4）如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。</p><p>6、如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：1）如果规则是终止规则，那就忽略它，继续下一条模式规则。2）计算依赖文件。（同第5步） 3）测试所有的依赖文件是否存在或是理当存在。4）对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。5）如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。</p><p>7、如果没有隐含规则可以使用，查看<code>.DEFAULT</code>规则，如果有，采用，把<code>.DEFAULT</code>的命令给T使用。</p><p>一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。</p><h2 id="十一.使用make更新函数库文件">十一.使用make更新函数库文件</h2><p>函数库文件也就是对Object文件（程序编译的中间文件）的打包文件。在Unix下，一般是由命令<code>ar</code>来完成打包工作。</p><h3 id="函数库文件的成员"><strong>函数库文件的成员</strong></h3><p>一个函数库文件由多个文件组成。你可以以如下格式指定函数库文件及其组成：</p><p>archive(member)</p><p>这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了<code>ar</code>命令来服务的。如：</p><p>foolib(hack.o) : hack.o ar cr foolib hack.o</p><p>如果要指定多个member，那就以空格分开，如：</p><p>foolib(hack.o kludge.o)</p><p>其等价于：</p><p>foolib(hack.o) foolib(kludge.o)</p><p>你还可以使用Shell的文件通配符来定义，如：</p><p>foolib(*.o)</p><h3 id="函数库成员的隐含规则"><strong>函数库成员的隐含规则</strong></h3><p>当make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是<code>a(m)</code>形式的，其会把目标变成<code>(m)</code>。于是，如果我们的成员是<code>%.o</code>的模式定义，并且如果我们使用<code>make  foo.a(bar.o)</code>的形式调用Makefile时，隐含规则会去找<code>bar.o</code>的规则，如果没有定义bar.o的规则，那么内建隐含规则生效，make会去找bar.c文件来生成bar.o，如果找得到的话，make执行的命令大致如下：</p><p>cc -c bar.c -o bar.o ar r foo.a bar.o rm -f bar.o</p><p>还有一个变量要注意的是<code>$%</code>，这是专属函数库文件的自动化变量，有关其说明请参见<code>自动化变量</code>一节。</p><h3 id="函数库文件的后缀规则"><strong>函数库文件的后缀规则</strong></h3><p>你可以使用<code>后缀规则</code>和<code>隐含规则</code>来生成函数库打包文件，如：</p><p>.c.a: $(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $<em>.o $(AR) r $@$</em>.o $(RM) $*.o</p><p>其等效于：</p><p>(%.o) : %.c $(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $<em>.o $(AR) r$@ $</em>.o $(RM) $*.o</p><h3 id="注意事项"><strong>注意事项</strong></h3><p>在进行函数库打包文件生成时，请小心使用make的并行机制（<code>-j</code>参数）。如果多个ar命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。所以，在make未来的版本中，应该提供一种机制来避免并行操作发生在函数打包文件上。</p><p>但就目前而言，你还是应该不要尽量不要使用<code>-j</code>参数。</p><p>WORK_DIR = /home/lzm/ysyx-workbench/nemu</p><p>BUILD_DIR = $(WORK_DIR)/build</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;makefile学习笔记&quot;&gt;Makefile学习笔记&lt;/h1&gt;
&lt;figure class=&quot;highlight makefile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;b</summary>
      
    
    
    
    <category term="工具" scheme="https://zmailee.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Makefile" scheme="https://zmailee.github.io/tags/Makefile/"/>
    
  </entry>
  
  <entry>
    <title>梅森旋转算法</title>
    <link href="https://zmailee.github.io/2022/11/11/%E6%A2%85%E6%A3%AE%E8%9E%BA%E6%97%8B%E7%AE%97%E6%B3%95/"/>
    <id>https://zmailee.github.io/2022/11/11/%E6%A2%85%E6%A3%AE%E8%9E%BA%E6%97%8B%E7%AE%97%E6%B3%95/</id>
    <published>2022-11-11T03:38:19.140Z</published>
    <updated>2022-11-12T15:01:30.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景知识">背景知识</h1><p>梅森数：形如<spanclass="math inline">\(2^p－1\)</span>的一类数，指数p是素数，常记为Mp。</p><p>梅森素数：是素数的梅森数，就称为梅森素数</p><p>真随机数：使用物理现象产生的：比如掷钱币、骰子、转轮、使用电子元件的噪音、核裂变等等，这样的随机数发生器叫做物理性随机数发生器。</p><p>伪随机数：按照一定算法模拟产生的，其结果是确定的，是可见的。我们可以这样认为这个可预见的结果其出现的概率是100%。用计算机随机函数所产生的“随机数”并不随机，是伪随机数。</p><span id="more"></span><p>本原多项式：一个 m 阶的不可约多项式 <spanclass="math inline">\(\large f(x)\)</span>，如果 <spanclass="math inline">\(\large f(x)\)</span> 整除 <spanclass="math inline">\(\large x^n+ 1\)</span>的最小正整数 n 满足 <spanclass="math inline">\(n = 2^m − 1\)</span> ，则该多项式是本原的。</p><figure><img src="梅森螺旋算法.assets/OIP-C.jpeg" alt="查看源图像" /><figcaption aria-hidden="true">查看源图像</figcaption></figure><p>线性反馈移位寄存器LFSR：</p><figure><imgsrc="梅森螺旋算法.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdHRsZV9zb2xkaWVy,size_16,color_FFFFFF,t_70.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>r级线性反馈移位寄存器唯一地表达为𝑟次幂的多项式<spanclass="math inline">\(G(x)=\sum_{i=0}^r{g_ix^i}, g_0=g_r=1\)</span></p><h1 id="梅森螺旋">梅森螺旋</h1><p><ahref="http://www.math.sci.hiroshima-u.ac.jp/m-mat/MT/emt.html">MersenneTwister: A random number generator (since 1997/10)</a></p><p>MersenneTwister这个名字来自周期长度通常取Mersenne素数这样一个事实。常见的有两个变种MersenneTwister MT19937和Mersenne Twister MT19937-64。</p><p>Mersenne Twister算法的原理：MersenneTwister算法是利用线性反馈移位寄存器(LFSR)产生随机数的，LFSR的反馈函数是寄存器中某些位的简单异或。</p><p>一个n位的LFSR在重复之前最多产生<spanclass="math inline">\(2^n-1\)</span>位的伪随机序列。只有具有一定抽头序列的LFSR才能产生<spanclass="math inline">\(2^n-1\)</span>位长的伪随机序列。为了使LFSR成为最大周期的LFSR，由抽头序列加上常数1形成的多项式必须是本原多项式。例如(32,7,5,3,2,1,0)是指本原多项式<spanclass="math inline">\(x^{32}+x^7+x^5+x^3+x^2+x+1\)</span>，把它转化为最大周期LFSR就是在LFSR的第32，7，5，2，1位抽头。利用上述两种方法产生周期为m的伪随机序列后，只需要将产生的伪随机序列除以序列的周期，就可以得到(0，1)上均匀分布的伪随机序列了。</p><p>MersenneTwister优点：随机性好，在计算机上容易实现，占用内存较少(MT19937的C代码执行仅需624个字的工作区域)，与其它已使用的伪随机数发生器相比，产生随机数的速度快、周期长，可达到2^19937-1，且具有623维均匀分布的性质，序列关联比较小，能通过很多随机性测试。</p><p><strong>其他随机数产生器性能对比</strong></p><figure><img src="梅森螺旋算法.assets/ce74efc0d7db44589e385feaa8b75832.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h1 id="verilog实现">Verilog实现</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景知识&quot;&gt;背景知识&lt;/h1&gt;
&lt;p&gt;梅森数：形如&lt;span
class=&quot;math inline&quot;&gt;\(2^p－1\)&lt;/span&gt;的一类数，指数p是素数，常记为Mp。&lt;/p&gt;
&lt;p&gt;梅森素数：是素数的梅森数，就称为梅森素数&lt;/p&gt;
&lt;p&gt;真随机数：使用物理现象产生的：比如掷钱币、骰子、转轮、使用电子元件的噪音、核裂变等等，这样的随机数发生器叫做物理性随机数发生器。&lt;/p&gt;
&lt;p&gt;伪随机数：按照一定算法模拟产生的，其结果是确定的，是可见的。我们可以这样认为这个可预见的结果其出现的概率是100%。用计算机随机函数所产生的“随机数”并不随机，是伪随机数。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://zmailee.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="梅森素数" scheme="https://zmailee.github.io/tags/%E6%A2%85%E6%A3%AE%E7%B4%A0%E6%95%B0/"/>
    
    <category term="伪随机数" scheme="https://zmailee.github.io/tags/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>SynopsysEDA</title>
    <link href="https://zmailee.github.io/2022/11/10/SynopsysEDA/"/>
    <id>https://zmailee.github.io/2022/11/10/SynopsysEDA/</id>
    <published>2022-11-10T07:20:14.357Z</published>
    <updated>2022-11-13T11:07:57.080Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><strong>Design Compiler</strong> for the synthesis,</p></li><li><p><strong>ICC Compiler</strong> for the layout</p></li><li><p><strong>PrimeTime</strong> for static timing analysis</p></li></ul><p>新思安装指南：<ahref="https://link.zhihu.com/?target=http%3A//www.synopsys.com/install">http://www.synopsys.com/install</a></p><p>新思license快速入门指南： <ahref="https://link.zhihu.com/?target=http%3A//www.synopsys.com/licensing">http://www.synopsys.com/licensing</a></p><span id="more"></span><h1 id="第一章design-compiler使用">第一章：Design Compiler使用</h1><h2 id="综合">1.1综合</h2><p>Systhesis = Translation(转换) + G ate M apping(映射) + Logic O ptimization(优化)</p><ul><li>Tranlation：把电路转换为ED A 内部数据</li><li>Mapping：将门级网表映射到晶圆厂给定的工艺库上，形成对应的门级网表</li><li>Optimization：根据工作频率、面积、功耗来对电路进行优化，推断出满足要求的门级网表</li></ul><h2 id="逻辑综合流程">1.2逻辑综合流程</h2><p>1.读取库和设计：包括目标库、链接库、符号库等</p><p>2.添加时序约束和设计规则约束：包括环境约束、面积约束、时序约束等</p><p>3.综合RTL设计：将RTL代码转换为用标准单元表示的门级网表</p><p>4.分析结果</p><p>5.输出设计数据</p><h2 id="command">1.3Command</h2><p><strong>所有命令均可以使用man进行查询</strong></p><h3 id="启动-dc">启动 DC</h3><p>DC在启动时会自动在启动目录下创建“command.log”和“view_command.log”两个文件，用于记录用户在使用DC时所执行的命令及设置的参数。还会创建“filenames.log”，用于记录DC访问过的目录，包括库、源文件等，退出DC时会被自动删除。启动dc_shell只产生“command.log”日志文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">dc_shell   <span class="hljs-comment">#命令行</span><br>dc_shell -f syn.tcl | <span class="hljs-built_in">tee</span> -i syn.log <span class="hljs-comment">#批量模式(batch mode)</span><br>design_analyzer <span class="hljs-comment">#图形，基于dc_shell</span><br>dc_shell_t <span class="hljs-comment">#命令行</span><br>  <span class="hljs-comment"># 以tcl为基础；</span><br>  <span class="hljs-comment"># 在该脚本语言上扩展了实现DC的命令；</span><br>  <span class="hljs-comment"># 也可直接调用tcl脚本“dc_shell_t -f script”来执行。 `推荐`</span><br>design_vision <span class="hljs-comment">#图形，基于tcl</span><br><span class="hljs-built_in">source</span> dc.tcl  <span class="hljs-comment">#启动后可以运行tcl脚本</span><br></code></pre></td></tr></table></figure><h3id="读取verilog设置顶层设置路径">读取verilog，设置顶层，设置路径</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">read_verilog xxx.v<br>current_design TOP <span class="hljs-comment">#设置最顶层的模块</span><br>set_app_var search_path <span class="hljs-string">&quot;<span class="hljs-variable">$search_path</span> ./rtl&quot;</span><br></code></pre></td></tr></table></figure><p><strong>Search Path</strong>: 当在LinkLibrary中无法找到某些模块时，DC会在SearchPath下的库中自动找对应的模块。比如Synopsis的DesignWare中的库就缺省包含在了SearchPath下，这也就是为什么一般不需要手动设置SyntheticLibrary的原因。在Verilog源文件中，如果找不到include的文件，也会在SearchPath下寻找。<strong>DC在search_path指定的目录底下寻找设计代码和库文件。</strong></p><h3 id="建立库">建立库</h3><ul><li><p><strong>Target Library</strong>：由厂商提供，后缀一般为".db"，Verilog文件映射为门级网表的时候，就在里面查找标准单元。</p></li><li><p><strong>LinkLibrary</strong>：并非所有Verilog代码都可以转化为TargetLibrary中的标准单元（比如PLL，编译好的RAM），这就需要告诉DC这些东西在那些库里。</p></li></ul><p><code>dw_foundation.sldb</code>是在你的设计中使用了SynopsysDesignWare提供的IP时，方便DC找到相应的IP，否则link会报错</p><ul><li><strong>SymbolLibrary</strong>：标准单元在电脑上显示的“图标”，一般后缀为“.sdb”。</li><li><strong>SyntheticLibrary</strong>：Synopsis内部集成了很多可以复用的逻辑，比如+, -, *,&lt;, &gt;, &lt;=,&gt;=这些运算，并且可以根据不同的要求来选择不同的实现，比如选择Booth乘法器或者WallaceTree乘法器等等，一般这个库不用载入，DC会自动载入Synopsis的DesignWare。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#target library(工艺库) </span><br>set_app_var target_library xxx.db<br><span class="hljs-built_in">set</span> target_library  xxx.db<br><br><span class="hljs-comment">#link library(链接库) </span><br>set_app_var link_library xxx.db<br>set_app_var link_library <span class="hljs-string">&quot;<span class="hljs-variable">$target_library</span>&quot;</span><br><span class="hljs-built_in">set</span> link_library   [ list * xxx.db Lib/dw_foundation.sldb]<br><span class="hljs-comment"># “*”号表示如果设计中某个模块找不到对应的库，那么就现在DC内存中搜索</span><br><span class="hljs-built_in">set</span> symbol_library  <span class="hljs-string">&quot;xxx/xxx.sdb&quot;</span><br></code></pre></td></tr></table></figure><p>gtech.db和standard.db是synopsys提供的默认库，分别包含了GTECH逻辑单元和基本的DesignWareIP模块。在使用read命令时，这些库都被自动地加载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">elaborate design_name<br>      [-library library_name | -work library_name]<br>      [-architecture arch_name]<br>      [-parameters param_list]<br>      [-file_parameters file_list]<br>      [-update]<br>      [-ref]<br></code></pre></td></tr></table></figure><h3 id="时钟约束">时钟约束</h3><h4 id="creat_clock">creat_clock</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">create_clock -period 2 [get_ports CLK] <span class="hljs-comment">#clock period 2ns</span><br>creat_clock-periodperiod_value<span class="hljs-comment">#定义时钟周期，如-period 10</span><br>[source_objects]<span class="hljs-comment">#标识时钟源，如[get_ports A]</span><br>[-name clock_name]<span class="hljs-comment">#命名时钟，如-name CLK</span><br>[-waveform edge_list]<span class="hljs-comment">#指定占空比，如-waveform &#123;0 5&#125;</span><br>[-add]<span class="hljs-comment">#多源时钟，加此开关且各源时钟不同名</span><br>[-comment comment_string]<span class="hljs-comment">#注释时钟，字符串纪录时钟信号文档信息</span><br></code></pre></td></tr></table></figure><h4id="creat_generated_clock时钟分频或倍频">creat_generated_clock（时钟分频或倍频）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs bash">creat_generated_clock<br>  <span class="hljs-comment">#定义生成时钟的源对象，即生成时钟的引脚，如[get_pins FF1/Q]</span><br>  [source_objects]<br><br>  <span class="hljs-comment">#定义生成时钟的源时钟的引脚，如-source [get_ports CLK]</span><br>  -<span class="hljs-built_in">source</span> clock_source_pin<br><br>  <span class="hljs-comment">#多源时钟复用于一个源时钟的引脚CLK，需指明当前源时钟</span><br>  <span class="hljs-comment">#如源时钟C1与C2复用得到生成时钟GC1与GC2，需分别定义GC1与GC2</span><br>  <span class="hljs-comment">#其中定义GC1加入开关-master_clock C1，定义GC2加入开关-master_clock C2</span><br>  [-master_clock master_clock_name]<br><br>  <span class="hljs-comment">#生成时钟命名，如-name GCLK1</span><br>  [-name generated_clock_name]<br><br>  <span class="hljs-comment">#生成时钟特性，生成时钟的上升-下降-上升沿对应的源时钟边沿序号，为奇数个整数</span><br>  <span class="hljs-comment">#如-edges &#123;1 3 5&#125;，表示二分频的时钟特性</span><br>  <span class="hljs-comment">#即生成时钟在源时钟第1个边沿处上升，第3个边沿处下降，第5个边沿处上升</span><br>  [-edges edge_list]<br><br>  <span class="hljs-comment">#生成时钟特性，时钟分频因子，如二分频-divide_by 2</span><br>  [-divide_by <span class="hljs-built_in">factor</span>]<br><br>  <span class="hljs-comment">#生成时钟特性，时钟倍频因子，如二倍频-multiply_by 2</span><br>  [-multiply_by <span class="hljs-built_in">factor</span>]<br><br>  <span class="hljs-comment">#使用分频或倍频时，生成时钟相位取反，用于定义D触发器的反向输出端时钟</span><br>  [-invert]<br><br>  <span class="hljs-comment">#时钟沿位移，与-edges有相同数量的浮点数</span><br>  <span class="hljs-comment">#表明-edges中每个边沿的超前或滞后情况</span><br>  <span class="hljs-comment">#如-edge_shift &#123;0 2 0&#125;，其中的单位为ns</span><br>  <span class="hljs-comment">#表示生成时钟的第1个与第2个上升沿无位移，第1个下降沿滞后2ns</span><br>  [-edge_shift shift_list]<br><br>  <span class="hljs-comment">#配合倍频使用，确定占空比，50表示占空比50%，如-duty_cycle 50</span><br>  [duty_cycle percent]<br><br>  <span class="hljs-comment">#使能组合电路路径，源时钟引脚到生成时钟引脚的路径是纯组合电路时使用</span><br>  <span class="hljs-comment">#可以阻隔路径中的时序电路，组合电路始终有效</span><br>  [-combinational]<br><br>  <span class="hljs-comment">#多源时钟，除第一个源时钟外，其他源时钟需加此开关，否则会被最后一个源时钟覆盖</span><br>  <span class="hljs-comment">#各源时钟-name不同名</span><br>  [-add]<br><br>  <span class="hljs-comment">#注释时钟，字符串纪录时钟信号文档信息</span><br>  [-comment comment_string]<br></code></pre></td></tr></table></figure><h4 id="set_clock_group异步时钟域">set_clock_group（异步时钟域）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">creat_clock_groups<br>  <span class="hljs-comment">#定义时钟组的名称</span><br>  [-name group_name]<br><br>  <span class="hljs-comment">#将不同的时钟分组，如将异步时钟C1与C2分入不同组为-group C1 -group C2</span><br>  [-group clock_list]<br><br>  <span class="hljs-comment">#各组之间的关系有以下三种：</span><br>  <span class="hljs-comment">#(1)逻辑独立，时钟组中各组互斥但具有耦合关系时，即各组时钟同时存在时使用</span><br>  <span class="hljs-comment">#与物理独立，异步互斥</span><br>  [-logically_exclusive]<br><br>  <span class="hljs-comment">#(2)物理独立，时钟组中各组时钟以多路复用实现，并不同时共存于电路网络中时使用</span><br>  <span class="hljs-comment">#与逻辑独立，异步互斥</span><br>  [-physically_exclusive]<br><br>  <span class="hljs-comment">#(3)异步，时钟不共享相位关系时使用</span><br>  <span class="hljs-comment">#与逻辑独立，物理独立互斥</span><br>  [-asynchronous]<br><br>  <span class="hljs-comment">#异步且希望执行串扰分析而不禁用时钟之间的时序电路路径时使用</span><br>  <span class="hljs-comment">#仅可与-asynchronous一起使用，用于信号完整性检查</span><br>  [-allow_paths]<br><br>  <span class="hljs-comment">#注释时钟组，字符串纪录时钟组信号文档信息</span><br>  [-comments comment_string]<br></code></pre></td></tr></table></figure><p>时钟分组建议：</p><ul><li>如果设计中共存多个时钟，却没有相位关系，则应在set_clock_group中设定-asynchronous</li><li>如果设计中共存多个时钟，并且电路仅选择其中一个，则应在set_clock_group中设定-logically_exclusive</li><li>如果设计中不能共存多个时钟，则应在set_clock_group中设定-physically_exclusive</li></ul><h4 id="set_clock_transition">set_clock_transition</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">set_clock_transition -max 0.15 [get_ports CLK] <span class="hljs-comment">#CLK跳转最大时间为0.15ns</span><br>set_clock_transition<br>[-rise]<span class="hljs-comment">#上升沿过渡时间</span><br>[-fall]<span class="hljs-comment">#下降沿过渡时间</span><br>[-max]<span class="hljs-comment">#最大过渡时间</span><br>[-min]<span class="hljs-comment">#最小过渡时间</span><br>clock_list<span class="hljs-comment">#应用的时钟，如[get_clocks CLK]</span><br>transition_time<span class="hljs-comment">#过渡时间的数值，单位为ns</span><br>set_max_transition 0.5 sync_FIFO  <br></code></pre></td></tr></table></figure><h4id="set_clock_uncertaintyskewjitter">set_clock_uncertainty（skew+jitter）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">set_clock_uncertainty -setup 0.3 [get_ports CLK] <span class="hljs-comment">#clock skew</span><br>set_clock_uncertainty<br>  <span class="hljs-comment">#两个异步时钟之间的不确定度</span><br>  [-from|-rise_from|-fall_from from_clock]<span class="hljs-comment">#交互时钟的起始边沿，如-from C1</span><br>  [-to|-rise_to|-fall_to to_clock]<span class="hljs-comment">#交互时钟的结束边沿，如-to C2</span><br>  <span class="hljs-comment">#单个时钟内部时钟的不确定度</span><br>  [-setup]<span class="hljs-comment">#建立时间不确定度</span><br>  [-hold]<span class="hljs-comment">#保持时间不确定度</span><br>  [-rise]<span class="hljs-comment">#上升沿时间不确定度</span><br>  [-fall]<span class="hljs-comment">#下降沿时间不确定度</span><br>  [object_list]<span class="hljs-comment">#时钟的源对象，如[get_clocks CLK]</span><br>  Uncertainty_value<span class="hljs-comment">#不确定度的数值，单位ns</span><br></code></pre></td></tr></table></figure><h4id="set_clock_latencysource-latencynetwork-latency">set_clock_latency（sourcelatency+network latency）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">set_clock_latency -max 0.7 [get_ports CLK] <span class="hljs-comment">#晶振到CLK端口所需最大时间为0.7ns</span><br>set_clock_latency<br>[-rise]<span class="hljs-comment">#上升沿的延迟</span><br>[-fall]<span class="hljs-comment">#下降沿的延迟</span><br>[-min]<span class="hljs-comment">#最小延迟</span><br>[-max]<span class="hljs-comment">#最大延迟</span><br>[-<span class="hljs-built_in">source</span>]<span class="hljs-comment">#片外时钟源至模块时钟端口间的延迟，如-source 0.5</span><br><span class="hljs-comment">#若关闭此开关，则表示模块时钟端口至触发器件之间的延时</span><br>[-late]<span class="hljs-comment">#片内时钟源至模块时钟端口的最长路径延迟，如-source -late 1.0</span><br>[-early]<span class="hljs-comment">#片内时钟源至模块时钟端口的最短路径延迟，如-source -early 0.5</span><br>[-clock clock_list]<span class="hljs-comment">#多个时钟通过一个模块端口的延迟，如-clock &#123;C1 C2&#125;</span><br>delay<span class="hljs-comment">#延迟的数值，单位为ns</span><br>object_list<span class="hljs-comment">#对引脚设定延迟，如[get_ports A]</span><br></code></pre></td></tr></table></figure><h4id="set_clock_sense时钟敏感性非单边">set_clock_sense（时钟敏感性：非单边）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">set_clock_sense<br>  <span class="hljs-comment">#三个开关互斥</span><br>  <span class="hljs-comment">#-positive指示正单边</span><br>  <span class="hljs-comment">#-negative指示负单边</span><br>  <span class="hljs-comment">#-stop_propagation指示禁用部分时钟的传递</span><br>  [-positive|-negative|-stop_propagation]<br><br>  <span class="hljs-comment">#创建时钟脉冲，可选项为</span><br>  <span class="hljs-comment">#rise_triggered_high_pulse</span><br>  <span class="hljs-comment">#rise_triggered_low_pulse</span><br>  <span class="hljs-comment">#fall_triggered_high_pulse</span><br>  <span class="hljs-comment">#high_triggered_low_pulse</span><br>  <span class="hljs-comment">#如-pulse rise_triggered_high_pulse，表示时钟上升沿产生一个高电平的脉冲</span><br>  <span class="hljs-comment">#脉冲的宽度为|rise_latency - fall_latency|</span><br>  [-pulse pulse]<br><br>  [-clock clock_list]<span class="hljs-comment">#定义影响指定敏感性引脚的时钟源</span><br>  pin_list<span class="hljs-comment">#需要指定敏感性的引脚，如[get_pins XOR/Z]</span><br></code></pre></td></tr></table></figure><h3 id="信号约束">信号约束</h3><h4 id="set_input_delay">set_input_delay</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">set_input_delay<br>  [-clock clock_name]<span class="hljs-comment">#指定参考时钟，如-clock CLK</span><br>  [-clock_fall]<span class="hljs-comment">#参考时钟是下降沿触发时打开</span><br>  [-level_sensitive]<span class="hljs-comment">#启动元器件为锁存器时使用，一般不用</span><br><br>  <span class="hljs-comment">#当模块输入端口信号上升沿和下降沿的输入到达时间不同</span><br>  <span class="hljs-comment">#使用-rise与-fall分别限定，但一般路径延迟相似，不会经常使用</span><br>  [-rise]<br>  [-fall]<br>  [-max]<span class="hljs-comment">#限定延迟值最大值，实现建立检查</span><br>  [-min]<span class="hljs-comment">#限定延迟值最小值，实现保持检查</span><br>  [-add_delay]<span class="hljs-comment">#同一个端口额外的延迟约束，则需使用，否则会被覆盖</span><br>  [-network_latency_included]<span class="hljs-comment">#额外指定时钟network延迟，不常使用</span><br>  [-source_latency_included]<span class="hljs-comment">#额外指定时钟source延迟，不常使用</span><br>  delay_value port_pin_list<span class="hljs-comment">#延迟的数值，单位ns；定义输入的端口</span><br>set_input_delay -max 0.6 -clock CLK [get_ports A] //A端口数据到寄存器输入时延<br></code></pre></td></tr></table></figure><h4 id="set_output_delay">set_output_delay</h4><figure><img src="SynopsysEDA.assets/webp.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="SynopsysEDA.assets/webp-16681351791993.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="SynopsysEDA.assets/webp-16681352041766.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">set_output_delay -max 0.8 -clock CLK [get_ports B] <span class="hljs-comment">#寄存器输出到B端口的时延  </span><br>set_output_delay<br>  [-clock clock_name]<span class="hljs-comment">#指定参考时钟，如-clock CLK</span><br>  [-clock_fall]<span class="hljs-comment">#参考时钟是下降沿触发时打开</span><br>  [-level_sensitive]<span class="hljs-comment">#启动元器件为锁存器时使用，一般不用</span><br><br>  <span class="hljs-comment">#当模块输入端口信号上升沿和下降沿的输入到达时间不同</span><br>  <span class="hljs-comment">#使用-rise与-fall分别限定，但一般路径延迟相似，不会经常使用</span><br>  [-rise]<br>  [-fall]<br><br>  [-max]<span class="hljs-comment">#限定延迟值最大值，实现建立检查</span><br>  [-min]<span class="hljs-comment">#限定延迟值最小值，实现保持检查</span><br>  [-add_delay]<span class="hljs-comment">#同一个端口额外的延迟约束，则需使用，否则会被覆盖</span><br>  [-network_latency_included]<span class="hljs-comment">#额外指定时钟network延迟，不常使用</span><br>  [-source_latency_included]<span class="hljs-comment">#额外指定时钟source延迟，不常使用</span><br>  delay_value port_pin_list<span class="hljs-comment">#延迟的数值，单位ns；定义输出的端口</span><br></code></pre></td></tr></table></figure><h4 id="set_drive驱动电阻">set_drive（驱动电阻）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">set_drive<br>[-rise][-fall]<span class="hljs-comment">#指定驱动信号的上升或下降沿</span><br>[-min][-max]<span class="hljs-comment">#指定驱动电阻的最小或最大值，小电阻驱动能力大，过渡快</span><br>resistance_value<span class="hljs-comment">#指定驱动电阻的数值</span><br>port_list<span class="hljs-comment">#指定驱动目标的输入端口</span><br></code></pre></td></tr></table></figure><h4 id="set_driving_cell驱动单元">set_driving_cell（驱动单元）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">set_driving_cell<br>[-lib_cell lib_cell_name]<span class="hljs-comment">#指定模块的驱动单元，如-lib_cell FA</span><br>[-rise][-fall]<span class="hljs-comment">#指定驱动信号的上升或下降沿</span><br>[-min][-max]<span class="hljs-comment">#指定最强或最弱驱动单元合集</span><br>[-library lib_name] <span class="hljs-comment">#指定驱动单元所在的库</span><br>[-pin pin_name] <span class="hljs-comment">#指定驱动单元用于驱动的输出引脚</span><br>[-from_pin from_pin_name]<span class="hljs-comment">#指定驱动单元输入引脚,不同输入,输出过渡时间不同</span><br>[-multiply_by <span class="hljs-built_in">factor</span>]<span class="hljs-comment">#过渡时间的倍乘因子，多驱动目标时驱动下降</span><br>[-dout_scale]<span class="hljs-comment">#电气特性扩展与降额，不使用时需使能此开关</span><br>[-no_design_rule]<span class="hljs-comment">#防止驱动引脚设计规则转移到目标输入端口</span><br>[-clock clock_name]<span class="hljs-comment">#指定驱动单元目标端口的时钟</span><br>[-clock_fall]<span class="hljs-comment">#表示时钟下降沿驱动</span><br>[-input_transition_rise rise_time]<span class="hljs-comment">#输入上升过渡时间</span><br>[-input_transition_fall fall_time]<span class="hljs-comment">#输入下降过渡时间</span><br>port_list<span class="hljs-comment">#被驱动的输入端口</span><br></code></pre></td></tr></table></figure><p>常用选项是指定驱动单元的名称和驱动单元的端口，其他不常用。通过<code>set_drive</code>和<code>set_driving_cell</code>可以计算出过渡时间，但也可以通过<code>set_input_transition</code>指定过渡时间。</p><h4id="set_input_transition输入过渡">set_input_transition（输入过渡）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">set_input_transition 0.12 [get_ports A] //输入端口A的电平跳变时间0.12ns<br>set_input_transition<br>[-rise][-fall]<span class="hljs-comment">#指定驱动信号的上升或下降沿</span><br>[-min][-max]<span class="hljs-comment">#指定最小或最大过渡时间</span><br>[-clock clock_name]<span class="hljs-comment">#指定时钟</span><br>[-clock_fall]<span class="hljs-comment">#表示时钟下降沿驱动</span><br>transition port_list<span class="hljs-comment">#指定约束的端口</span><br></code></pre></td></tr></table></figure><h4id="set_port_fanout_number扇出数">set_port_fanout_number（扇出数）</h4><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tcl">set_port_fanout_number<br>value #指定扇出数<br>port_list#指定约束的端口<br>set_max_fanout <span class="hljs-number">4</span> sync_FIFO   #约束cell的最大扇出,扇出过大会使cell delay变慢<br></code></pre></td></tr></table></figure><h4 id="set_load负载">set_load（负载）</h4><p><code>set_load</code>指定负载的实际电容负载</p><p><code>set_fanout_load</code>是根据标准负载指定负载值</p><p>电容负载=标准负载×单个标准负载的电容负载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">set_load [<span class="hljs-built_in">expr</span>&#123;30.0/1000&#125;] [get_ports B]<br>set_load<br>[-min][-max]<span class="hljs-comment">#指定最小或最大负载</span><br>[-subtract_pin_load]<span class="hljs-comment">#标注净电容负载时，需要打开避免与后端输入负载重复</span><br>[-pin_load]<span class="hljs-comment">#指定引脚负载</span><br>[-wire_load]<span class="hljs-comment">#指定线路负载</span><br>value   <span class="hljs-comment">#指定负载值</span><br>objects  <span class="hljs-comment">#指定约束的端口</span><br></code></pre></td></tr></table></figure><h3 id="其他约束">其他约束</h3><h4id="set_operating_conditions指定工作条件">set_operating_conditions（指定工作条件）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">set_operating_conditions<br>[-library lib_name]<span class="hljs-comment">#指定工艺库</span><br>[-analysis_type]<span class="hljs-comment">#应执行的分析类型，最慢，最快，基于芯片变异性的延迟</span><br>[-max max_condition]<span class="hljs-comment">#该工作点应考虑执行最慢的分析，如-max WCMIL</span><br>[-min min_condition]<span class="hljs-comment">#该工作点应考虑执行最快的分析，如-min BCIND</span><br>[-max_library max_lib]<span class="hljs-comment">#指定最慢的库</span><br>[-min_library min_lib]<span class="hljs-comment">#指定最快的库</span><br>[-object_list objects]<span class="hljs-comment">#设计对象，通常为整个设计，故很少使用</span><br>[condition]<span class="hljs-comment">#工作条件</span><br></code></pre></td></tr></table></figure><h4 id="set_units指定单位标识">set_units（指定单位标识）</h4><p>该命令仅作为表示用户意图的文档，工具会检查正在使用的库中单位，并标记库中单位与命令指定单位是否存在不匹配。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">set_units<br>-capacitance cap_unit<br>-resistance res_unit<br>-time time_unit<br>-voltage voltage_unit<br>-current current_unit<br>-power power_unit<br></code></pre></td></tr></table></figure><h4id="current_instance指定当前设计或实例">current_instance（指定当前设计或实例）</h4><p>设计范围更改为current_design中的实例，但返回名称是相对于current_design的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">current_instance [instance]<br></code></pre></td></tr></table></figure><h4id="set_wire_load_model指定线负载模型">set_wire_load_model（指定线负载模型）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">set_wire_load_model<br>-name model_name<span class="hljs-comment">#指定库中的模型，如WIRE_LOAD_70×70</span><br>[-library lib_name]<span class="hljs-comment">#指定库名称</span><br>[-min][-max]<span class="hljs-comment">#指定模型运用的条件，一般不用</span><br>[object_list]<span class="hljs-comment">#一般不用，而用current_design指定范围</span><br></code></pre></td></tr></table></figure><h4 id="set_max_area指定面积约束">set_max_area（指定面积约束）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">set_max_area area_value<br>set_max_area 0  <span class="hljs-comment"># 让综合后的面积越小越好</span><br></code></pre></td></tr></table></figure><h4 id="set_voltage指定电压约束">set_voltage（指定电压约束）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">set_voltage<br>[-min min_case_value]<span class="hljs-comment">#指定最小延迟对应的最大电压</span><br>[-object_list list_of_power_nets]<span class="hljs-comment">#指定电压下的电源网表</span><br>max_case_voltage<span class="hljs-comment">#指定最大延迟对应的最小电压</span><br></code></pre></td></tr></table></figure><h4id="creat_voltage_area指定电压岛">creat_voltage_area（指定电压岛）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">creat_voltage_area<br>-name name<span class="hljs-comment">#电压岛名称</span><br>[-coordinates coordinate_list]<span class="hljs-comment">#指定保持电压岛的矩形区域</span><br>[-guard_band_x <span class="hljs-built_in">float</span>]<span class="hljs-comment">#沿x轴距离，电压岛间缓冲区，不放单元</span><br>[-guard_band_y <span class="hljs-built_in">float</span>]<span class="hljs-comment">#沿y轴距离，电压岛间缓冲区，不放单元</span><br>cell_list<span class="hljs-comment">#电压岛中单元列表</span><br></code></pre></td></tr></table></figure><h4id="set_level_shifter_strategythreshold指定电平移位器">set_level_shifter_strategy/threshold（指定电平移位器）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#指定何时插入电平移位器的策略</span><br>set_level_shifter_strategy [-rule rule_type]<br><span class="hljs-comment">#指定插入电平移位器的最小电压差阈值</span><br>set_level_shifter_threshold [-voltage <span class="hljs-built_in">float</span>][-percent <span class="hljs-built_in">float</span>]<br></code></pre></td></tr></table></figure><h4id="set_max_dynamicleakage_power指定动态静态功耗">set_max_dynamic/leakage_power（指定动态、静态功耗）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#指定动态功耗最大值</span><br>set_max_dynamic_power power [unit]<br><br><span class="hljs-comment">#指定泄露功耗最大值</span><br>set_max_leakage_power power [unit]<br></code></pre></td></tr></table></figure><h3 id="编译">编译</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">compile<br>compile_utra<br>compile -exact_map //综合优化<br></code></pre></td></tr></table></figure><h3 id="输出信息">输出信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">report_clock<br>report_timing &gt; ./timing.rpt<br>report_area &gt; ./area.rpt<br>report_constraint -all_violators &gt; ./constraint.rpt<br>report_qor<br>write_sdc xxx.sdc <span class="hljs-comment">#输出约束条件</span><br>write_sdf xxx.sdf <span class="hljs-comment">#输出时延信息</span><br>write_file -format verilog -output xxx_netlist.v <span class="hljs-comment">#输出网表文件</span><br>write -format verilog -hierarchy -output xxx_netlist.v<br>write_parasitics <span class="hljs-comment">#save parasitics in SPEF format or as a Tcl that contains set_load and set_resistance commands.</span><br></code></pre></td></tr></table></figure><p>​</p><p>SYNTAX status write_parasitics [-output file_name] [-format reduced][-min] [-ratio ratio_number] [-script]</p><p>Data Types file_name string ratio_number float</p><p>ARGUMENTS -output file_name Specifies the name of the output file towhich parasitics for the current design are written.</p><pre><code>          If you do not specify this option, the parasitics are written to          a file named design_name.format_name, where design_name  is  the          name of the current design.   -format reduced          Specifies to write the parasitics in reduced SPEF format.   -min   Writes  parasitics  for  the  minimum  operating  condition.  By          default, the parasitics are written for  the  maximum  operating          conditions.   -ratio ratio_number          Specifies  the ratio used when writing the pie model description          for every driver in the net.  The ratio specified by  this  com-          mand  must  be  in the range 0.0 - 1.0.  By default, the nets in          reduced format are generated with a ratio  equal  to  0.5.   The          capacitor  closest  to the driver is 0.5 (the ratio value) times          the total net capacitance in the pie model description.   -script          Writes out set_load and set_resistance commands  instead  of  an          SPEF file.</code></pre><p>DESCRIPTION This command writes parasitics for the current design toa disk file.</p><p>Multicorner-Multimode Support This command uses information from allactive scenarios.</p><p>在面积报告里面没有线网所消耗的面积，这是因为我们之前没有规定综合使用的线网模型，如果我们设置了wire_load那么最后的area报告里面也会有布线所花的面积。</p><h3 id="demo">demo</h3><p>link是Design Compiler ”resolve”设计中例化模块的过程。DesignCompiler通过变量“link_library”指定例化模块库的位置，和target_library一样，默认为your_library.db。建议显式地使用link命令，否则工具可能带着“unresolvedreferences”进行综合，产生没有意义的结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#############################读入并分析设计##################################</span><br>remove_design -all <span class="hljs-comment">#首先清理系统</span><br><br><span class="hljs-comment">#读入并分析Verilog文件，autoread会自动按照文件的依赖顺序逐个分析源文件，</span><br><span class="hljs-comment">#如果有错误analyze命令会报错，如果没有错误会生成中间文件。</span><br>analyze -format verilog  ../src/TMO_System.v -autoread &gt; ./log/analyze.rpt<br><br><span class="hljs-comment">#将analyze生成的中间文件转为technology-independent design (GTECH)</span><br><span class="hljs-comment">#要将顶层转化为最后的网表，就要将所有的模块都组合起来，这一过程即是Link</span><br><span class="hljs-comment">#elaborate命令会自动执行Link命令，如果再次执行Link命令，我看可以看到关于Link的报告</span><br>elaborate TMO_System<br><span class="hljs-built_in">link</span> &gt; ./log/link.rpt<br>current_design TMO_System <span class="hljs-comment">#确认在DC内存中，正在处理的是顶层TMO_System</span><br><br><span class="hljs-comment"># 如果设计中多次使用了同一个instance，那么在DC的内存中多个instance均指向一个模块</span><br><span class="hljs-comment"># 但是在电路中他们应该是多个独立的实体，uniquify命令的目的就是为这些instance都创造一个</span><br><span class="hljs-comment"># 新的模块使其指向它，这样，即使在Verilog源文件中，多个instance源自同一个module，</span><br><span class="hljs-comment"># 在DC中他们也会指向不同的module（内容一样，名字不一样）</span><br>uniquify &gt; ./log/uniquify.rpt<br>check_design &gt; ./log/check_RTL.rpt <span class="hljs-comment">#检查设计是否一致，要消除report中所有error</span><br>replace_synthetic &gt; ./log/replace_synthetic.rpt <span class="hljs-comment">#将设计中的运算符替换为DesignWare中的IP</span><br><br><span class="hljs-comment">#############################环境约束###################################</span><br>set_operating_conditions -min_library wcells -min BEST -max_library wcells -max WORST<br><span class="hljs-built_in">set</span> auto_wire_load_selection <span class="hljs-literal">true</span> <br>set_wire_load_mode enclosed<br><span class="hljs-comment"># 从库中找一个标准单元来驱动所有输入</span><br>set_driving_cell -lib_cell winv_1 -pin op [all_inputs]<br>set_load 3 [all_outputs]<br><br><span class="hljs-comment">#############################优化约束##################################</span><br><span class="hljs-comment">#### 时钟约束 ####</span><br>create_clock -name <span class="hljs-string">&quot;clock&quot;</span> -period 10 -waveform &#123;0 5&#125; [get_ports clk]<br>set_clock_latency            1    [get_clocks clock]<br>set_clock_transition         0.3  [get_clocks clock]<br>set_clock_uncertainty -setup 0.8  [get_clocks clock]<br>set_clock_uncertainty -hold  0.4  [get_clocks clock]<br>set_drive 0  [get_ports clock] <span class="hljs-comment">#默认时钟驱动能力无穷大</span><br><span class="hljs-comment">#为了防止在时钟路径上插入Buffer而恶化时序，所以对时钟网络设置Dont_touch_network属性</span><br><span class="hljs-built_in">set</span> dont_touch_network [ list clock ]<br><span class="hljs-built_in">set</span> all_inputs_in_domain [get_ports [list Pi_Value hsync vsync configure_addr configure_value write <span class="hljs-built_in">read</span>]]<br><span class="hljs-built_in">set</span> all_outputs_in_domain [get_ports [list configured_value toned_pixel TValid]]<br>set_input_delay  -max       2.5 -clock <span class="hljs-string">&quot;clock&quot;</span> <span class="hljs-variable">$all_inputs_in_domain</span>    <br>set_input_delay  -min       0.4 -clock <span class="hljs-string">&quot;clock&quot;</span> <span class="hljs-variable">$all_inputs_in_domain</span><br>set_output_delay -max       2.5 -clock <span class="hljs-string">&quot;clock&quot;</span> <span class="hljs-variable">$all_outputs_in_domain</span><br>set_output_delay -min       0.4 -clock <span class="hljs-string">&quot;clock&quot;</span> <span class="hljs-variable">$all_outputs_in_domain</span><br><br><br><span class="hljs-comment">#############################DRC约束##################################</span><br><span class="hljs-comment">#0.35先使用库中的默认值</span><br><span class="hljs-comment">#set_max_transition</span><br><span class="hljs-comment">#set_max_capacitance</span><br><span class="hljs-comment">#set_max_fanout</span><br><span class="hljs-comment">#set_max_delay</span><br><span class="hljs-comment">#set_min_delay</span><br><br><span class="hljs-comment">#############################生成Netlist###############################</span><br><span class="hljs-comment">#### One Pass Compilation ####</span><br>current_design TMO_System<br>compile_ultra -timing_high_effort_script  &gt; ./log/compile_pass1.rpt<br>set_auto_disable_drc_nets  -clock  <span class="hljs-literal">true</span>  -constant  <span class="hljs-literal">true</span><br><span class="hljs-built_in">set</span>  bus_inference_descending_sort   <span class="hljs-literal">true</span><br><span class="hljs-built_in">set</span>  bus_inference_style     %s\[%d\]<br><span class="hljs-built_in">set</span>  bus_naming_style        %s\[%d\]<br><span class="hljs-built_in">set</span>  verilogout_no_tri <span class="hljs-literal">true</span><br><span class="hljs-built_in">set</span>  verilogout_show_unconnected_pins <span class="hljs-literal">true</span><br>set_fix_multiple_port_nets  -all -buffer_constants<br>remove_unconnected_ports [get_cells -hier &#123;*&#125;]<br><span class="hljs-built_in">set</span>  change_names_dont_change_bus_members   <span class="hljs-literal">true</span><br>change_names  -hier   -rules   verilog<br><span class="hljs-comment">#change_names  -hier   -rules   lab_vlog</span><br><br><span class="hljs-comment">#### Two Pass Compilation ####</span><br>current_design TMO_System <br>compile_ultra -incremental  &gt; ./log/compile_incr.rpt<br><span class="hljs-built_in">set</span>  bus_inference_descending_sort   <span class="hljs-literal">true</span><br><span class="hljs-built_in">set</span>  bus_inference_style     %s\[%d\]<br><span class="hljs-built_in">set</span>  bus_naming_style        %s\[%d\]<br><span class="hljs-built_in">set</span>  verilogout_no_tri <span class="hljs-literal">true</span><br><span class="hljs-built_in">set</span>  verilogout_show_unconnected_pins <span class="hljs-literal">true</span><br>set_fix_multiple_port_nets  -all -buffer_constants<br>remove_unconnected_ports [get_cells -hier &#123;*&#125;]<br><span class="hljs-built_in">set</span>  change_names_dont_change_bus_members   <span class="hljs-literal">true</span><br>change_names  -hier   -rules   verilog<br><span class="hljs-comment">#Check Netlist</span><br>check_design &gt; ./log/check_netlist.rpt<br>current_design TMO_System<br>write -f verilog -h -output ./netlist/TMO_System_syn.v<br>write -f ddc -h -output ./unmapped/TMO_System.ddc<br>write_sdc  ./unmapped/TMO_System.sdc  -version 1.4<br><br><span class="hljs-comment">#get reports</span><br>report_timing -to [all_outputs]  -max_paths 5000 -nworst 5000 &gt; ./log/timing_max_output.rpt<br>report_timing -to [all_registers -data_pins]    -max_paths 5000 -nworst 5000 &gt; ./log/timing_max_register.rpt       <br>report_timing -to [all_outputs]                 -max_paths 5000 -nworst 5000  -delay min \<br>                                                &gt; ./log/timing_min_output.rpt<br>report_timing -to [all_registers -data_pins]  -max_paths 5000 -nworst 5000  -delay min \<br>                                              &gt; ./log/timing_min_register.rpt<br>report_area   &gt; ./log/area.rpt<br>report_power  &gt; ./log/power.rpt<br></code></pre></td></tr></table></figure><h1 id="第二章vcs">第二章：VCS</h1><h1 id="第三章primetime">第三章：PrimeTime</h1><ul><li><strong>PrimeTime PX</strong> for estimating the powerconsumption</li></ul><h2 id="时序分析">3.1时序分析</h2><ul><li><p>动态时序分许：基于动态仿真的方法，既能够验证设计的功能，也能够验证设计的时序。</p></li><li><p>静态时序分许：通过提取整个电路的所有时序路径，检查建立时间和保持时间是否满足要求。分析执行速度快，不需要测试向量，适合进行大规模集成电路的验证，可节约大量时间。</p></li></ul><p>随着设计尺寸和复杂性的增加，动态仿真所需时间及工作量都难以承受，在设计流程中成为一个严重的瓶颈，促使时序分析技术从动态向静态迁移。并由此诞生了静态时序分析工具。</p><h2 id="pt命令">3.2PT命令</h2><p>PT的输入可以使db、Verilog、VHDL或EDIF格式的文件。</p><p>read_ db -netlist_ _only <design name> .db <figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs tcl">read_db -netlist_only &lt;design name&gt;.db  #db <span class="hljs-keyword">format</span><br>read_verilog &lt;design name&gt;.sv   #verilog <span class="hljs-keyword">format</span><br>read_vhdl &lt;design name&gt;.svhd    #vhdl <span class="hljs-keyword">format</span><br>read_edif &lt;design name&gt;.edf     #edif <span class="hljs-keyword">format</span><br><br><br>create_clock -period <span class="hljs-number">20</span> -waveform &#123;<span class="hljs-number">0</span> <span class="hljs-number">10</span>&#125; [<span class="hljs-keyword">list</span> CLK]  # 创建时钟<br>set_clock_latency <span class="hljs-number">2.5</span> [get_clocks CLK]<br>set_clock_transition <span class="hljs-number">0.2</span> [get_clocks CLK]<br><br><span class="hljs-comment">#插入时钟树之后布图工具通常接着要进行传播时钟，网表被带回PT进行STA</span><br><span class="hljs-comment">#时钟通过网表中的整个时钟树网络传播以确定时钟延迟。换言之，对通过时钟树中每个单元的延迟和单元间的互连线延迟都要加以考虑</span><br>set_propagated_clock [get_clocks CLK]<br>set_clock_uncertainty <span class="hljs-number">0.5</span> -from [get_clocks CLK1] -to [get_clocks CLK2]<br><br><span class="hljs-comment">#定义生成时钟与源时钟间的关系</span><br><span class="hljs-comment">#在布图后时序分析中，插入了时钟树并通过时钟树缓冲器传播时钟信号来计算时钟延迟。用户选择定义独立于时钟源的分频时钟（通过在分频逻辑子模块的输出引脚上定义时钟）。然而，这个方法迫使设计人员从时钟源到分频逻辑模块的时钟延迟手动添加从分频模块到设计的其余部分的时钟树延迟。通过下述命令建立分频时钟，则这两个时钟在布图前和布图后阶段都保持同步。</span><br>create_generated_clock -name &lt;divided <span class="hljs-keyword">clock</span> name&gt;<br> -<span class="hljs-keyword">source</span> &lt;primary <span class="hljs-keyword">clock</span> name&gt;<br>                       -divide_by &lt;value&gt;<br>                       &lt;pin name&gt;<br>                       <br><span class="hljs-comment"># PT允许对门控时钟指定建立/保持要求</span><br>set_clock_gating_check -setup &lt;value&gt;<br> -hold &lt;value&gt;<br>     &lt;object <span class="hljs-keyword">list</span>&gt;<br><br></code></pre></td></tr></table></figure></p><h2 id="primetime-px">3.3PrimeTime PX</h2><p>PT如果进行功耗分析需要额外的PTPX的licence，可以通过命令打开：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl">set_app_var power_enable_analysis true #默认为false<br></code></pre></td></tr></table></figure><p><strong>在EDA工具的安装目录底下有Lab教程和相关设计文件</strong></p><figure><img src="SynopsysEDA.assets/Power%20Analysis%20Flow.png"alt="Power Analysis Flow" /><figcaption aria-hidden="true">Power Analysis Flow</figcaption></figure><p><strong>Power = Leakage Power + Dynamic Power(internal power andswitching power)</strong></p><p><strong>动态功耗</strong>：电容充放电引起的功耗、短路功耗。</p><p><strong>静态功耗</strong>：主要为泄露电流和亚阈值电流引起的功耗。</p><p>PTPX支持两种功耗分析模式： <strong>averagedmode</strong>和<strong>time-based mode</strong>。</p><h3 id="命令">命令</h3><p><strong>Setting the Concurrent Multirail Power AnalysisMode</strong></p><p>PTPX supports concurrent power analysis on multiple power rails. Thisfeature improves the performance because, a single run of theupdate_power command analyzes multiplepower rails or power supply netsin the UPF mode, simultaneously. The concurrent multirail power analysisis supported in both averaged and time-based power analysis modes. Whenyou run the update_power command with this variable set to true, thetool simultaneously updates all the valid power rails in the design.</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">set</span> power_enable_multi_rail_analysis true<br></code></pre></td></tr></table></figure><p><strong>Estimating Clock Network Power Consumption</strong></p><p>You can estimate the additional power incurred by a clock networkprior to its insertion. You enable this feature with theestimate_clock_network_power command, which provides a more accurateanalysis of the total design power when clock network synthesis has notyet been performed. Before issuing the estimate_clock_network_powercommand, you must identify the design clocks.</p><p>If you want PrimeTime PX to consider clock-gating cells to be part ofthe clock network, set the</p><p>power_clock_network_include_clock_gating_network</p><p>variable to true. The default value of this variable is false.</p><p>The estimate_clock_network_power command is supported only in theaveraged power analysis mode.</p><h3 id="averaged-power-analysis"><strong>Averaged PowerAnalysis</strong></h3><p>For purely averaged power analysis, PrimeTime PX supports propagationof switching activity based on <strong>defaults</strong>,<strong>user-defined switching</strong>, or switching derived from an<strong>HDL simulation</strong> (either RTL or gate level).</p><p>（1）有波形文件：最理想的情况是能提供后仿产生的VCD/SAIF文件，通过<strong>read_vcd</strong>/<strong>read_saif</strong>将真实的翻转率反标到Net上，然后通过<strong>report_switching_activity</strong>检查反标率，最后<strong>report_power</strong>报功耗值。</p><p>（2）人为设置翻转率：根据以往项目的经验值，通过<strong>set_switching_activity/set_case_analysis</strong>来设置register，clockgate以及memory/blackbox的翻转率</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tcl">reset_switching_activity # 重置之前设置的翻转率<br><br><span class="hljs-comment"># 设置register翻转率</span><br>set_switching_activity [get_pins -of_object [all_registers]] -toggle_rate <span class="hljs-number">0.5</span> -static_probability <span class="hljs-number">0.5</span> -base_clock * <br><span class="hljs-comment"># 设置blockboxs上的翻转率</span><br>set_switching_activity -type black_boxes -toggle_rate <span class="hljs-number">0.1</span> -static_probability <span class="hljs-number">0.5</span> -base_clock * -hierarchy <br>set_switching_activity -toggle_rate <span class="hljs-number">0.5</span> -static_probability <span class="hljs-number">0.5</span> -base_clock * [remove_from_collection [all_inputs] [get_port -filter <span class="hljs-string">&quot;is_clock_used_as_clock == true&quot;</span>]] # 设置Input上的翻转率<br>set_switching_activity [get_pins -of_object [get_cells -hierarchical * -filter <span class="hljs-string">&quot;ref_name =~ *ICG*&quot;</span>]] -toggle_rate <span class="hljs-number">0.5</span> -static_probability <span class="hljs-number">0.5</span> -base_clock * （设置<span class="hljs-keyword">clock</span> gate上的翻转率）<br>set_case_analysis <span class="hljs-number">1</span> [get_ports *reset*] # 使reset信号不翻转，准静态信号<br>set_switching_activity -toggle_rate <span class="hljs-number">0</span> -static_probability <span class="hljs-number">1</span> -base_clock * [get_port *reset*]<br></code></pre></td></tr></table></figure><p>（3）<strong>Vector-Free Power Analysis：</strong>使用默认翻转率</p><p>The default value of the static probability and toggle rate are 0.5and 0.1. If required, you can change thedefault toggle rate. This usagemodel is useful for quick power estimation.</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tcl">set_app_var power_default_toggle_rate <span class="hljs-number">0.5</span> # 默认值为 <span class="hljs-number">0.1</span><br>set_app_var power_default_static_probability <span class="hljs-number">0.5</span> # 默认值为<span class="hljs-number">0.5</span><br>set_app_var power_default_toggle_rate_reference_clock fastest # 默认值related<br></code></pre></td></tr></table></figure><p>The following commands and variables affect the default toggleratesused by the tool:</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tcl">create_clock<br><span class="hljs-keyword">set</span> power_default_toggle_rate<br><span class="hljs-keyword">set</span> power_default_static_probability<br><span class="hljs-keyword">set</span> power_default_toggle_rate_reference_clock<br>set_switching_activity<br>reset_switching_activity<br>set_case_analysis<br></code></pre></td></tr></table></figure><p>在PT中report_switching_activity会报出所有Nets的switchingactivity来源的统计数据：</p><p><strong>From Activity File：</strong> The switching activity value isfrom a SAIF or VCD file，在read_vcd或者read_saif时要注意通过<strong>-stripe_path</strong>选项指定合适的hierarchical层次，否则activity反标不上。</p><p><strong>From SSA： </strong>The switching activity value set by usingthe <strong>set_switching_activity</strong> command.</p><p><strong>From SCA ：</strong>The switching activity set by using the<strong>set_case_analysis</strong> command.</p><p><strong>From clock ：</strong>The switching activity set by using thecreate_clock command.</p><p><strong>Default：</strong>对于用户没有指定的翻转率的Net，使用默认的翻转率</p><p><strong>Propagated：</strong>The switching activity from<strong>propagation engine</strong></p><p><strong>Implied：</strong>Switching activity from simple automaticpropagation of activity <strong>through buffers andinverters</strong></p><p><strong>NotAnnotated：</strong>没有反标翻转率的Net，需要特别注意，一般要求在update_power或者report_power之后，这部分占比应该很低甚至为0，如果有大量没有翻转的Net，会影响report_power的准确率，可以通过以下命令打印出来分析：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tcl">report_switching_activity -list_not_annotated    <br>get_switching_activity ...<br></code></pre></td></tr></table></figure><h3 id="averaged-power-analysis-script">Averaged Power AnalysisScript</h3><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-comment"># Set the Power Analysis Mode</span><br><span class="hljs-keyword">set</span> power_enable_analysis TRUE<br><span class="hljs-keyword">set</span> power_analysis_mode averaged<br><br><span class="hljs-comment"># Read and link the Gate Level Netlist</span><br><span class="hljs-keyword">set</span> search_path <span class="hljs-string">&quot;../src/hdl/gate ../src/lib/snps . &quot;</span><br><span class="hljs-keyword">set</span> link_library <span class="hljs-string">&quot; * core_typ.db&quot;</span><br>read_verilog mac.vg<br>current_design mac<br>link<br><br><span class="hljs-comment"># Read SDC and set transition time or annotate parasitics</span><br>read_sdc ../src/hdl/gate/mac.sdc<br>set_disable_timing [get_lib_pins ssc_core_typ/*/G]<br>read_parasitics ../src/annotate/mac.spef.gz<br><br><span class="hljs-comment"># check, update, or report the timing</span><br>check_timing<br>update_timing<br>report_timing<br><br><span class="hljs-comment"># read switching activity file</span><br>read_vcd -strip_path tb/macinst ../sim/vcd.dump.gz<br>report_switching_activity -list_not_annotated<br><br><span class="hljs-comment"># check or update or report power</span><br>check_power<br>update_power<br>report_power -hierarchy<br></code></pre></td></tr></table></figure><h3 id="time-based-power-analysis"><strong>Time-based poweranalysis</strong></h3><p>For extremely accurate analysis of power with respect to time,PrimeTime PX supports analysis <strong>based on the RTL or gate-levelsimulation activity over time</strong>.</p><p>PrimeTime PX uses an event-driven algorithm to calculate thepowerconsumption for each event. Detailed time-based power waveforms aregeneratedto provide both average and peak power results. The tool canproduce an average and peak power report.</p><p>通过以下选项开启，在该模式下，需要提供VCD（<strong>注：SAIF文件不行</strong>）</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">set</span> power_enable_analysis TRUE<br><span class="hljs-keyword">set</span> power_analysis_mode time_based<br>set_app_var power_analysis_mode time_based # 默认为averaged<br></code></pre></td></tr></table></figure><p>timebased模式下工具会分析峰值功耗，生成功耗波形等图，执行完功耗分析之后，会在当前工作目录底下保存.fsdb波形文件</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tcl">set_power_analysis_options -waveform_format fsdb -waveform_output [name]<br>nWave &amp;       # 使用nWave波形查看器查看波形文件<br></code></pre></td></tr></table></figure><h3 id="time-based-power-analysis-script">Time-based power analysisScript</h3><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-comment"># Set the Power Analysis Mode</span><br><span class="hljs-keyword">set</span> power_enable_analysis TRUE<br><span class="hljs-keyword">set</span> power_analysis_mode time_based<br><span class="hljs-comment">#set_power_analysis_options # 为功耗分析设置选项</span><br><span class="hljs-comment">#set_app_var power_limit_extrapolation_range true # 超过功耗查找表时，可以外推，默认是false</span><br><span class="hljs-comment">#set_app_var power_use_ccsp_pin_capacitance true；# 考虑弥勒效应，默认是false</span><br><br><span class="hljs-comment"># link design</span><br><span class="hljs-keyword">set</span> search_path <span class="hljs-string">&quot;../src/hdl/gate ../src/lib/snps . &quot;</span><br><span class="hljs-keyword">set</span> link_library <span class="hljs-string">&quot; *core_typ.db&quot;</span><br>read_verilog mac.vg<br>current_design mac<br>link<br><br><span class="hljs-comment"># set transition time/annotate parasitics</span><br>read_sdc ../src//hdl/gate/mac.sdc<br>set_disable_timing [get_lib_pins ssc_core_typ/*/G]<br>read_parasitics ../src/annotate/mac.spef.gz<br><br><span class="hljs-comment"># analyze timing</span><br>check_timing<br>update_timing # 更新时序关系<br>report_timing<br><br><span class="hljs-comment"># read switching activityfile</span><br>read_vcd ../sim/vcd.dump.gz \<br>  -strip_path tb/macinst<br><span class="hljs-comment"># read_vpd</span><br><span class="hljs-comment"># read_fsdb</span><br><span class="hljs-comment"># read_saif 用在平均功耗分析上</span><br><span class="hljs-comment"># set_switching_activity </span><br><span class="hljs-comment"># set_case_analysis </span><br><br><span class="hljs-comment"># analyze power</span><br>check_power # 检查会影响功耗准确性的错误，默认的检查内容由power_check_defaults定义<br>set_power_analysis_options \<br>  -waveform_format out \<br>  -waveform_output vcd<br>update_power # 进行功耗分析<br>report_power<br></code></pre></td></tr></table></figure><h3 id="required-files-descriptions"><strong>Required Filesdescriptions</strong></h3><p><strong>逻辑库</strong>：单元库，包含所有单元的时序和功耗特性，db文件；</p><p><strong>spef文件</strong>：寄生参数文件；</p><ul><li><p><strong>Gate-LevelNetlist：</strong>verilog、vhdl，db、ddc、Milkyway格式的网表均可</p></li><li><p><strong>Technology Library</strong></p></li></ul><p>PTPX supports either CCS (composite current source) or NLPM(nonlinear power model).</p><p>You use the power_model_preference nlpm | ccs variable to specifyyour power model preference when the library contains both NLPM and CCSdata. The default is ccs.</p><ul><li><strong>SDC File</strong></li></ul><p>The SDC file contains the <strong>design constraints</strong>. Thedriver cellinformation is used to calculate the transition time on theprimary inputs.</p><ul><li><p><strong>Parasitic File</strong></p></li><li><p><strong>SwitchingActivity：</strong>vcd、vpd、fsdb、saif文件，或者命令设置</p></li></ul><p>In the averaged power analysis, you use either SAIF or VCD fileformats to read the switching activity. If you do not specify switchingactivity information, the tool assumes certain default values for theswitching activity.</p><p>In time-based power analysis, you use VCD file formats to read theswitching activity.</p><p>When you read a SAIF file or an RTL VCD file for power estimation,use the set_rtl_to_gate_name command to map the RTL and gate-levelobject names. This command is especially necessary if you have performedonly the RTL simulation for generating the backward SAIF file. Becausethe RTL object names can change after synthesis, the read_saif orread_vcd command is not able to map the names present in the RTL SAIF orVCD fileto the gate-level objects, which can result in inaccurateresults. You can avoid this by using the set_rtl_to_gate_namecommand.</p><h2 id="vcdsaiffsdb的区别">3.4VCD，SAIF，FSDB的区别</h2><h4 id="vcdvaluevariable-change-dump">VCD：Value/Variable ChangeDump</h4><ul><li>It is an event-based format that contains every value change for thesignals in the design and the time at which they occurred.</li><li>VCD is supported in both the averaged and time-based analysismodes，是国际标准格式</li><li>Gate-Level VCD和RTL-Level VCD都可以，但是使用RTL-LevelVCD时，需要进行name mapping (set_rtl_to_gate_name)。</li><li>VCD文件示例：http://en.wikipedia.org/wiki/Value_change_dump</li></ul><h4 id="saifswitching-activity-interface-format">SAIF：SwitchingActivity Interface Format</h4><ul><li>It captures signal transitions and the time spent at each logiclevel. The SAIF file contains the toggle counts and static probabilitiesfor the nets in the design.</li><li>SAIF is supported only in the averaged power analysis mode.</li><li>有些工具，比如ICC/ICC2，只支持SAIF文件，需要将VCD转换成SAIF文件，在PT安装目录下有一个utility：</li><li>vcd2saif -input vcd_file -output saif_file ...</li></ul><h4 id="fsdbfast-signal-databbase">FSDB：Fast Signal DataBbase</h4><ul><li>类似于VCD的波形文件，去除了VCD中的冗余信息，数据量小很多，提高了仿真的速度，Synopsys的仿真工具支持较多。</li></ul><h1 id="第四章icc-compiler">第四章：ICC Compiler</h1>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Design Compiler&lt;/strong&gt; for the synthesis,&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;ICC Compiler&lt;/strong&gt; for the layout&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;PrimeTime&lt;/strong&gt; for static timing analysis&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新思安装指南：&lt;a
href=&quot;https://link.zhihu.com/?target=http%3A//www.synopsys.com/install&quot;&gt;http://www.synopsys.com/install&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;新思license快速入门指南： &lt;a
href=&quot;https://link.zhihu.com/?target=http%3A//www.synopsys.com/licensing&quot;&gt;http://www.synopsys.com/licensing&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="https://zmailee.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="EDA" scheme="https://zmailee.github.io/tags/EDA/"/>
    
    <category term="数字IC" scheme="https://zmailee.github.io/tags/%E6%95%B0%E5%AD%97IC/"/>
    
  </entry>
  
  <entry>
    <title>IC后端</title>
    <link href="https://zmailee.github.io/2022/11/09/IC%E5%90%8E%E7%AB%AF/"/>
    <id>https://zmailee.github.io/2022/11/09/IC%E5%90%8E%E7%AB%AF/</id>
    <published>2022-11-09T03:35:24.612Z</published>
    <updated>2022-11-09T03:55:44.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章标准单元库">第一章：标准单元库</h1><h2 id="hvtsvtlvt">HVT/SVT/LVT</h2><p>High Vt、Standard Vt（也有称为Regular Vt，即RVT)、LowVt。Vt阈值电压越低，因为饱和电流变小，所以速度性能越高；但是因为漏电流会变大，因此功耗会变差。</p><span id="more"></span><h2 id="pvt">PVT</h2><p>Process、Voltage、Temperature</p><h2 id="multi-channel-library">multi-channel library</h2><p>对应不同的gate-length，即沟道长度。例如，UMC28nm的SVTmin 相对SVTmax，性能增加20%，静态功耗增加80%。</p><h2 id="t9t12t">7T/9T/12T</h2><p>T，代表track，是单元库的版图规则，作为一个计量单位。</p><p>7T/9T/12T分别对应ultra-high-density（for lowest power in SOCblocks）、high-density（for highest density in GPUblocks）、high-speed（for highest performance in CPU blocks）。</p><p>标准单元库的单元高度，基本都是固定的，方便版图的布局；高度，通常以track作为计量单位pitch=minSpacing+minWidth。</p><p>grid是单元库里，与工艺制造精度相关的名称。一般pin都放置在grid上，工艺在版图上的最小精度。</p><figure><img src="IC后端.assets/SouthEast.png" alt="这里写图片描述" /><figcaption aria-hidden="true">这里写图片描述</figcaption></figure><h2 id="推荐的单元库选择方法">推荐的单元库选择方法</h2><p><img src="IC后端.assets/SouthEast-16679659616183.png"alt="img" /><strong>HLP</strong>，high performance low power；<strong>HPC</strong>，high performace compact。28nmHLP的core电压，是1.05V；HPC的core电压，则是0.9V。</p><figure><img src="IC后端.assets/SouthEast-16679660832146.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;第一章标准单元库&quot;&gt;第一章：标准单元库&lt;/h1&gt;
&lt;h2 id=&quot;hvtsvtlvt&quot;&gt;HVT/SVT/LVT&lt;/h2&gt;
&lt;p&gt;High Vt、Standard Vt（也有称为Regular Vt，即RVT)、Low
Vt。Vt阈值电压越低，因为饱和电流变小，所以速度性能越高；但是因为漏电流会变大，因此功耗会变差。&lt;/p&gt;</summary>
    
    
    
    <category term="基础课程" scheme="https://zmailee.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="人工智能" scheme="https://zmailee.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="计算机体系结构" scheme="https://zmailee.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习笔记</title>
    <link href="https://zmailee.github.io/2022/11/02/linux/"/>
    <id>https://zmailee.github.io/2022/11/02/linux/</id>
    <published>2022-11-02T07:11:43.295Z</published>
    <updated>2022-11-04T05:27:00.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="添加环境变量"><strong>1.添加环境变量</strong></h2><p>https://www.cnblogs.com/youyoui/p/10680329.html</p><p>1、Linux的环境变量是保存在变量PATH中</p><ul><li><strong>export</strong>命令显示当前系统定义的所有环境变量</li><li><strong>echo $PATH</strong>命令输出当前的PATH环境变量的值</li></ul><p>2、Linux环境变量值之间是通过冒号分隔的( : )</p><p><strong>临时添加环境变量PATH：</strong>可通过export命令，如将/usr/local/nginx/sbin/目录临时添加到环境变量中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=/usr/local/nginx/sbin/:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><span id="more"></span><h2 id="常用命令">2.常用命令</h2><h3 id="开启全部权限解锁文件">开启全部权限：解锁文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chmod</span> -R 777 xx/xx/xx<br></code></pre></td></tr></table></figure><h3 id="tar命令">tar命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">解压命令:tar -xzvf xxx.tar.gz <br>压缩命令:tar zcvf 文件名.tar.gz 待压缩的文件名<br>//-x 表示 extract， 提取，因为是解压所以使用。<br>//-c 表示压缩，compress<br>//-z 表示先使用 gzip支持压缩或解压缩。其他的压缩或解压缩方式，比如-j表示bzip2的方式<br>//-v 表示 verbose，在压缩或解压缩过程中显示正在处理的文件名<br>//-f 表示 file，指定要处理的 tar 包<br>//-C 可以指定输出目录,默认是解压到当前目录<br><br></code></pre></td></tr></table></figure><h2 id="git">3.git</h2><p>When you want to commit the change, type</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit --allow-empty -am <span class="hljs-string">&quot;提交备注&quot;</span><br></code></pre></td></tr></table></figure><p>The <code>--allow-empty</code> option is necessary, because usuallythe change is already committed by development tracing system. Withoutthis option, <code>git</code> will reject no-change commits</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 删除本地分支<br>git branch -d localBranchName<br><br>// 删除远程分支<br>git push origin --delete remoteBranchName<br></code></pre></td></tr></table></figure><h2 id="make">4.make</h2><p>通过<code>lscpu</code>命令来查询有多少个CPU.在<code>make</code>时候添加<code>-j?</code>的参数,其中<code>?</code>为你查询到的CPU数量.</p><p>为了查看编译加速的效果, 在编译的命令前面添加<code>time</code>命令,它将会对紧跟在其后的命令的执行时间进行统计。可以通过<code>make clean</code>清除所有的编译结果,然后重新编译并统计时间,</p><h2 id="gdb">5.GDB</h2><h3 id="常用命令-1">常用命令</h3><blockquote><ul><li>start #开始调试,停在第一行代码处,(gdb)start</li><li>finish #执行到函数retun返回</li><li>bt（backtrace） #列出调用栈</li><li>info locals #列出当前函数的局部变量</li><li>l #list的缩写查看源代码,(gdb) l [number/function]</li><li>watch var_name #追踪变量</li><li>b <lines> #b: Breakpoint的简写，<strong>设置断点</strong>。(gdb) b10</li><li>b <func> #b: Breakpoint的简写，设置断点。(gdb) b main</li><li>b filename:[line/function]#b:在文件filename的某行或某个函数处设置断点</li><li>i breakpoints #i:info 的简写。(gdb)i breakpoints</li><li>d [bpNO] #d: Deletebreakpoint，删除指定编号的某个断点，或删除所有断点。(gdb)d 1</li><li>s #s:step执行一行源程序代码，如果此行代码中有函数调用，<strong>则进入该函数</strong>；(gdb)s</li><li>n #n:next执行一行源程序代码，此行<strong>代码中的函数调用也一并执行</strong>。(gdb)n</li><li>r#run，运行被调试程序。如果没有下断点，则执行完；如果有断点，则程序暂停在第一个断点处。</li><li>c#continue的简写，继续执行被调试程序，直至下一个断点或程序结束。</li><li>p [var]#Print的简写，<strong>显示指定变量</strong>（临时变量或全局变量 例如 inta）<strong>的值</strong>。(gdb) p a</li><li>display [var] #display，设置想要跟踪的变量(例如 int a)。(gdb)display a</li><li>undisplay [varnum]#undisplay取消对变量的跟踪，被跟踪变量用整型数标识。(gdb) undisplay1</li><li>set args #可指定运行时参数。(gdb)set args 10 20</li><li>show args #查看运行时参数。</li><li>q #Quit的简写，退出GDB调试环境。(gdb) q</li><li>help [cmd]#GDB帮助命令。如果指定“命令名称”参数，则显示该命令的详细说明；如果没有指定参数，则分类显示所有GDB命令(gdb)help</li><li>回车 #重复前面的命令，(gdb)回车</li></ul></blockquote><hr /><h3 id="man命令">man命令</h3><table><colgroup><col style="width: 4%" /><col style="width: 54%" /><col style="width: 42%" /></colgroup><thead><tr class="header"><th>编号</th><th>说明</th><th>解释</th></tr></thead><tbody><tr class="odd"><td>1</td><td>Executable programs or shell commands</td><td><strong>标准Linux命令</strong></td></tr><tr class="even"><td>2</td><td>System calls(functions provided by the kernel)</td><td><strong>系统调用（内核）</strong></td></tr><tr class="odd"><td>3</td><td>Library functions(functions within program 1 ibraries)</td><td><strong>库函数</strong></td></tr><tr class="even"><td>4</td><td>Special devices(usually found in /dev</td><td><strong>设备说明</strong>（通常在/dev下可以找到）</td></tr><tr class="odd"><td>5</td><td>File formats and conventions eg /etc/ passwd</td><td><strong>文件格式</strong></td></tr><tr class="even"><td>6</td><td>Games</td><td>游戏娱乐等</td></tr><tr class="odd"><td>7</td><td>Miscellaneous</td><td>杂乱项</td></tr><tr class="even"><td>8</td><td>System administration commands</td><td><strong>系统管理员命令</strong>（通常针对<strong>root</strong>用户）</td></tr><tr class="odd"><td>9</td><td>Kernel routines</td><td>常规<strong>内核</strong>文件</td></tr></tbody></table><p>编号 说明 解释 1 Executable programs or shell commands 标准Linux命令2 System calls 系统调用（内核） 3 Library functions 库函数 4 Specialdevices 设备说明（通常在/dev下可以找到） 5 File formats 文件格式 6 Games游戏娱乐等 7 Miscellaneous 杂乱项 8 System administration commands系统管理员命令（通常针对root用户） 9 Kernel routines 常规内核文件</p><h3 id="list命令">list命令</h3><blockquote><p>list，显示当前行后面的源程序。</p><p>list - ，显示当前行前面的源程序</p><p>list <linenum> ，显示程序第linenum行周围的源程序</p><p>list <function> ，显示函数名为function的函数的源程序</p></blockquote><h3 id="break命令">break命令</h3><ul><li><p>break <function>在进入指定函数时停住</p></li><li><p>break <linenum>在指定行号停住</p></li><li><p>break +offset / break-offset在当前行号的前面或后面的offset行停住</p></li><li><p>break filename:linenum在源文件filename的linenum行处停住</p></li><li><p>breakfilename:function在源文件filename的function函数的入口处停住</p></li><li><p>break *address在程序运行的内存地址处停住</p></li><li><p>break表示在下一条指令处停住</p></li><li><p>break ... if <condition>“...”可以是上述的break <linenum>、break+offset / break –offset中的参数，在循环体中，可以设置break ifi=100，表示当i为100时停住程序</p></li><li><p>查看断点时，可使用info命令，如info breakpoints n、info breakn（n表示断点号）</p></li></ul><h3 id="单步命令">单步命令</h3><p>next(n)的单步不会进入函数的内部，</p><p>step(s)命令则在单步执行一个函数时，会进入其内部</p><ul><li>step <count></li></ul><p>单步跟踪，如果有函数调用，则进入该函数（进入函数的前提是，此函数被编译有debug信息）。step后面不加count表示一条条地执行，加表示执行后面的count条指令，然后再停住。</p><ul><li>next <count></li></ul><p>单步跟踪，如果有函数调用，它不会进入该函数。同样地，next后面不加count表示一条条地执行，加表示执行后面的count条指令，然后再停住。</p><ul><li>set step-mode</li></ul><p>set step-modeon用于打开step-mode模式，这样，在进行单步跟踪时，程序不会因为没有debug信息而不停住，这个参数的设置可便于查看机器码。setstep-mod off用于关闭step-mode模式。</p><ul><li>finish</li></ul><p>运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。</p><ul><li>until （缩写u）</li></ul><p>一直在循环体内执行单步，退不出来是一件令人烦恼的事情，until命令可以运行程序直到退出循环体。</p><ul><li>stepi（缩写si）和nexti（缩写ni）</li></ul><p>stepi和nexti用于单步跟踪一条机器指令，一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步执行机器指令。另外，运行“display/i$pc”命令后，单步跟踪会在打出程序代码的同时打出机器指令，即汇编代码。</p><h3 id="continue命令">continue命令</h3><p>当程序被停住后，可以使用continue命令（缩写c，fg命令同continue命令）恢复程序的运行直到程序结束，或到达下一个断点，命令格式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">continue</span> [ignore-count]<br>c [ignore-count]<br>fg [ignore-count]<br></code></pre></td></tr></table></figure><p>ignore-count表示忽略其后多少次断点。假设我们设置了函数断点add()，并watchi，则在continue过程中，每次遇到add()函数或i发生变化，程序就会停住，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) <span class="hljs-keyword">continue</span><br>Continuing.<br>Hardware watchpoint <span class="hljs-number">3</span>: i<br><br>Old value = <span class="hljs-number">2</span><br>New value = <span class="hljs-number">3</span><br><span class="hljs-number">0x0804838d</span> in <span class="hljs-built_in">main</span> () at gdb_example.c:<span class="hljs-number">23</span><br><span class="hljs-number">23</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>(gdb) <span class="hljs-keyword">continue</span><br>Continuing.<br><br>Breakpoint <span class="hljs-number">1</span>, <span class="hljs-built_in">main</span> () at gdb_example.c:<span class="hljs-number">25</span><br><span class="hljs-number">25</span>          sum[i] = <span class="hljs-built_in">add</span>(array1[i], array2[i]);<br>(gdb) <span class="hljs-keyword">continue</span><br>Continuing.<br>Hardware watchpoint <span class="hljs-number">3</span>: i<br><br>Old value = <span class="hljs-number">3</span><br>New value = <span class="hljs-number">4</span><br><span class="hljs-number">0x0804838d</span> in <span class="hljs-built_in">main</span> () at gdb_example.c:<span class="hljs-number">23</span><br><span class="hljs-number">23</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br></code></pre></td></tr></table></figure><h3 id="print命令">print命令</h3><p>在调试程序时，当程序被停住时，可以使用print命令（缩写为p），或是同义命令inspect来查看当前程序的运行数据。print命令的格式是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">print &lt;expr&gt;<br>print /&lt;f&gt; &lt;expr&gt;<br></code></pre></td></tr></table></figure><p><expr>是<ahref="https://so.csdn.net/so/search?q=表达式&amp;spm=1001.2101.3001.7020">表达式</a>，是被调试的程序中的表达式，<f>是输出的格式，比如，如果要把表达式按16进制的格式输出，那么就是/x。在表达式中，有几种GDB所支持的操作符，它们可以用在任何一种语言中，“@”是一个和数组有关的操作符，“::”指定一个在文件或是函数中的变量，“{<type>}<addr>”表示一个指向内存地址<addr>的类型为type的一个对象。</p><p>下面演示了查看sum[]数组的值的过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) print sum<br>$<span class="hljs-number">2</span> = &#123;<span class="hljs-number">133</span>, <span class="hljs-number">155</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;<br>(gdb) next<br><br>Breakpoint <span class="hljs-number">1</span>, <span class="hljs-built_in">main</span> () at gdb_example.c:<span class="hljs-number">25</span><br><span class="hljs-number">25</span>          sum[i] = <span class="hljs-built_in">add</span>(array1[i], array2[i]);<br>(gdb) next<br><span class="hljs-number">23</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>(gdb) print sum<br>$<span class="hljs-number">3</span> = &#123;<span class="hljs-number">133</span>, <span class="hljs-number">155</span>, <span class="hljs-number">143</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;<br></code></pre></td></tr></table></figure><p>当需要查看一段连续内存空间的值的时间，可以使用GDB的“@”操作符，“@”的左边是第一个内存地址，“@”的右边则是想查看内存的长度。例如如下动态申请的内存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prettyprint">int *array = (int *) malloc (len * sizeof (int)); *array = (int *) malloc (len * sizeof (int));<br></code></pre></td></tr></table></figure><p>在GDB调试过程中这样显示出这个动态数组的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prettyprint">p *array@len*array@len<br></code></pre></td></tr></table></figure><p>print的输出格式包括：</p><ul><li>x 按十六进制格式显示变量。</li><li>d 按十进制格式显示变量。</li><li>u 按十六进制格式显示无符号整型。</li><li>o 按八进制格式显示变量。</li><li>t 按二进制格式显示变量。</li><li>a 按十六进制格式显示变量。</li><li>c 按字符格式显示变量。</li><li>f 按浮点数格式显示变量。</li></ul><p>我们可用display命令设置一些自动显示的变量，当程序停住时，或是单步跟踪时，这些变量会自动显示。如果要修改变量，如x的值，可使用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prettyprint">print x=4 x=4<br></code></pre></td></tr></table></figure><p>当用GDB的print查看程序运行时的数据时，每一个print都会被GDB记录下来。GDB会以$1，$2，$3…这样的方式为每一个print命令编号。我们可以使用这个编号访问以前的表达式，如$1。</p><h3 id="watch命令">watch命令</h3><p>watch一般来观察某个表达式（变量也是一种表达式）的值是否有变化了，如果有变化，马上停住程序。我们有下面的几种方法来设置观察点：watch<expr>：为表达式（变量）expr设置一个观察点。一量表达式值有变化时，马上停住程序。rwatch<expr>：当表达式（变量）expr被读时，停住程序。awatch<expr>：当表达式（变量）的值被读或被写时，停住程序。infowatchpoints：列出当前所设置了的所有观察点。下面演示了观察i并在连续运行next时一旦发现i变化，i值就会显示出来的过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) watch i<br>Hardware watchpoint <span class="hljs-number">3</span>: <span class="hljs-built_in">i</span><br>(gdb) next<br><span class="hljs-number">23</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>(gdb) next<br>Hardware watchpoint <span class="hljs-number">3</span>: i<br><br>Old value = <span class="hljs-number">0</span><br>New value = <span class="hljs-number">1</span><br><span class="hljs-number">0x0804838d</span> in <span class="hljs-built_in">main</span> () at gdb_example.c:<span class="hljs-number">23</span><br><span class="hljs-number">23</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>(gdb) next<br><br>Breakpoint <span class="hljs-number">1</span>, <span class="hljs-built_in">main</span> () at gdb_example.c:<span class="hljs-number">25</span><br><span class="hljs-number">25</span>          sum[i] = <span class="hljs-built_in">add</span>(array1[i], array2[i]);<br>(gdb) next<br><span class="hljs-number">23</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>(gdb) next<br>Hardware watchpoint <span class="hljs-number">3</span>: i<br><br>Old value = <span class="hljs-number">1</span><br>New value = <span class="hljs-number">2</span><br><span class="hljs-number">0x0804838d</span> in <span class="hljs-built_in">main</span> () at gdb_example.c:<span class="hljs-number">23</span><br><span class="hljs-number">23</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br></code></pre></td></tr></table></figure><h3 id="examine命令">examine命令</h3><p>我们可以使用examine命令（缩写为x）来查看内存地址中的值。examine命令的语法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prettyprint">x/&lt;n/f/u&gt; &lt;addr&gt; /&lt;n/f/u&gt; &lt;addr&gt; <br></code></pre></td></tr></table></figure><p><addr>表示一个内存地址。“x/”后的n、f、u都是可选的参数，n是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容；f表示显示的格式，如果地址所指的是字符串，那么格式可以是s，如果地址是指令地址，那么格式可以是i；u表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4字节。u参数可以被一些字符代替：b表示单字节，h表示双字节，w表示四字节，g表示八字节。当我们指定了字节长度后，GDB会从指定的内存地址开始，读写指定字节，并把其当作一个值取出来。n、f、u这3个参数可以一起使用，例如命令“x/3uh0x54320”表示从内存地址0x54320开始以双字节为1个单位（h）、16进制方式（u）显示3个单位（3）的内存。==</p><p>譬如下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">main</span>()<br>&#123;<br>        <span class="hljs-type">char</span> *c = <span class="hljs-string">&quot;hello world&quot;</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, c);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> *c = <span class="hljs-string">&quot;hello world&quot;</span>;<br></code></pre></td></tr></table></figure><p>下一行设置断点后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) l<br><span class="hljs-number">1</span>    <span class="hljs-built_in">main</span>()<br><span class="hljs-number">2</span>    &#123;<br><span class="hljs-number">3</span>        <span class="hljs-type">char</span> *c = <span class="hljs-string">&quot;hello world&quot;</span>;<br><span class="hljs-number">4</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, c);<br><span class="hljs-number">5</span>    &#125;<br>(gdb) b <span class="hljs-number">4</span><br>Breakpoint <span class="hljs-number">1</span> at <span class="hljs-number">0x100000f17</span>: file main.c, line <span class="hljs-number">4.</span><br>(gdb) r<br>Starting program: /Users/songbarry/main<br>Reading symbols <span class="hljs-keyword">for</span> shared libraries +. done<br><br>Breakpoint <span class="hljs-number">1</span>, <span class="hljs-built_in">main</span> () at main.c:<span class="hljs-number">4</span><br><span class="hljs-number">4</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, c);<br></code></pre></td></tr></table></figure><p>可以通过多种方式看C指向的字符串：</p><p>方法1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) p c<br>$<span class="hljs-number">1</span> = <span class="hljs-number">0x100000f2e</span> <span class="hljs-string">&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) x/s <span class="hljs-number">0x100000f2e</span><br><span class="hljs-number">0x100000f2e</span>: <span class="hljs-string">&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure><p>方法3：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) <span class="hljs-built_in">p</span> (<span class="hljs-type">char</span> *)<span class="hljs-number">0x100000f2e</span><br>$<span class="hljs-number">3</span> = <span class="hljs-number">0x100000f2e</span> <span class="hljs-string">&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure><p>将第一个字符改为大写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) p *(<span class="hljs-type">char</span> *)<span class="hljs-number">0x100000f2e</span>=<span class="hljs-string">&#x27;H&#x27;</span><br>$<span class="hljs-number">4</span> = <span class="hljs-number">72</span> <span class="hljs-string">&#x27;H&#x27;</span><br></code></pre></td></tr></table></figure><p>再看看C：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) p c<br>$<span class="hljs-number">5</span> = <span class="hljs-number">0x100000f2e</span> <span class="hljs-string">&quot;Hello world&quot;</span><br></code></pre></td></tr></table></figure><h3 id="set命令">set命令</h3><p>修改寄存器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) set $v0 = <span class="hljs-number">0x004000000</span><br>(gdb) set $epc = <span class="hljs-number">0xbfc00000</span> <br></code></pre></td></tr></table></figure><p>修改内存：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) set &#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&#125;<span class="hljs-number">0x8048a51</span>=<span class="hljs-number">0x0</span><br></code></pre></td></tr></table></figure><p>譬如对于第8节的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) set &#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&#125;<span class="hljs-number">0x100000f2e</span>=<span class="hljs-number">0x0</span>       <br>(gdb) x/<span class="hljs-number">10</span>cb <span class="hljs-number">0x100000f2e</span><br><span class="hljs-number">0x100000f2e</span>:<span class="hljs-number">0</span> <span class="hljs-string">&#x27;\0&#x27;</span><span class="hljs-number">0</span> <span class="hljs-string">&#x27;\0&#x27;</span><span class="hljs-number">0</span> <span class="hljs-string">&#x27;\0&#x27;</span><span class="hljs-number">0</span> <span class="hljs-string">&#x27;\0&#x27;</span><span class="hljs-number">111</span> <span class="hljs-string">&#x27;o&#x27;</span><span class="hljs-number">32</span> <span class="hljs-string">&#x27; &#x27;</span><span class="hljs-number">119</span> <span class="hljs-string">&#x27;w&#x27;</span><span class="hljs-number">111</span> <span class="hljs-string">&#x27;o&#x27;</span><br><span class="hljs-number">0x100000f36</span>:<span class="hljs-number">114</span> <span class="hljs-string">&#x27;r&#x27;</span><span class="hljs-number">108</span> <span class="hljs-string">&#x27;l&#x27;</span><br>(gdb) p c<br>$<span class="hljs-number">10</span> = <span class="hljs-number">0x100000f2e</span> <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="jump命令">jump命令</h3>一般来说，被调试程序会按照程序代码的运行顺序依次执行，但是GDB也提供了乱序执行的功能，也就是说，GDB可以修改程序的执行顺序，从而让程序随意跳跃。这个功能可以由GDB的jump命令：jump<linespec>来指定下一条语句的运行点。<linespec>可以是文件的行号，可以是file:line格式，也可以是+num这种偏移量格式，表示下一条运行语句从哪里开始。jump<address>这里的<address><p>是代码行的内存地址。注意，jump命令不会改变当前的程序栈中的内容，所以，如果使用jump从一个函数跳转到另一个函数，当跳转到的函数运行完返回，进行出栈操作时必然会发生错误，这可能导致意想不到的结果，所以最好只用jump在同一个函数中进行跳转。</p><h3 id="signal命令">signal命令</h3><p>使用singal命令，可以产生一个信号量给被调试的程序，如中断信号“Ctrl+C”。这非常方便于程序的调试，可以在程序运行的任意位置设置断点，并在该断点用GDB产生一个信号量，这种精确地在某处产生信号的方法非常有利于程序的调试。signal命令的语法是：signal <signal>，<ahref="https://so.csdn.net/so/search?q=UNIX&amp;spm=1001.2101.3001.7020">UNIX</a>的系统信号量通常从1到15，所以<signal>取值也在这个范围。</p><h3 id="return命令">return命令</h3><p>如果在函数中设置了调试断点，在断点后还有语句没有执行完，这时候我们可以使用return命令强制函数忽略还没有执行的语句并返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">return</span><br><span class="hljs-keyword">return</span> &lt;expression&gt;<br></code></pre></td></tr></table></figure><p>上述return命令用于取消当前函数的执行，并立即返回，如果指定了<expression>，那么该表达式的值会被作为函数的返回值。</p><h3 id="call命令">call命令</h3><p>call命令用于强制调用某函数： call <expr>表达式中可以一是函数，以此达到强制调用函数的目的，它会显示函数的返回值（如果函数返回值不是void）。其实，前面介绍的print命令也可以完成强制调用函数的功能。</p><h3 id="info命令">info命令</h3><p>info命令可以在调试时用来查看寄存器、断点、观察点和信号等信息。要查看寄存器的值，可以使用如下命令：info registers （查看除了浮点寄存器以外的寄存器）info all-registers（查看所有寄存器，包括浮点寄存器）info registers &lt;regname ...&gt;（查看所指定的寄存器） 要查看断点信息，可以使用如下命令：info break列出当前所设置的所有观察点，使用如下命令：info watchpoints查看有哪些信号正在被GDB检测，使用如下命令：info signals info handle也可以使用info line命令来查看源代码在内存中的地址。infothreads可以看多线程。infoline后面可以跟行号、函数名、文件名:行号、文件名:函数名等多种形式，例如下面的命令会打印出所指定的源码在运行时的内存地址：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">info line tst.c:func<br></code></pre></td></tr></table></figure><h3 id="set-scheduler-locking-offonstep">set scheduler-lockingoff|on|step</h3><p>off 不锁定任何线程，也就是所有线程都执行，这是默认值。 on只有当前被调试程序会执行。 step在单步的时候，除了next过一个函数的情况以外，只有当前线程会执行。</p><p>与多线程调试相关的命令还包括：</p><p>thread ID 切换当前调试的线程为指定ID的线程。</p><p>break thread_test.c:123 thread all 在所有线程中相应的行上设置断点</p><p>thread apply ID1 ID2 command让一个或者多个线程执行GDB命令command。</p><p>thread apply all command 让所有被调试线程执行GDB命令command。</p><h3 id="disassemble">disassemble</h3><p>disassemble命令用于反汇编，它可被用来查看当前执行时的源代码的机器码，其实际上只是把目前内存中的指令dump出来。下面的示例用于查看函数func的汇编代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) disassemble func<br>Dump of assembler code <span class="hljs-keyword">for</span> function func:<br><span class="hljs-number">0x8048450</span> &lt;func&gt;:       push   %ebp<br><span class="hljs-number">0x8048451</span> &lt;func+<span class="hljs-number">1</span>&gt;:     mov    %esp,%ebp<br><span class="hljs-number">0x8048453</span> &lt;func+<span class="hljs-number">3</span>&gt;:     sub    $<span class="hljs-number">0x18</span>,%esp<br><span class="hljs-number">0x8048456</span> &lt;func+<span class="hljs-number">6</span>&gt;:     movl   $<span class="hljs-number">0x0</span>,<span class="hljs-number">0xfffffffc</span>(%ebp)<br>...<br>End of assembler dump.<br></code></pre></td></tr></table></figure><h2 id="gcc">6.gcc</h2><h3 id="优化等级">优化等级</h3><p>gcc中指定优化级别的参数有：-O0、-O1、-O2、-O3、-Og、-Os、-Ofast。在编译时，如果没有指定优化参数，则默认为-O0</p><p>-O1、-O2、-O3中，随着数字变大，代码的优化程度也越高，不过这在某种意义上来说，也是以牺牲程序的可调试性为代价的。</p><p>-Og 是在 -O1的基础上，去掉了那些影响调试的优化，所以如果最终是为了调试程序，可以使用这个参数。不过光有这个参数也是不行的，这个参数只是告诉编译器，编译后的代码不要影响调试，但调试信息的生成还是靠-g 参数的。</p><p>参数 -Os 是在 -O2的基础上，去掉了那些会导致最终可执行程序增大的优化，如果想要更小的可执行程序，可选择这个参数。</p><p>参数 -Ofast 是在 -O3的基础上，添加了一些非常规优化，这些优化是通过打破一些国际标准（比如一些数学函数的实现标准）来实现的，所以一般不推荐使用该参数。</p><h3 id="编译链接命令">编译链接命令</h3><p>在使用 GCC 编译程序时，编译过程可以被细分为四个阶段：</p><p>1）<strong>预处理</strong>（ Pre-Processing）阶段：主要对包含的头文件（＃include ）和宏定义（＃define,#ifdef …）进行处理。可以使用“gcc -E” 让gcc 在预处理之后停止编译过程，生成 *.i文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -E hello.c -o hello.i<br></code></pre></td></tr></table></figure><p>2）<strong>编译</strong>（ Compiling ）阶段：gcc首先要检查代码的规范性，是否有语法错误等。以确定代码实际要做的工作，在检查无误后，gcc把代码翻译成汇编语言。用户可以使用-S选项进行查看，该选项只进行编译而不进行汇编，生成汇编代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -S hello.i -o hello.s<br></code></pre></td></tr></table></figure><p>3） <strong>汇编</strong>（ Asse mbling ）阶段：生成目标代码 <em>.o；有两种方式：使用 gcc 直接从源代码生成目标代码 gcc -c </em>.s -o <em>.o以及使用汇编器从汇编代码生成目标代码 as </em>.s -o *.o</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -c hello.s -o hello.o<br>as hello.s -o hello.o<br></code></pre></td></tr></table></figure><p>也可以直接使用as <em>.s,将<strong>执行汇编、链接过程生成可执行文件a.out</strong>,可以像上面使用<strong>-o 选项</strong>指定输出文件的格式。4）<strong>链接</strong>（ Linking）阶段：生成可执行文件；可以生成的可执行文件格式有：a.out/</em>/,当然可能还有其它格式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc hello.o     生成可执行文件 a.out<br>gcc hello.o -o hello        生成可执行文件 hello<br></code></pre></td></tr></table></figure><p><strong>gcc 常用编译选项：</strong></p><table><colgroup><col style="width: 10%" /><col style="width: 89%" /></colgroup><thead><tr class="header"><th>选项</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>-c</td><td>只编译不链接，生成目标文件<code>.o</code></td></tr><tr class="even"><td>-S</td><td>只编译不汇编，生成汇编代码</td></tr><tr class="odd"><td>-E</td><td>只进行预编译</td></tr><tr class="even"><td>-g</td><td>在可执行程序中包含标准调试信息</td></tr><tr class="odd"><td>-o file</td><td>指定file文件作为输出文件</td></tr><tr class="even"><td>-v</td><td>打印出编译器内部编译各过程的命令行信息和编译器的版本</td></tr><tr class="odd"><td>-Idir</td><td>在头文件的搜索路径列表中添加dir目录</td></tr><tr class="even"><td>-static</td><td>进行静态编译，只链接静态库，禁止使用动态库</td></tr><tr class="odd"><td>-shared</td><td>进行动态编译，尽可能地链接动态库，没有动态库时才会链接同名静态库</td></tr><tr class="even"><td>-L dir</td><td>在库文件的搜索路径列表中添加dir目录</td></tr><tr class="odd"><td>-lname</td><td>链接libname.a或libname.so的库文件</td></tr><tr class="even"><td>-fPIC</td><td>生成使用相对地址的位置无关目标代码（Position Independent Code）</td></tr></tbody></table><p>gcc在链接时优先使用动态链接库，只有当动态链接库不存在时才考虑使用静态链接库，如果需要的话可以在编译时加上<strong>-static</strong>选项，强制使用静态链接库。</p><h2 id="重定向">7.重定向</h2><h3 id="linux-21">Linux 2&gt;&amp;1</h3><p>2&gt;&amp;1的意思是将标准错误(2)也定向到标准输出(1)的输出文件中。</p><p>Linux中三种标准输入输出，分别是STDIN，STDOUT，STDERR，对应的数字是0，1，2。</p><p>STDIN就是标准输入，默认从键盘读取信息；</p><p>STDOUT是标准输出，默认将输出结果输出至终端，也就是显示器之类的东西；</p><p>STDERR是标准的错误信息，默认也会显示在终端上。</p><p>由于STDOUT与STDERR都会默认显示在终端上，为了区分二者的信息，就有了编号的0，1，2的定义，用1表示STDOUT，2表示STDERR。</p><h3 id="从commanddevnull说起">从command&gt;/dev/null说起</h3><p>其实这条命令是一个缩写版，对于一个重定向命令，肯定是<code>a &gt; b</code>这种形式，那么<code>command &gt; /dev/null</code>难道是command充当a的角色，/dev/null充当b的角色。这样看起来比较合理，其实一条命令肯定是充当不了a，肯定是command执行产生的输出来充当a，其实就是标准输出stdout。所以<code>command &gt; /dev/null</code>相当于执行了<code>command 1 &gt; /dev/null</code>。执行command产生了标准输出stdout(用1表示)，重定向到/dev/null的设备文件中。</p><h3 id="说说21">说说2&gt;&amp;1</h3><p>通过上面<code>command &gt; /dev/null</code>等价于<code>command 1 &gt; /dev/null</code>,那么对于<code>2&gt;&amp;1</code>也就好理解了，2就是标准错误，1是标准输出，那么这条命令不就是相当于把标准错误重定向到标准输出么。等等是&amp;1而不是1，这里&amp;是什么？这里<code>&amp;</code>相当于<strong>等效于标准输出</strong>。这里有点不好理解，先看下面。</p><h3 id="commanda-2a-与-commanda-21的区别">command&gt;a 2&gt;a 与command&gt;a 2&gt;&amp;1的区别</h3><p>通过上面的分析，对于<code>command&gt;a 2&gt;&amp;1</code>这条命令，等价于<code>command 1&gt;a 2&gt;&amp;1</code>可以理解为执行command产生的标准输入重定向到文件a中，标准错误也重定向到文件a中。那么是否就说<code>command 1&gt;a 2&gt;&amp;1</code>等价于<code>command 1&gt;a 2&gt;a</code>呢。其实不是，<code>command 1&gt;a 2&gt;&amp;1</code>与<code>command 1&gt;a 2&gt;a</code>还是有区别的，区别就在于前者只打开一次文件a，后者会打开文件两次，并导致stdout被stderr覆盖。<code>&amp;1</code>的含义就可以理解为用标准输出的引用，引用的就是重定向标准输出产生打开的a。从IO效率上来讲，<code>command 1&gt;a 2&gt;&amp;1</code>比<code>command 1&gt;a 2&gt;a</code>的效率更高</p><h3 id="再思考一下">再思考一下</h3><p>为什么2&gt;&amp;1 要放在后边呢？我的理解是因为2（也就是错误输出）要重定向到&amp;1，也就是标准输出的引用中，也就是标准输出打开的文件中，所以需要现在前面打开1的输出文件。</p><h3 id="nohup及nohup.out">nohup及nohup.out</h3><p>如果使用nohup执行命令，配合&amp;的使用，则可以不挂断的将命令执行到后台，如果没有指定重定向文件，则输出将附加到当前目录的nohup.out 文件中。如果当前目录的 nohup.out 文件不可写，输出重定向到$HOME/nohup.out 文件中，实例如下：</p><p>nohup test.pl 2&gt;&amp;1 &amp;</p><p>在shell脚本中，默认情况下，总是有三个文件处于打开状态，标准输入(键盘输入)、标准输出（输出到屏幕）、标准错误（也是输出到屏幕），它们分别对应的<strong>文件描述符</strong>是0，1，2。</p><p><strong>&gt; 默认为标准输出重定向，与 1&gt; 相同 2&gt;&amp;1</strong>意思是把 标准错误输出 重定向到 标准输出.</p><p><strong>&amp;&gt;file</strong> 意思是把<strong>标准输出</strong> 和<strong>标准错误输出</strong> 都重定向到文件file中</p><p><strong>/dev/null是一个文件，这个文件比较特殊，所有传给它的东西它都丢弃掉</strong></p><p><strong>举例说明:</strong></p><p>当前目录只有一个文件 a.txt. [root@redhat box]# ls a.txt [root@redhatbox]# ls a.txt b.txt ls: b.txt: No such file or directory由于没有b.txt这个文件, 于是返回错误值, 这就是所谓的2输出 a.txt而这个就是所谓的1输出</p><p><strong>再接着看:</strong></p><p>[root@redhat box]# ls a.txt b.txt 1&gt;<strong>file.out</strong>2&gt;<strong>file.err</strong> 执行后,没有任何返回值. 原因是, 返回值都<ahref="https://so.csdn.net/so/search?q=重定向&amp;spm=1001.2101.3001.7020">重定向</a>到相应的文件中了,而不再前端显示[root@redhat box]# cat file.out a.txt [root@redhat box]# cat file.errls: b.txt: No such file or directory 一般来说, "1&gt;" 通常可以省略成"&gt;". 即可以把如上命令写成: ls a.txt b.txt &gt;file.out 2&gt;file.err有了这些认识才能理解 "1&gt;&amp;2" 和 "2&gt;&amp;1". <strong>1&gt;&amp;2正确返回值传递给2输出通道 &amp;2表示2输出通道</strong> 如果此处错写成1&gt;2, 就表示把1输出重定向到文件2中. <strong>2&gt;&amp;1错误返回值传递给1输出通道, 同样&amp;1表示1输出通道.</strong> 举个例子.[root@redhat box]# <strong>ls a.txt b.txt 1&gt;file.out2&gt;&amp;1</strong> [root@redhat box]# cat file.out ls: b.txt: No suchfile or directory a.txt 现在,正确的输出和错误的输出都定向到了file.out这个文件中, 而不显示在前端.补充下, 输出不只1和2, 还有其他的类型, 这两种只是最常用和最基本的.</p><p>例如： rm -f $(find / -name core) &amp;&gt;/dev/null，<strong>/dev/null是一个文件，这个文件比较特殊，所有传给它的东西它都丢弃掉。</strong></p><p>例如： 注意，为了方便理解，必须设置一个环境使得执行grep da<em>命令会有正常输出和错误输出，然后分别使用下面的命令生成三个文件：grep da </em> &gt; greplog1 grep da * &gt; greplog2 1&gt;&amp;2<br />grep da * &gt; greplog3 2&gt;&amp;1 //grep da * 2&gt; greplog41&gt;&amp;2 结果一样 #查看greplog1会发现里面只有正常输出内容#查看greplog2会发现里面什么都没有#查看greplog3会发现里面既有正常输出内容又有错误输出内容</p><h2 id="grep命令">8. grep命令</h2><p><code>grep</code>命令是打印匹配文本行，其全称为 Global Search RegularExpression and Print out the line；基本语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;code class=<span class="hljs-string">&quot;hljs css has-numbering&quot;</span>&gt;&lt;span class=<span class="hljs-string">&quot;hljs-tag&quot;</span>&gt;grep&lt;/span&gt; &lt;span class=<span class="hljs-string">&quot;hljs-attr_selector&quot;</span>&gt;[OPTIONS]&lt;/span&gt; &lt;span class=<span class="hljs-string">&quot;hljs-tag&quot;</span>&gt;PATTERN&lt;/span&gt; &lt;span class=<span class="hljs-string">&quot;hljs-attr_selector&quot;</span>&gt;[FILE...]&lt;/span&gt;<br>&lt;span class=<span class="hljs-string">&quot;hljs-tag&quot;</span>&gt;grep&lt;/span&gt; &lt;span class=<span class="hljs-string">&quot;hljs-attr_selector&quot;</span>&gt;[OPTIONS]&lt;/span&gt; &lt;span class=<span class="hljs-string">&quot;hljs-attr_selector&quot;</span>&gt;[-e PATTERN | -f FILE]&lt;/span&gt; &lt;span class=<span class="hljs-string">&quot;hljs-attr_selector&quot;</span>&gt;[FILE...]&lt;/span&gt;<br>&lt;/code&gt;<br></code></pre></td></tr></table></figure><p>其中，<code>OPTIONS</code>表示选项；<code>PATTERN</code>表示匹配模式，匹配模式可以是字符串、变量、正则表达式，若匹配模式中含义空格，则需要使用双引号将匹配模式引起来；<code>FILE</code>表示一系列文件；<code>grep</code>命令从文件中搜索满足指定匹配模式的文本行，并打印出来。</p><p>正则表达式的分类为：</p><ul><li>基本正则表达式（Basic Regular Expression）：Basic RegEx，简称<strong>BRE</strong></li><li>扩展正则表达式（Extended Regular Expression）：Extended RegEx，简称<strong>ERE</strong></li><li>Perl 正则表达式（Perl Regular Expression）：Perl RegEx，简称<strong>PCRE</strong>；</li></ul><p><code>grep</code>命令根据不同的参数支持不同的正则表达式：</p><ul><li><code>grep</code>命令后不跟任何参数（默认），则表示要使用“BRE”；</li><li><code>grep</code>命令后跟<code>-E</code>参数，则表示要使用“ERE”；</li><li><code>grep</code>命令后跟<code>-P</code>参数，则表示要使用“PCRE”；</li></ul><p>常用<code>OPTIONS</code>选项如下表所示：</p><table><colgroup><col style="width: 14%" /><col style="width: 85%" /></colgroup><thead><tr class="header"><th>选项</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>-E</td><td>指定 PATTERN 匹配模式为扩展正则表达式</td></tr><tr class="even"><td>-F</td><td>指定 PATTERN 匹配模式为固定的字符串</td></tr><tr class="odd"><td>-G</td><td>指定 PATTERN 匹配模式为基本正则表达式</td></tr><tr class="even"><td>-P</td><td>指定 PATTERN 匹配模式为 Perl 正则表达式</td></tr><tr class="odd"><td>-R</td><td>查找所有文件包含子目录</td></tr><tr class="even"><td>-e PATTERN</td><td>指定 PATTERN 为一个或多个搜索模式</td></tr><tr class="odd"><td>-f FILE</td><td>指定包含搜索模式的 FILE</td></tr><tr class="even"><td><strong>-i</strong></td><td>匹配是忽略字母大小写</td></tr><tr class="odd"><td><strong>-v</strong></td><td>显示所有与匹配模式不匹配的文本行（如grep -v "grep"或grep -v grep意思是不显示包含grep符串的那一行）</td></tr><tr class="even"><td>-w</td><td>执行单词搜索</td></tr><tr class="odd"><td>-x</td><td>显示与指定模式精确匹配而不含其他字符的文本行</td></tr><tr class="even"><td>-y</td><td>与选项 -i 相同功能</td></tr><tr class="odd"><td></td><td></td></tr><tr class="even"><td>-c</td><td>只打印匹配的文本行的行数，不显示匹配内容</td></tr><tr class="odd"><td>-l</td><td>只显示匹配文本行的文件名，不显示匹配内容</td></tr><tr class="even"><td><strong>-n</strong></td><td>列出所有匹配的文本行，并显示行号</td></tr><tr class="odd"><td><strong>-r</strong></td><td>递归搜索目录(当前目录及其各级子目录)</td></tr><tr class="even"><td>-s</td><td>不显示错误信息</td></tr></tbody></table><p>在当前目录下查找"hello,world!"字符串<code>grep -rn "hello,world!" *</code> * :表示当前目录所有文件，也可以是某个文件名</p><p>命令行参数：</p><p>grep -i pattern files ：不区分大小写地搜索。默认情况区分大小写，</p><p>grep -l pattern files ：只列出匹配的文件名，</p><p>grep -L pattern files ：列出不匹配的文件名，</p><p>grep -w pattern files：只匹配整个单词，而不是字符串的一部分（如匹配‘magic’，而不是‘magical’），</p><p>grep -C number pattern files ：匹配的上下文分别显示[number]行，</p><p>grep pattern1 | pattern2 files ：显示匹配 pattern1 或 pattern2的行，</p><p>grep pattern1 files | grep pattern2 ：显示既匹配 pattern1 又匹配pattern2 的行。</p><p>&lt; 和 &gt; 分别标注单词的开始与结尾。</p><p>grep man * 会匹配 ‘Batman’、‘manic’、‘man’等，</p><p>grep '&lt;man' * 匹配‘manic’和‘man’，但不是‘Batman’，</p><p>grep '&lt;man&gt;'只匹配‘man’，而不是‘Batman’或‘manic’等其他的字符串。</p><p>'^'：指匹配的字符串在行首，</p><p>'$'：指匹配的字符串在行尾，</p><h2 id="流编辑器-sed">9. 流编辑器 sed</h2><h3 id="sed命令">sed命令</h3><p>元字符集：<br /><code>^</code>锚定行的开始 如：/^sed/匹配所有以sed开头的行。</p><p><code>$</code>锚定行的结束 如：/sed$/匹配所有以sed结尾的行。</p><p><code>.</code>匹配一个非换行符的字符如：/s.d/匹配s后接一个任意字符，然后是d。</p><p><code>*</code>匹配零或多个字符如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。</p><p><code>[]</code>匹配一个指定范围内的字符，如/[Ss]ed/匹配sed和Sed。</p><p><code>[^]</code>匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。</p><p>保存匹配的字符，如s/able/\1rs，loveable被替换成lovers。</p><p><code>&amp;</code>保存搜索字符用来替换其他字符，如s/love/<strong>&amp;</strong>/，love这成<strong>love</strong>。</p><p><code>\&lt;</code>锚定单词的开始，如:/&lt;love/匹配包含以love开头的单词的行。</p><p><code>\&gt;</code>锚定单词的结束，如/love&gt;/匹配包含以love结尾的单词的行。</p><p><code>x\&#123;m\&#125;</code>重复字符x，m次，如：/0{5}/匹配包含5个o的行。</p><p><code>x\&#123;m,\&#125;</code>重复字符x,至少m次，如：/o{5,}/匹配至少有5个o的行。</p><p><code>x\&#123;m,n\&#125;</code>重复字符x，至少m次，不多于n次，如：/o{5,10}/匹配5--10个o的行。</p><p>​ 先看几个实例：</p><p>删除：d命令</p><ul><li>$ sed '2d' example-----删除example文件的第二行。</li><li>$ sed '2,$d' example-----删除example文件的第二行到末尾所有行。</li><li>$ sed '$d' example-----删除example文件的最后一行。</li><li>$ sed '/test/'d example-----删除example文件所有包含test的行。</li></ul><p>替换：s命令</p><ul><li><p>$ sed 's/test/mytest/g'example-----在整行范围内把test替换为mytest。如果没有g标记，则只有每行第一个匹配的test被替换成mytest。</p></li><li><p>$ sed -n 's/^test/mytest/p'example-----(-n)选项和p标志一起使用表示只打印那些发生替换的行。也就是说，如果某一行开头的test被替换成mytest，就打印它。</p></li><li><p>$ sed 's/^192.168.0.1/&amp;localhost/'example-----&amp;符号表示替换换字符串中被找到的部份。所有以192.168.0.1开头的行都会被替换成它自已加localhost，变成192.168.0.1localhost。</p></li><li><p>$ sed -n 's/able/\1rs/p'example-----love被标记为1，所有loveable会被替换成lovers，而且替换的行会被打印出来。</p></li><li><p>$ sed 's#10#100#g'example-----不论什么字符，紧跟着s命令的都被认为是新的分隔符，所以，“#”在这里是分隔符，代替了默认的“/”分隔符。表示把所有10替换成100。</p><p>选定行的范围：逗号</p></li><li><p>$ sed -n '/test/,/check/p'example-----所有在模板test和check所确定的范围内的行都被打印。</p></li><li><p>$ sed -n '5,/^test/p'example-----打印从第五行开始到第一个包含以test开始的行之间的所有行。</p></li><li><p>$ sed '/test/,/check/s/$/sed test/'example-----对于模板test和west之间的行，每行的末尾用字符串sedtest替换。</p></li></ul><p>多点编辑：e命令</p><ul><li>$ sed -e '1,5d' -e 's/test/check/'example-----(-e)选项允许在同一行里执行多条命令。如例子所示，第一条命令删除1至5行，第二条命令用check替换test。命令的执行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。</li><li>$ sed --expression='s/test/check/' --expression='/love/d'example-----一个比-e更好的命令是--expression。它能给sed表达式赋值。</li></ul><p>从文件读入：r命令</p><ul><li>$ sed '/test/r file'example-----file里的内容被读进来，显示在与test匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面。</li></ul><p>写入文件：w命令</p><ul><li>$ sed -n '/test/w file'example-----在example中所有包含test的行都被写入file里。</li></ul><p>追加命令：a命令</p><ul><li>$ sed '/^test/a\---&gt;this is a example' example&lt;-----'this is aexample'被追加到以test开头的行后面，sed要求命令a后面有一个反斜杠。</li></ul><p>插入：i命令</p><p>$ sed '/test/i\</p><p>new line</p><p>-------------------------' example</p><p>如果test被匹配，则把反斜杠后面的文本插入到匹配行的前面。</p><p>下一个：n命令</p><ul><li>$ sed '/test/{ n; s/aa/bb/; }'example-----如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb，并打印该行，然后继续。</li></ul><p>变形：y命令</p><ul><li>$ sed '1,10y/abcde/ABCDE/'example-----把1--10行内所有abcde转变为大写，注意，正则表达式元字符不能使用这个命令。</li></ul><p>退出：q命令</p><ul><li>$ sed '10q' example-----打印完第10行后，退出sed。</li></ul><p>保持和获取：h命令和G命令</p><ul><li>$ sed -e '/test/h' -e '$Gexample-----在sed处理文件的时候，每一行都被保存在一个叫模式空间的临时缓冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。在这个例子里，匹配test的行被找到后，将存入模式空间，h命令将其复制并存入一个称为保持缓存区的特殊缓冲区内。第二条语句的意思是，当到达最后一行后，G命令取出保持缓冲区的行，然后把它放回模式空间中，且追加到现在已经存在于模式空间中的行的末尾。在这个例子中就是追加到最后一行。简单来说，任何包含test的行都被复制并追加到该文件的末尾。</li></ul><p>保持和互换：h命令和x命令</p><ul><li>$ sed -e '/test/h' -e '/check/x' example-----互换模式空间和保持缓冲区的内容。也就是把包含test与check的行互换。</li></ul><p><code>sed</code>命令从文件或者标准输入中一次读取一行数据，将该行数据复制到缓冲区，然后读取命令行或脚本的编辑子命令，对缓冲区中的文本行进行编辑。重复此工作，直到所有文本行都处理完毕。</p><p><code>sed</code>命令编辑的是文件是原始文件在缓冲区中的副本，并不影响原始文件，但是可以把编辑结果通过输出重定向保存起来。</p><p><code>sed</code>命令的基本语法如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;code class=<span class="hljs-string">&quot;hljs r has-numbering&quot;</span>&gt;sed [OPTION]&lt;span class=<span class="hljs-string">&quot;hljs-keyword&quot;</span>&gt;...&lt;/span&gt; &#123;script&#125; [input-file]&lt;span class=<span class="hljs-string">&quot;hljs-keyword&quot;</span>&gt;...&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure><p>常用选项<code>OPTION</code>如下表所示：</p><table><thead><tr class="header"><th>选项</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><strong>-n</strong></td><td>取消默认输出</td></tr><tr class="even"><td>-e script</td><td>允许执行多个脚本</td></tr><tr class="odd"><td><strong>-f script-file</strong></td><td><strong>从脚本文件中读取命令</strong></td></tr><tr class="even"><td><strong>-i</strong></td><td><strong>直接修改原始文件</strong></td></tr><tr class="odd"><td>-l N</td><td>指定行长度为 N</td></tr><tr class="even"><td>-r</td><td>在脚本中使用扩展正则表达式</td></tr><tr class="odd"><td>-s</td><td>把文件作为单独文件</td></tr><tr class="even"><td>-u</td><td>最低限度的缓存输入与输出</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">test2.sh<br><span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;code&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;python&quot;</span>&gt;</span>  asdafsadfasdfsa<br>  badfasdfas<br>  bdsdfsdfsdf<br>  csdfasdfasf<br></code></pre></td></tr></table></figure><p>test.sh #!/bin/bash</p><p>sed -ie '/^b/ s/b/bbbbbb/g' test2.sh</p><p>执行后test2.sh的结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">asdafsadfasdfsa<br>bbbbadfasdfas<br>bbbbdsdfsdfsdf<br>csdfasdfasf<br></code></pre></td></tr></table></figure><p><strong>如果不带-i，那么test2.sh中的内容不会发生变化，发生变化的只是缓冲区中的内容。</strong></p><h3 id="文本行定位">文本行定位</h3><p><code>sed</code>命令提供了两种方式来实现文本行的定位：<strong>行号定位</strong>、<strong>正则表达式定位</strong></p><h3 id="行号定位"><strong>行号定位</strong></h3><ul><li>定位某个特定的行<strong><code>n</code></strong>：<code>n</code>是一个整数，表示定位到文本的第<code>n</code>行；</li><li>定位某段连续的行<strong><code>n,m</code></strong>：<code>n</code>和<code>m</code>都是整数，表示定位到起始行为<code>n</code>，终止行为<code>m</code>的文本行；</li><li>指定起始行和步长<strong><code>start~step</code></strong>：起始行为<code>start</code>，步长为<code>step</code>；</li><li>第一行<strong><code>1</code></strong>和最后一行<strong><code>$</code></strong>：<code>1</code>表示第一行，<code>$</code>表示最后一行；</li><li>指定某行后面的几行<strong><code>n,+x</code></strong>：表示从第<code>n</code>行开始到后面的<code>x</code>行；</li></ul><h3 id="正则表达式定位"><strong>正则表达式定位</strong></h3><p><code>sed</code>命令使用正则表达式定位文本行的语法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs vala has-numbering&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;#regexp 表示正则表达式&lt;/span&gt;<br>/regexp/<br><br>如：/^b/ 表示行首为b<br>   /1,3/ 表示第1～3行<br>&lt;/code&gt;<br></code></pre></td></tr></table></figure><h3 id="sed命令的常用操作">sed命令的常用操作</h3><p><code>sed</code>命令的常用编辑命令有：打印、删除、增加、替换；其基本语法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs css has-numbering&quot;&gt;&lt;span class=&quot;hljs-attr_selector&quot;&gt;[address1[,address2]&lt;/span&gt;] &lt;span class=&quot;hljs-tag&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;hljs-attr_selector&quot;&gt;[argument]&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure><p>其中<code>address</code>称为位置参数，即上面的行定位；<code>command</code>是<code>sed</code>所提供的子命令，用来实现编辑操作；<code>argument</code>表示子命令的选项参数；</p><h4 id="打印文本">1) 打印文本</h4><p><code>sed</code>命令中可通过位置参数和<strong><code>p</code></strong>命令打印所需要的文本行，其语法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs css has-numbering&quot;&gt;&lt;span class=&quot;hljs-attr_selector&quot;&gt;[address1[,address2]&lt;/span&gt;] &lt;span class=&quot;hljs-tag&quot;&gt;p&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;&lt;span class=&quot;hljs-shebang&quot;&gt;#! /bin/bash<br>&lt;/span&gt;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#输出第1~4行文本，注意1,3p之间是单引号&lt;/span&gt;<br>sed -n &lt;span class=&quot;hljs-string&quot;&gt;&#x27;1,3p&#x27;&lt;/span&gt; test.txt<br><br>&lt;span class=&quot;hljs-comment&quot;&gt;#输出以Lin开头的文本行&lt;/span&gt;<br>result=`sed -n &lt;span class=&quot;hljs-string&quot;&gt;&#x27;/^Lin/ p&#x27;&lt;/span&gt; test.txt`<br>&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$result&lt;/span&gt;&quot;&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure><h4 id="替换文本">2) 替换文本</h4><p><code>sed</code>命令中可通过位置参数和<code>s</code>子命令替换文本行，其语法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs coffeescript has-numbering&quot;&gt;[address1[,address2]] s&lt;span class=&quot;hljs-regexp&quot;&gt;/pattern/replacemen/&lt;/span&gt;[flag]&lt;/code&gt;<br></code></pre></td></tr></table></figure><p><code>flag</code>为替换标志，不同值会影响<code>s</code>子命令的行为；<code>flag</code>常用取值如下表所示：</p><table><colgroup><col style="width: 13%" /><col style="width: 86%" /></colgroup><thead><tr class="header"><th>取值</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><strong>g</strong></td><td>全局匹配，会替换文本行所有符合规则的字符串</td></tr><tr class="even"><td>p</td><td>替换第一个符合规则的字符串，并将缓冲区输出到标准输出</td></tr><tr class="odd"><td>w</td><td>替换第一个符合规则的字符串，并将受影响的行输出到磁盘文件中</td></tr><tr class="even"><td>十进制数n</td><td>替换文本行中第n个符合规则的字符串</td></tr><tr class="odd"><td>空</td><td>若不指定flag值，替换文本行中第一个符合规则的字符串</td></tr></tbody></table><h4 id="删除文本">3) 删除文本</h4><p><code>sed</code>命令中可通过位置参数和<code>d</code>子命令删除文本行，其语法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs css has-numbering&quot;&gt;&lt;span class=&quot;hljs-attr_selector&quot;&gt;[address1[,address2]&lt;/span&gt;] &lt;span class=&quot;hljs-tag&quot;&gt;d&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure><h4 id="增加文本">4) 增加文本</h4><p><strong>追加文本</strong><code>sed</code>命令中可通过位置参数和<code>a</code>子命令追加文本行，其语法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs vala has-numbering&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;#将string插入到address1位置后面&lt;/span&gt;<br>[address1] a &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt; &lt;/code&gt;<br></code></pre></td></tr></table></figure><h4 id="插入文本"><strong>5) 插入文本</strong></h4><p><code>sed</code>命令中可通过位置参数和<code>i</code>子命令插入文本行，其语法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs vala has-numbering&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;#将string插入到address1位置前面&lt;/span&gt;<br>[address1] i &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure><h4 id="组合命令">6) 组合命令</h4><p><code>sed</code>命令支持将多个子命令组合在一起使用；具体方式如下所示：</p><ul><li>使用<code>-e</code>选项：<code>-e</code>选项可以将多个子命令组合在一起使用；例如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;&lt;span class=&quot;hljs-shebang&quot;&gt;#! /bin/bash<br>&lt;/span&gt;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#将全部小写字母 e 替换成大写字母 E，并打印第 1 行到第 3 行文本行&lt;/span&gt;<br>result=`sed -n &lt;span class=&quot;hljs-operator&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#x27;s/e/E/g&#x27;&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#x27;1,3 p&#x27;&lt;/span&gt; test.txt`<br>&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$result&lt;/span&gt;&quot;&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure><ul><li>使用分号<code>;</code>执行多个子命令： 其语法格式：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;sed &lt;span class=&quot;hljs-operator&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#x27;command1; command2...&#x27;&lt;/span&gt; filename&lt;/code&gt;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;&lt;span class=&quot;hljs-shebang&quot;&gt;#! /bin/bash<br>&lt;/span&gt;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#将全部小写字母 e 替换成大写字母 E，并打印第 1 行到第 3 行文本行&lt;/span&gt;<br>result=`sed -n &lt;span class=&quot;hljs-operator&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#x27;s/e/E/g; 1,3 p&#x27;&lt;/span&gt; test.txt`<br>&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$result&lt;/span&gt;&quot;&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure><ul><li>对同一个地址使用多个子命令： 其语法格式：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs r has-numbering&quot;&gt;address&#123;<br>    command1<br>    command2<br>    command3<br>    &lt;span class=&quot;hljs-keyword&quot;&gt;...&lt;/span&gt;<br>&#125;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#或&lt;/span&gt;<br>[address] &#123; command1;command2;command3;&lt;span class=&quot;hljs-keyword&quot;&gt;...&lt;/span&gt;&#125;&lt;/code&gt;<br></code></pre></td></tr></table></figure><h4 id="sed脚本文件">7)sed脚本文件</h4><p>可以将多个子命令写成后缀名为<code>.sed</code>的<code>sed</code>脚本文件，<code>sed</code>脚本文件内容只需将各个子命令依次列出来，不必使用引号，若将多个子命令写在同一行，则不同子命令之间需使用分号隔开。调用<code>sed</code>脚本文件的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;sed &lt;span class=&quot;hljs-operator&quot;&gt;-f&lt;/span&gt; script&lt;/code&gt;<br>&lt;pre&gt;<br><br></code></pre></td></tr></table></figure><h2 id="awk命令">10. awk命令</h2><h3 id="awk命令的基本语法">awk命令的基本语法</h3><p><code>awk</code>命令是一个文本处理工具，其基本语法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs mathematica has-numbering&quot;&gt;awk pattern &lt;span class=&quot;hljs-list&quot;&gt;&#123; actions &#125;&lt;/span&gt;&lt;/code&gt;<br></code></pre></td></tr></table></figure><p>其中，<code>pattern</code>表示匹配模式，<code>actions</code>表示要执行的操作；即对符合<code>pattern</code>匹配模式的文本行执行<code>actions</code>操作；若省略<code>pattern</code>匹配模式，则表示对所有文本行执行<code>actions</code>操作；若省略<code>pattern</code>匹配模式，则把匹配成功的文本行打印输出；但是不能同时省略<code>pattern</code>和<code>actions</code>。</p><p><code>pattern</code>匹配模式可以是以下其中一种：</p><ul><li>正则表达式；</li><li>关系表达式；</li><li>模式<code>1</code>，模式<code>2</code>：指定一行的范围；</li><li><code>BEGIN</code>：指定在第一行文本被处理之前所发生的操作；</li><li><code>END</code>：指定在最后一行文本被读取之后发送的操作；</li></ul><p><code>actions</code>命令由一个或多个命令、函数或者表达式组成，他们之间由换行符或分号隔开，并位于大括号内，一般有以下四种情况：</p><ul><li>变量或数组赋值；</li><li>输出命令，例如<code>printf</code>或<code>print</code>；</li><li>内置函数；</li><li>流控制语句，例如<code>if</code>、<code>while</code>或<code>for</code>语句；</li></ul><p><code>awk</code>命令的执行方式：</p><ul><li>通过命令行执行：其语法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;awk &lt;span class=&quot;hljs-string&quot;&gt;&#x27;awk程序语句&#x27;&lt;/span&gt; 数据文件&lt;/code&gt;<br></code></pre></td></tr></table></figure><ul><li>执行 <code>awk</code>脚本：其语法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;#注意：awk脚本文件是后缀名为.awk的文件&lt;/span&gt;<br>awk &lt;span class=&quot;hljs-operator&quot;&gt;-f&lt;/span&gt; awk脚本文件 数据文件&lt;/code&gt;<br></code></pre></td></tr></table></figure><ul><li>可执行脚本文件：即在<code>shell</code>文件中指定解析器为<code>#! /bin/awk -f</code></li></ul><h3 id="awk命令的匹配模式">awk命令的匹配模式</h3><p>在<code>awk</code>命令的匹配模式主要包括：关系表达式、正则表达式、混合模式、区间模式、<code>BEGIN</code>模式、<code>END</code>模式等。</p><h4 id="关系表达式"><strong>1) 关系表达式</strong></h4><p><code>awk</code>命令中的关系运算符如下表所示：</p><table><thead><tr class="header"><th>运算符</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>&gt;</td><td>大于</td></tr><tr class="even"><td>&gt;=</td><td>大于等于</td></tr><tr class="odd"><td>&lt;</td><td>小于</td></tr><tr class="even"><td>&lt;=</td><td>小于等于</td></tr><tr class="odd"><td>==</td><td>等于</td></tr><tr class="even"><td>!=</td><td>不等于</td></tr><tr class="odd"><td>~</td><td>匹配运算：例如<code>$1~/^A</code>表示匹配第一个字段以字符<code>A</code>开头的记录</td></tr><tr class="even"><td>!~</td><td>不匹配运算</td></tr></tbody></table><h4 id="正则表达式"><strong>2) 正则表达式</strong></h4><p><code>awk</code>支持以正则表达式为匹配模式，其基本语法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs vala has-numbering&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;#regexp 表示正则表达式&lt;/span&gt;<br>/regexp/&lt;/code&gt;<br></code></pre></td></tr></table></figure><p>例如：输出以字符u开头的文本行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;&lt;span class=&quot;hljs-shebang&quot;&gt;#! /bin/bash&lt;/span&gt;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#filename:test.sh&lt;/span&gt;<br><br>result=`awk &lt;span class=&quot;hljs-string&quot;&gt;&#x27;/^u/ &#123;print&#125;&#x27;&lt;/span&gt; shell.md`<br><br>&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$result&lt;/span&gt;&quot;&lt;/span&gt;<br><br>&lt;span class=&quot;hljs-comment&quot;&gt;#输出结果：&lt;/span&gt;<br>$ sh test.sh <br>&lt;span class=&quot;hljs-built_in&quot;&gt;unset&lt;/span&gt; variable_name<br>&lt;span class=&quot;hljs-built_in&quot;&gt;unset&lt;/span&gt; var<br>until<br>until<br>&lt;span class=&quot;hljs-built_in&quot;&gt;unset&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;-f&lt;/span&gt; 函数名&lt;/code&gt;<br></code></pre></td></tr></table></figure><h4 id="混合模式"><strong>3) 混合模式</strong></h4><p>在<code>awk</code>命令的匹配模式中，可以通过逻辑运算符使用多个表达式组成命令；基本逻辑运算符如下表所示：</p><table><thead><tr class="header"><th>运算符</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>&amp;&amp;</td><td>逻辑与</td></tr><tr class="even"><td>||</td><td>逻辑或</td></tr><tr class="odd"><td>!</td><td>逻辑非</td></tr></tbody></table><h4 id="区间模式"><strong>4) 区间模式</strong></h4><p><code>awk</code>命令支持区间模式，其语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs  has-numbering&quot;&gt;pattern1, pattern2&lt;/code&gt;<br></code></pre></td></tr></table></figure><p>例如：第一个匹配模式是：以字符串<code>one</code>开头的文本行；第二个匹配模式是：第<code>3</code>字段等于<code>14</code>的文本行；所有符合这两个匹配模式之间的文本行都会被输出；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs bash has-numbering&quot;&gt;&lt;span class=&quot;hljs-shebang&quot;&gt;#!/bin/bash&lt;/span&gt;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#filename:test.sh&lt;/span&gt;<br><br>result=`awk &lt;span class=&quot;hljs-string&quot;&gt;&#x27;/^one/ , $3==14 &#123;print&#125;&#x27;&lt;/span&gt; test.txt`<br><br>&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$result&lt;/span&gt;&quot;&lt;/span&gt;<br><br>&lt;span class=&quot;hljs-comment&quot;&gt;#执行结果：&lt;/span&gt;<br>$ sh test.sh <br>one     &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;<br>two     &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;25&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;<br>three   &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;31&lt;/span&gt;<br>four    &lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;26&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;35&lt;/span&gt;<br>five    &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;40&lt;/span&gt;<br>&lt;/code&gt;<br></code></pre></td></tr></table></figure><h4 id="begin模式"><strong>5) BEGIN模式</strong></h4><p><code>BEGIN</code>模式是<code>awk</code>命令一种特殊的内置模式，在<code>awk</code>读取数据之前对执行的操作；</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs livecodeserver has-numbering&quot;&gt;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#! /usr/bin/awk -f&lt;/span&gt;<br>&lt;span class=&quot;hljs-comment&quot;&gt;#filename:test.sh&lt;/span&gt;<br><br>BEGIN &#123; print &lt;span class=&quot;hljs-string&quot;&gt;&quot;Beging operator.&quot;&lt;/span&gt; &#125;<br>/^&lt;span class=&quot;hljs-constant&quot;&gt;one&lt;/span&gt;/ , $&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;==&lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt; &#123;print&#125;<br><br>&lt;span class=&quot;hljs-comment&quot;&gt;#执行结果：&lt;/span&gt;<br>$ ./test.sh test.txt<br>Beging operator.<br>&lt;span class=&quot;hljs-constant&quot;&gt;one&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;<br>&lt;span class=&quot;hljs-constant&quot;&gt;two&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;25&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;<br>&lt;span class=&quot;hljs-constant&quot;&gt;three&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;31&lt;/span&gt;<br>&lt;span class=&quot;hljs-constant&quot;&gt;four&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;26&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;35&lt;/span&gt;<br>&lt;span class=&quot;hljs-constant&quot;&gt;five&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;40&lt;/span&gt;<br>&lt;/code&gt;<br></code></pre></td></tr></table></figure><h4 id="end模式"><strong>6) END模式</strong></h4><p><code>END</code>模式是在处理完数据之后执行的操作；例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs asciidoc has-numbering&quot;&gt;#! /usr/bin/awk -f<br># /usr/bin/env awk -f<br>#filename:test.sh<br><br>BEGIN &#123;<br>&lt;span class=&quot;hljs-code&quot;&gt;    print &quot;Beging operator.&quot;&lt;/span&gt;<br>&lt;span class=&quot;hljs-code&quot;&gt;    print &quot;====================&quot;&lt;/span&gt;<br>&#125;<br>/^one/ , $3==14 &#123;print&#125;<br><br>END &#123;<br>&lt;span class=&quot;hljs-code&quot;&gt;    print &quot;====================&quot;&lt;/span&gt;<br>&lt;span class=&quot;hljs-code&quot;&gt;    print &quot;Ending operator.&quot;&lt;/span&gt;<br>&#125;<br><br><br>#执行结果：<br>$ ./test.sh test.txt<br>&lt;span class=&quot;hljs-header&quot;&gt;Beging operator.<br>====================&lt;/span&gt;<br>one     10  20  30<br>two     15  25  20<br>three   20  15  31<br>four    16  26  35<br>&lt;span class=&quot;hljs-header&quot;&gt;five    11  14  40<br>====================&lt;/span&gt;<br>Ending operator.<br>&lt;/code&gt;<br></code></pre></td></tr></table></figure><h3 id="awk-变量">awk 变量</h3><p><code>awk</code>中的用户自定义的变量一般在<code>BEGIN</code>模式中定义；</p><h4 id="系统内置变量">系统内置变量</h4><p><code>awk</code>的常用系统内置变量如下表所示：</p><table><colgroup><col style="width: 11%" /><col style="width: 88%" /></colgroup><thead><tr class="header"><th>变量</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>$0</td><td>当前记录（存放着整个行的内容）</td></tr><tr class="even"><td><span class="math inline">\(1~\)</span>n</td><td>当前记录的第n个字段，字段间由FS分隔</td></tr><tr class="odd"><td>FS</td><td>输入字段分隔符 默认是空格或Tab</td></tr><tr class="even"><td>NF</td><td>当前记录中的字段个数，就是有多少列</td></tr><tr class="odd"><td>NR</td><td>已经读出的记录数，就是行号，从1开始，如果有多个文件话，这个值也是不断累加中</td></tr><tr class="even"><td>FNR</td><td>当前记录数，与NR不同的是，这个值会是各个文件自己的行号</td></tr><tr class="odd"><td>RS</td><td>输入的记录分隔符， 默认为换行符</td></tr><tr class="even"><td>OFS</td><td>输出字段分隔符， 默认也是空格</td></tr><tr class="odd"><td>ORS</td><td>输出的记录分隔符，默认为换行符</td></tr><tr class="even"><td>FILENAME</td><td>当前输入文件的名字</td></tr></tbody></table><h4 id="运算符">运算符</h4><p><code>awk</code>命令支持常用的运算符：算术运算符、赋值运算符、条件运算符、逻辑运算法、关系运算符等操作；</p><p><strong>算术运算符</strong></p><p><code>awk</code>命令直接支持的算术运算符有：加+、减-、乘*、除/、模运算%、指数运算^；</p><p><strong>赋值运算符</strong></p><p><code>awk</code>命令常用的赋值运算符有：=、+=、-=、*=、/=、%=、^=；</p><p><strong>条件运算符</strong></p><p><code>awk</code>命令的条件运算符语法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;code class=&quot;hljs  has-numbering&quot;&gt;表达式?值1:值2&lt;/code&gt;<br></code></pre></td></tr></table></figure><p><strong>逻辑运算法</strong></p><p><code>awk</code>命令支持的逻辑运算符：&amp;&amp;、||、！；</p><p><strong>关系运算符</strong></p><p><code>awk</code>命令支持的关系运算符：&gt;、&gt;=、&lt;、&lt;=、==、！=、<sub>、!</sub>；</p><h4 id="awk-函数"><strong>awk 函数</strong></h4><p><code>awk</code>提供了许多系统函数，用户也可以自定义函数；</p><p><strong>字符串函数</strong></p><p>常用的字符串函数有：</p><table><colgroup><col style="width: 34%" /><col style="width: 65%" /></colgroup><thead><tr class="header"><th>函数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>index(string1, string2)</td><td>返回 string2 在string1中第一次出现的位置</td></tr><tr class="even"><td>length(string)</td><td>返回string的长度</td></tr><tr class="odd"><td>match(string,regexp)</td><td>返回string中符合regexp的子字符串</td></tr><tr class="even"><td>split(string,array,seperator)</td><td>根据分隔符seperator，将字符串string分隔成多个字段，并存储到数组array中</td></tr><tr class="odd"><td>sub(regexp,replacement,string)</td><td>将字符串string第一个符合regexp的子字符串替换成replacement</td></tr><tr class="even"><td>gsub(regexp,replacement,string)</td><td>将字符串string中符合regexp的全部子字符串都替换成replacement</td></tr><tr class="odd"><td>substr(string,start,[length])</td><td>从字符串string的start位置开始截取长度为length(若指定了length，否则一直截取到字符串string结束)字串</td></tr></tbody></table><p><strong>算术函数</strong></p><p>常用的算术函数有：int(x)、sqrt(x)、exp(x)、log(x)、sin(x)、cos(x)、rand(x)、srand(x)；2)</p><p>实例：</p><ul><li>$ awk '/^(no|so)/' test-----打印所有以模式no或so开头的行。</li><li>$ awk '/<a href="#fn1" class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a>/{print $1}'test-----如果记录以n或s开头，就打印这个记录。</li><li>$ awk '<span class="math inline">\(1 ~/[0-9][0-9]\)</span>/(print$1}' test-----如果第一个域以两个数字结束就打印这个记录。</li><li>$ awk '$1 == 100 || $2 &lt; 50'test-----如果第一个或等于100或者第二个域小于50，则打印该行。</li><li>$ awk '$1 != 10' test-----如果第一个域不等于10就打印该行。</li><li>$ awk '/test/{print $1 + 10}'test-----如果记录包含正则表达式test，则第一个域加10并打印出来。</li><li>$ awk '{print ($1 &gt; 5 ? "ok "$1: "error"$1)}'test-----如果第一个域大于5则打印问号后面的表达式值，否则打印冒号后面的表达式值。</li><li>$ awk '/<sup>root/,/</sup>mysql/'test----打印以正则表达式root开头的记录到以正则表达式mysql开头的记录范围内的所有记录。如果找到一个新的正则表达式root开头的记录，则继续打印直到下一个以正则表达式mysql开头的记录为止，或到文件末尾。</li></ul><h2 id="可执行文件elf">11. 可执行文件ELF</h2><h3 id="elf简介">ELF简介</h3><p>ELF文件除了包含程序本身的<strong>代码</strong>和<strong>静态数据</strong>之外，还包括一些用来<strong>描述它们的信息</strong>，否则我们连代码和数据之间的分界线在哪里都不知道。这些信息描述了可执行文件的组织形式,不同组织形式形成了不同格式的可执行文件,</p><p>Windows主流的可执行文件是PE(Portable Executable)格式</p><p>GNU/Linux主要使用ELF(Executable and LinkableFormat)格式。ELF是GNU/Linux可执行文件的标准格式,这是因为GNU/Linux遵循System V ABI(Application Binary Interface).</p><p><strong>为什么堆和栈的内容没有放入可执行文件里面?程序运行时刻用到的堆和栈又是怎么来的?</strong></p><p>ELF文件提供了两个视角来组织一个可执行文件。</p><p>一是面向链接过程的section视角，这个视角提供了用于链接与重定位的信息(例如符号表)。</p><p>二是面向执行的segment视角，这个视角提供了用于加载可执行文件的信息。</p><p>通过readelf命令,我们还可以看到section和segment之间的映射关系：一个segment可能由0个或多个section组成,但一个section可能不被包含于任何segment中。</p><p>ELF中采用<strong>program header table</strong>来管理segment, programheadertable的一个表项描述了一个segment的所有属性，包括<strong>类型</strong>,<strong>虚拟地址</strong>，<strong>标志</strong>，<strong>对齐方式</strong>，以及<strong>文件内偏移量</strong>和<strong>segment大小</strong>。根据这些信息,我们就可以知道需要加载可执行文件的哪些字节了，同时我们也可以看到，加载一个可执行文件并不是加载它所包含的所有内容，只要加载那些与运行时刻相关的内容就可以了,例如调试信息和符号表就不必加载。我们可以通过判断segment的Type属性是否为<strong>PT_LOAD</strong>来判断一个segment是否需要加载。更多与ELF文件相关的信息,请参考</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">man 5 elf<br></code></pre></td></tr></table></figure><h3 id="readelf命令">readelf命令</h3><p>readelf命令，一般用于查看ELF格式的文件信息，常见的文件如在Linux上的可执行文件，动态库(<em>.so)或者静态库(</em>.a)等包含ELF格式的文件。</p><p><strong>选项 -h</strong>(elfheader)，显示elf文件开始的文件头信息，如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">ELF Header:<br>  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 <br>  Class:                             ELF64<br>  Data:                              2<span class="hljs-string">&#x27;s complement, little endian</span><br><span class="hljs-string">  Version:                           1 (current)</span><br><span class="hljs-string">  OS/ABI:                            UNIX - System V</span><br><span class="hljs-string">  ABI Version:                       0</span><br><span class="hljs-string">  Type:                              EXEC (Executable file)</span><br><span class="hljs-string">  Machine:                           RISC-V</span><br><span class="hljs-string">  Version:                           0x1</span><br><span class="hljs-string">  Entry point address:               0x80000000</span><br><span class="hljs-string">  Start of program headers:          64 (bytes into file)</span><br><span class="hljs-string">  Start of section headers:          50496 (bytes into file)</span><br><span class="hljs-string">  Flags:                             0x4, double-float ABI</span><br><span class="hljs-string">  Size of this header:               64 (bytes)</span><br><span class="hljs-string">  Size of program headers:           56 (bytes)</span><br><span class="hljs-string">  Number of program headers:         2</span><br><span class="hljs-string">  Size of section headers:           64 (bytes)</span><br><span class="hljs-string">  Number of section headers:         13</span><br><span class="hljs-string">  Section header string table index: 12</span><br></code></pre></td></tr></table></figure><p><strong>选项 -l</strong>(program headers),segments显示程序头（段头）信息(如果有数据的话)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">Elf file <span class="hljs-built_in">type</span> is EXEC (Executable file)<br>Entry point 0x80000000<br>There are 2 program headers, starting at offset 64<br><br>Program Headers:<br>  Type           Offset             VirtAddr           PhysAddr<br>                 FileSiz            MemSiz              Flags  Align<br>  LOAD           0x0000000000001000 0x0000000080000000 0x0000000080000000<br>                 0x000000000000a6c8 0x0000000000014028  RWE    0x1000<br>  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000<br>                 0x0000000000000000 0x0000000000000000  RW     0x10<br><br> Section to Segment mapping:<br>  Segment Sections...<br>   00     .text .rodata .sdata2.__func__.1497 .sdata2.mainargs .data .data.heap .data.lut .bss <br>   01     <br></code></pre></td></tr></table></figure><p>找出每一个需要加载的segment的<strong>Offset</strong>，<strong>VirtAddr</strong>，<strong>FileSiz</strong>和<strong>MemSiz</strong>这些参数。<strong>相对文件偏移Offset指出相应segment的内容从ELF文件的第Offset字节开始,在文件中的大小为FileSiz, 它需要被分配到以VirtAddr为首地址的虚拟内存位置,在内存中它占用大小为MemSiz。</strong>也就是说，这个segment使用的内存就是[VirtAddr, VirtAddr +MemSiz)这一连续区间，然后将segment的内容从ELF文件中读入到这一内存区间，<strong>并将[VirtAddr+ FileSiz, VirtAddr + MemSiz)对应的物理区间清零。</strong></p><p>关于程序从何而来, 可以参考一篇文章: <ahref="https://www.tenouk.com/ModuleW.html">COMPILER, ASSEMBLER, LINKERAND LOADER: A BRIEF STORY</a></p><section id="footnotes" class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"><p>ns<a href="#fnref1" class="footnote-back"role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;添加环境变量&quot;&gt;&lt;strong&gt;1.添加环境变量&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;https://www.cnblogs.com/youyoui/p/10680329.html&lt;/p&gt;
&lt;p&gt;1、Linux的环境变量是保存在变量PATH中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;export&lt;/strong&gt;命令显示当前系统定义的所有环境变量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;echo $PATH&lt;/strong&gt;命令输出当前的PATH环境变量的值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、Linux环境变量值之间是通过冒号分隔的( : )&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;临时添加环境变量PATH：&lt;/strong&gt;可通过export命令，如将/usr/local/nginx/sbin/目录临时添加到环境变量中&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;export&lt;/span&gt; PATH=/usr/local/nginx/sbin/:&lt;span class=&quot;hljs-variable&quot;&gt;$PATH&lt;/span&gt;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://zmailee.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>DPI学习笔记</title>
    <link href="https://zmailee.github.io/2022/10/30/DPI/"/>
    <id>https://zmailee.github.io/2022/10/30/DPI/</id>
    <published>2022-10-30T14:39:30.544Z</published>
    <updated>2022-10-31T04:20:01.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dpi学习笔记">DPI学习笔记</h1><h2 id="一dpi前世-pli">一、DPI前世-PLI</h2><p>首先思考几个问题：</p><ul><li><p>用户如何获得Verilog描述的电路的内部<strong>数据结构信息</strong>?</p></li><li><p>EDA仿真器在仿真verilog的tb时，FSDB波形是如何生成的？</p></li><li><p>$display，$stop，$finish等系统函数,如何被不同EDA仿真器识别?</p></li></ul><p>除了底层描述硬件的能力，Verilog同样应该具有与上层交互的能力，基于此<strong>VerilogPLI</strong>(Programming LanguageInterface)应运而生，它是一种从Verilog代码调用C/C++函数的机制。可以说PLI的出现是Verilog语言在硬件设计方面如此成功的原因之一。使用PLI，第三方公司和最终用户可以扩展商业Verilog仿真器的功能。在Verilog代码中调用的函数称为<strong>系统调用</strong>。内置系统函数的一个示例是$display，$stop，$finish等。PLI允许用户创建自定义系统调用，这是Verilog语法不允许我们做的事情。基于PLI其实我们可以做的更多：</p><span id="more"></span><ul><li>功耗分析</li><li>代码覆盖率工具</li><li>修改Verilog仿真数据结构 - 更准确的延迟。</li><li>自定义输出显示</li><li>协同仿真。</li><li>设计调试工具。</li><li>仿真结果分析</li><li>C模型接口加速仿真</li><li>Testbench建模</li></ul><p>为了实现PLI的这些应用，C代码应该可以访问Verilog仿真器的内部数据结构。为方便起见，VerilogPLI提供了一些称为acc例程或简单访问例程的东西。还有第二组例程，称为tf例程，或简称为任务和函数例程。tf和acc是PLI 1.0例程，并且非常庞大且陈旧。</p><h3 id="vpi">VPI</h3><p>Verilog程序接口（VPI），最初称为PLI2.0，主要用于C编程语言的接口。它允许行为Verilog代码调用C函数，C函数调用标准Verilog系统任务。Verilog程序接口是IEEE1364编程语言接口标准的一部分;该标准的最新版本是从2005年开始的。VPI也取代了已弃用的PLI。</p><p>虽然PLI1被弃用而支持VPI（又名PLI2），但由于其广泛记录的tf_put，tf_get函数接口在许多verilog参考书中有所描述，因此PLI1仍常用于VPI。</p><p>综上所述：PLI有三个libraries, TF(task/function) interface,ACC(access) interface, 以及VPI(Verilog ProceduralInterface)，三者的时间先后顺序是1985-1989-1995而前面两个已经在IEEE1364-2005中被删除。</p><h3 id="pli的应用和维护问题">PLI的应用和维护问题</h3><p>写PLI例程，是件痛苦的事情，不仅需要好几个步骤，更让人头痛的是PLI三个库中提供的一大堆难记的标准例程名字。写完了，还必须再用checktf例程，calltf例程包一层，才能在verilog中调用。另外一个问题，就是谁来负责写这些PLI例程，通常情况下，不管是设计者还是验证人员通常都不需要了解仿真器生成的verilog数据结构。我们只是使用者，不是生产者。</p><p>编写PLI应用程序很难</p><ul><li>必须学习奇怪的PLI术语</li><li>必须了解PLI库中的内容</li><li>必须创建checktf例程，calltf例程等</li></ul><p>将PLI应用程序链接到仿真器很难</p><ul><li>涉及多个步骤</li><li>每个仿真器都不同</li><li>谁链接？设计工程师 or EDA工程师？</li><li>管理多个PLI应用程序很困难</li><li>PLI代码很少与二进制兼容</li><li>必须为每个仿真器重新编译</li></ul><p>综上，PLI的缺点它严重阻碍着设计者和验证者使用更高级的语言来加强verilog语言的功力，尤其是日益复杂的设计和验证工作迫切需要一种新的编程语言接口，为我们提供强大的生产力的时候。</p><p>SystemVerilog引入了<strong>DPI(Direct ProgrammingInterface</strong>)，能够更简洁的连接C/C++或者其他非<ahref="https://so.csdn.net/so/search?q=Verilog&amp;spm=1001.2101.3001.7020">Verilog</a>的编程语言。</p><h2 id="二dpi横空出世">二、DPI横空出世</h2><p>在2003年IEEE 1800 SV LRM3.1a中提出了一种直接的编程语言接口DPI。SystemVerilogDPI是将SystemVerilog与外部语言连接的一个接口。理论上外部语言可以是C，C++，SystemC以及其他语言。但是现在，SystemVerilog仅为C语言定义了一个外部语言层。</p><p>DPI由两层组成：SystemVerilog层和外部语言层。两层都彼此隔离。实际使用哪种编程语言作为外语是透明的，与此接口的SystemVerilog端无关。</p><p>DPI标准源自两个专有接口，一个来自Synopsys公司的VCSDirectC接口，另一个是来自Co-Design公司（已被Synopsys收购）的SystemSimCblend接口。这两个专有接口起初是为他们各自的仿真器开发的，而不是一个能够工作在任何仿真器上的标准。后来Synopsys公司将这两个技术捐献给了Accellera组织，Accellera的SystemVerilog标准委员会把这两个捐献技术合并在一起，并定义了DPI接口的语义，使得DPI能够与任何Verilog仿真器一起工作。</p><h3 id="两者之间的关系">两者之间的关系</h3><p>DPI不是PLI的替代品。相反，他们的角色是互补的。PLI和VPI将来会继续存在并蓬勃发展，这主要有两个原因。</p><ul><li>PLI和VPI是经过时间考验的方法确保了对仿真器数据库的保护。PLI和VPI将继续提供访问设计数据的安全机制，同时保持仿真器数据库的完整性。</li><li>对于许多人来说，PLI在未来几年仍将是首选接口语言。有许多应用程序使用PLI和VPI编写。将维护这些遗留应用程序，创建新的附加组件，并且将出现全新的应用程序-全部使用PLI和VPI。在Accellera决定对整个SystemVerilog语言提供完整的VPI支持时，PLI也就证明了其顽强的生命力。你熟悉和喜爱的VPI方法现在将适用于SystemVerilog的整个对象集。</li></ul><h2 id="三为什么需要dpi">三、为什么需要DPI？</h2><p>DPI出现的动机是双重的。</p><p>方法论要求接口应该允许<strong>构建异构系统</strong>（设计或测试平台），其中一些组件可以用除SystemVerilog之外的语言（或更多语言）编写。</p><p>另一方面，需要一种简单有效的方法来连接通常用C或C++编写的现有代码，而不需要PLI或VPI的知识开销。</p><p><strong>DPI遵循黑盒的原则</strong>：组件的规范和实现明确分开，实际实现对系统的其余部分是透明的。因此，实现的实际编程语言也是透明的，尽管该标准仅定义了C链接语义。SystemVerilog代码与外部语言之间的分离基于使用函数作为SystemVerilog中的自然封装单元。总的来说，任何函数都可以被视为一个黑盒子，并以透明的方式在SystemVerilog或外部语言中实现，而无需更改其调用。</p><p>现实世界中，C和C++应该是IC世界，最被广泛使用的高级编程语言，而且有很多开源的代码和工具都是C或者C++代码编写。按照DPI的方法论，我们理应为C和C++世界通往SV世界打开一扇门。</p><p>DPI是在SystemVerilog LRM 3.1a 2003中定义的关键字DPI-C是在SystemVerilog IEEE 1800-2012中定义的关键字</p><p>目前DPI已弃用，应替换为DPI-C</p><p>DPI-C的出现使得SV和C之间的互动变得简单直接</p><ul><li>使用C函数作为SV函数/任务，反之亦然</li><li>直接调用C/C++库中的函数</li><li>直接将输入传递给函数</li><li>直接从C/C++函数接收返回值</li></ul><p>其是在验证领域，使用C/C++代码作为参考模型很普遍</p><ul><li>使用功能强大的OpenSSL、OpenCV等开源库</li><li>参考模型是由设计师或软件团队使用C/C++编写的</li><li>使用MATLAB生成DPI组件</li></ul><p>SystemVerilog可以调用C，C可以调用SV</p><ul><li>支持函数和任务</li><li>在协同仿真中很有用</li></ul><p>（1）在模块级乃至子系统级的验证，使用SV就完全够用了，而在更上面的层级，例如系统级，多采用大量的C代码组成。那么<strong>为了完成测试用例从子系统到系统级的复用</strong>，我们最好在子系统级开始就有意识地建立支持C测试的环境，并且使用一些基于C的测试用例，这样才能使得整体具有更好的复用性。</p><p>（2）处理器的需要。子系统测试时，不一定本身自带了处理器的硬件实例(Verilog编写的)，因此在构建子系统时还要考虑如何模拟外部处理器对子系统的访问行为。当然，我们直接加上一个外部的处理器实例是完全可以的，等验证完子系统的功能后再撤掉就行。注意，这个处理器实例也是verilog编写的。但是，这种方法也存在了一些弊端：即使这个外部处理器再小巧，但硬件体积还是过大了，肯定会影响整个仿真的速度；针对不同子系统的预留接口(APB/AHB/AXI等)，处理器子系统也要进行对应的调整吧；这种真实的处理器，必然要处理C代码，所以要进行编译、转换成二进制bin文件以及下载到memory中，还是太麻烦；还需要额外的启动配置文件，而且仿真时需要额外的额时间进行初始化。总结一下真实处理器的弊端，那就是麻烦，处理C代码也繁琐，影响了仿真速度。</p><h2 id="四dpi基础">四、DPI基础</h2><h3 id="数据类型转换">4.1数据类型转换</h3><h4 id="数据映射关系">数据映射关系</h4><p>当SV与C环境交互时，会发生数据交换。数据需要在两端以完全相同的方式解释，否则通信将失败。SystemVerilog和C之间的数据交换通常使用DPI-C接口完成，该接口标准化类型对应关系和基本API（另请参见仿真器安装路径下的svdpi.h）。</p><p>大多数SystemVerilog数据类型在C语言中具有直接的对应关系，而其他（例如，4值类型，数组）需要DPI-C定义的类型和API。</p><p>通过DPI传递的每个变量都有两个相匹配的定义，一个在SV中，一个在C语言中。在使用中必须，确认使用的是兼容的数据类型。<strong>C输出数据给SV，只能通过指针的方式输出</strong>。所以输出数据也是在SV中建立空间，然后在C中得到指针，将值写进去，这样C的内存空间的控制不会影响到SV端。</p><table><colgroup><col style="width: 37%" /><col style="width: 32%" /><col style="width: 30%" /></colgroup><thead><tr class="header"><th style="text-align: left;">SystemVerilog</th><th>C(input)</th><th>C(output)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">byte</td><td>char</td><td>char*</td></tr><tr class="even"><td style="text-align: left;">shortint</td><td>short int</td><td>short int*</td></tr><tr class="odd"><td style="text-align: left;">int</td><td>int</td><td>int*</td></tr><tr class="even"><td style="text-align: left;">longint</td><td>long int</td><td>long int*</td></tr><tr class="odd"><td style="text-align: left;">shortreal</td><td>float</td><td>float*</td></tr><tr class="even"><td style="text-align: left;">real</td><td>double</td><td>double*</td></tr><tr class="odd"><td style="text-align: left;">string</td><td>const char*</td><td>char**</td></tr><tr class="even"><td style="text-align: left;">string[n]</td><td>const char**</td><td>char**</td></tr><tr class="odd"><td style="text-align: left;">bit</td><td>svBit(unsigned char)</td><td>svBit*(unsigned char)</td></tr><tr class="even"><td style="text-align: left;">logic, reg</td><td>svLogic</td><td>svLogic*</td></tr><tr class="odd"><td style="text-align: left;">bit[N:0]</td><td>const svBitVecVal*</td><td>svBitVecVal*</td></tr><tr class="even"><td style="text-align: left;">logic[N:0], reg[N:0]</td><td>const svLogicVecVal*</td><td>svLogicVecVal*</td></tr><tr class="odd"><td style="text-align: left;">Open array[] (import only)</td><td>const svOpenArrayHandle</td><td>svOpenArrayHandle</td></tr><tr class="even"><td style="text-align: left;">chandle</td><td>const void*</td><td>void*</td></tr></tbody></table><p>DPI调入C函数返回值，SV LRM推荐使用<strong>small values</strong>：void,byte,shortint,int,longint,real,shortreal,chandle,string,bit,logic</p><p>不推荐使用bit[6:0]或者logic[6:0]这样的值，因为这样需要返回一个svBitVecVal或者svLogicVecVal的指针。</p><h4 id="四值逻辑变量转换关系"><strong>四值逻辑变量转换关系</strong></h4><p>假设SV一侧有一个logicf，那么它在C一侧，会用一个无符号的字节来保存。分为aval和bval，其中aval保存在最低位，bval保存在紧邻的高位。</p><table><thead><tr class="header"><th>四状态值</th><th>bval</th><th>aval</th></tr></thead><tbody><tr class="odd"><td>0</td><td>0</td><td>0</td></tr><tr class="even"><td>1</td><td>0</td><td>1</td></tr><tr class="odd"><td>Z</td><td>1</td><td>0</td></tr><tr class="even"><td>X</td><td>1</td><td>1</td></tr></tbody></table><p>1’b0 -&gt; 0x0，1’b1 -&gt; 0x1，1’bz -&gt; 0x2，1’bx -&gt; 0x3</p><p>logic[31:0]word，采用一对32bit的变量来表示，aval[31:0]与bval[31:0]。</p><p>在导入数组时，需要同时赋值aval和bval，如data[31:0]，例如要将data[0]=1，那么需要data[0].aval=1,data[0].bval=0;</p><h3 id="接口调用">4.2接口调用</h3><p>通过import声明C任务和函数的原型：</p><ul><li><strong>带有返回值</strong>的C函数被映射成一个sv的<strong>function</strong></li><li><strong>void类型</strong>的C函数被映射为一个sv的<strong>task</strong>或<strong>voidfunction</strong></li></ul><p>如果C函数名和SV中的命名冲突，可以在import导入时，赋予新的函数名。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> test(); <br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> test=<span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_test(); <span class="hljs-comment">//将C中的test-&gt;my_test</span><br></code></pre></td></tr></table></figure><h4 id="参数传递">参数传递</h4><p>在C和SV中有两种传递参数的方法：</p><ul><li>按值传递：被调用者函数将使用来自调用者的参数的副本</li><li>通过引用传递：被调用者函数将使用来自调用者的参数的指针/引用</li></ul><p>如果函数正在更改其参数的值，则仅当参数通过引用传递时，更改才会在函数外部可见。当参数按值传递时，对函数内部完成的参数的任何更改都不会在其外部可见。</p><p>在SystemVerilog中，按值或按引用传递由参数方向确定。在C中，通过值或引用传递是由参数类型是否为指针确定的。默认情况下，SV和C都按值传递参数。</p><p>导入的C函数参数可以作为输入，输出或inout（双向）</p><ul><li>输入的行为就像在调用时复制到C函数中一样，C函数不应修改输入参数</li><li>当函数返回时，输出的行为就像复制到Verilog中一样</li><li>Inouts的行为就像在调用中复制一样，并在返回时复制出来</li></ul><p>除非另有说明，否则假定参数为输入</p><p>SV提供了丰富的数据类型可以作为参数：</p><ul><li>void, byte, shortint, int, longint, real, shortreal, chandle, time,integer, and string</li><li>Scalar values of type bit and logic</li><li>Packed arrays, structs, and unions composed of types bit andlogic</li><li>Types constructed from the supported types with the help of theconstructs: struct , union , Unpacked array , typedef</li></ul><p>返回值数据类型：</p><ul><li>void, byte, shortint, int, longint, real, shortreal, chandle, andstring</li><li>Scalar values of type bit and logic</li><li>Restrictions apply for import and export functions</li></ul><h4 id="参数方向">参数方向</h4><blockquote><p>对于参数方向，支持<strong>input,output以及inout</strong>。<strong>Ref则不被支持</strong>。<strong>默认是input</strong></p><p>例子：Import “DPI-C” function int add(input int a, b, output intsum);</p></blockquote><h4 id="导入方式"><strong>导入方式</strong></h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">import</span> “DPI-C” <span class="hljs-keyword">context</span> <span class="hljs-keyword">task</span> core0_thread();<br></code></pre></td></tr></table></figure><ul><li><p>pure：函数严格根据输入来计算输出，跟外部环境没有其它交互。作为pure函数，函数的结果必须仅仅依赖于通过形参传递进来的数值。优点在于仿真器可以执行优化以改进仿真性能。Pure函数不能使用全局或者静态变量，不能执行文件I/O操作，不能访问操作系统环境变量，不能调用来自VerilogPLI库的函数。<strong>只有没有输出或者inout的非void函数（必须有return值）可以被指定成pure。Pure函数不能作为Verilog任务导入。</strong></p></li><li><p>context：表示的是<strong>关联导入</strong>，关联类型会导致额外的开销。contextC函数明确函数声明所在工作域的Verilog的层次。可以是void函数，可以有输出和inout参数，可以从C库调用函数（用于文件I/O等)，可以调用PLI库中的许多函数，这使得被导入的C函数能够调用来自PLI或者VPI库的函数，从而DPI函数可以充分利用PLI的优势特性，比如写仿真器的log文件以及Verilog源代码打开的文件。</p></li><li><p>generic：函数使用了全局变量，但没有调用任何的PLI（缺省下为此类型）。本文把那些既没有明确声明为pure，也没有声明为context的函数称为generic函数(SystemVerilog标准没有给除了pure或context之外的函数特定的称呼)。genericC函数可以作为Verilog函数或者Verilog任务导入。任务或者函数可以由输入、输出以及inout的参数。函数可以有一个返回值，或者声明为void。genericC函数不允许调用VerilogPLI函数，不能访问除了参数以外的任何数据，只能修改这些参数。</p></li></ul><p><strong>正确的声明导入的函数为pure还是context是用户的责任</strong>。缺省情况下，DPI函数假定是generic函数。调用一个不正确声明成pure的C函数可能返回不正确或者不一致的结果，导致不可预测的运行时错误，甚至于让仿真崩溃。同样，如果一个C函数访问VerilogPLI库或者其他API库，却没有声明为context函数，会导致不可预见的仿真结果甚至仿真崩溃。</p><h4 id="导出方式"><strong>导出方式</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">export “DPI-C” function sv_display;<br></code></pre></td></tr></table></figure><p>注意后面不需要加括号和参数，如果需要改变名字，则可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">export “DPI-C” dpi_writew = task writew;<br></code></pre></td></tr></table></figure><p>而在C一侧，则只需要extern void sv_display();</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> dpi_writew(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> addr, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> data);<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> dpi_readw(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> addr, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *data);<br></code></pre></td></tr></table></figure><h4 id="绑定别名">绑定别名</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> gloval_name_space;<br>    <span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span>  <span class="hljs-keyword">context</span> <span class="hljs-keyword">task</span> sv_import_task ();<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> gloval_name_space1;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span>  <span class="hljs-keyword">context</span> C_task1=<span class="hljs-keyword">task</span> sv_import_task ();<br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-keyword">module</span> gloval_name_space2;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span>  <span class="hljs-keyword">context</span> C_task2=<span class="hljs-keyword">task</span> sv_import_task ();<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">export</span> <span class="hljs-string">&quot;DPI-C&quot;</span> f_plus = <span class="hljs-keyword">function</span> f ; <span class="hljs-comment">// &quot;f&quot; exported as &quot;f_plus&quot;</span><br><span class="hljs-keyword">export</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-keyword">function</span> f; <span class="hljs-comment">// &quot;f&quot; exported under its own name</span><br></code></pre></td></tr></table></figure><p>C的命名空间是全局可见的。sv_import_task中的声明变为等于C的链接名称。对于所有模块，名称必须是唯一的。 C的链接是全局性的。因此，上面是一种别名C链接名称的方法。SV上的名称相同，但在C上，使用别名C_task1和C_task2执行链接。</p><h4 id="dpi-各种使用方式">DPI 各种使用方式</h4><ul><li>通过import定义的函数可以在任何位置</li><li>在Verilog模块中</li><li>在SystemVerilog interface中</li><li>在SystemVerilog package中</li><li>在SystemVerilog“编译单元”中</li><li>import声明必须具有参数的原型</li><li>必须与C函数中的参数数完全匹配</li><li>必须指定兼容的数据类型</li><li>可以在多个位置导入相同的C功能</li><li>每个原型必须完全相同</li><li>更好的方法是在包中定义一个导入</li></ul><h3 id="常用数据类型映射">4.3常用数据类型映射</h3><ul><li>SV byte -&gt; C char</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_byte(input byte i_value, output byte result);<br>import &quot;DPI-C&quot; function byte get_byte(input byte i_value);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_byte</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> i_value, <span class="hljs-type">char</span>* result)</span>;<br><span class="hljs-type">char</span> <span class="hljs-title function_">get_byte</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> i_value)</span>;<br></code></pre></td></tr></table></figure><ul><li>SV shortint -&gt; C short int</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_shortint(input shortint i_value, output shortint result);<br>import &quot;DPI-C&quot; function shortint get_shortint(input shortint i_value);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_shortint</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> i_value, <span class="hljs-type">short</span> <span class="hljs-type">int</span>* result)</span>;<br><span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_shortint</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> i_value)</span>;<br></code></pre></td></tr></table></figure><ul><li>SV int -&gt; C int</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_int(input int i_value, output int result);<br>import &quot;DPI-C&quot; function int get_int(input int i_value);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_int</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> i_value, <span class="hljs-type">int</span>* result)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">get_int</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> i_value)</span>;<br></code></pre></td></tr></table></figure><ul><li>SV longint -&gt; C long int</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_longint(input longint i_value, output longint result);<br>import &quot;DPI-C&quot; function longint get_longint(input longint i_value);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_longint</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> i_value, <span class="hljs-type">long</span> <span class="hljs-type">int</span>* result)</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_longint</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> i_value)</span>;<br></code></pre></td></tr></table></figure><ul><li>SV real -&gt; C double</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_real(input real i_value, output real result);<br>import &quot;DPI-C&quot; function real get_real(input real i_value);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_real</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> i_value, <span class="hljs-type">double</span>* result)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">get_real</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> i_value)</span>;<br></code></pre></td></tr></table></figure><ul><li>SV string -&gt; C char*</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_string(input string i_value, output string result);<br>import &quot;DPI-C&quot; function string get_string(input string i_value);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_string</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* i_value, <span class="hljs-type">char</span>** result)</span>;<br><span class="hljs-type">char</span>* <span class="hljs-title function_">get_string</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* i_value)</span>;<br></code></pre></td></tr></table></figure><ul><li>SV chandle -&gt; C void*</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_chandle(output chandle result);<br>import &quot;DPI-C&quot; function chandle get_chandle();<br>import &quot;DPI-C&quot; function void call_chandle(input chandle i_value, output int result);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_chandle</span><span class="hljs-params">(<span class="hljs-type">void</span>** result)</span>;<br><span class="hljs-type">void</span>** <span class="hljs-title function_">get_chandle</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">call_chandle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* i_value, <span class="hljs-type">int</span>* o_value)</span>;<br></code></pre></td></tr></table></figure><ul><li>SV bit -&gt; C svbit</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_bit(input bit i_value, output bit result);<br>import &quot;DPI-C&quot; function bit get_bit(input bit i_value);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_bit</span><span class="hljs-params">(<span class="hljs-type">const</span> svBit i_value, svBit* result)</span>;<br>svBit <span class="hljs-title function_">get_bit</span><span class="hljs-params">(<span class="hljs-type">const</span> svBit i_value)</span>;<br></code></pre></td></tr></table></figure><ul><li>SV bit[n:0] -&gt; C svBitVecVal</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_bit_vector(input bit[`BIT_ARRAY_SIZE - 1 : 0] i_val, output bit[`BIT_ARRAY_SIZE - 1 : 0] result);<br>import &quot;DPI-C&quot; function bit[`BIT_ARRAY_SIZE - 1 : 0] get_bit_vector(input bit[`BIT_ARRAY_SIZE - 1 : 0] i_val);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_bit_vector</span><span class="hljs-params">(<span class="hljs-type">const</span> svBitVecVal* i_value, svBitVecVal* result)</span>;<br>svBitVecVal <span class="hljs-title function_">get_bit_vector</span><span class="hljs-params">(<span class="hljs-type">const</span> svBitVecVal* i_value)</span>;<br></code></pre></td></tr></table></figure><ul><li>SV logic -&gt; C svLogic</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_logic(input logic i_value, output logic result);<br>import &quot;DPI-C&quot; function logic get_logic(input logic i_value);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_logic</span><span class="hljs-params">(<span class="hljs-type">const</span> svLogic i_value, svLogic* result)</span>;<br>svLogic <span class="hljs-title function_">get_logic</span><span class="hljs-params">(<span class="hljs-type">const</span> svLogic i_value)</span>;<br></code></pre></td></tr></table></figure><ul><li>SV reg -&gt; C svLogic</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_reg(input reg i_value, output reg result);<br>import &quot;DPI-C&quot; function reg  get_reg(input reg i_value);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_reg</span><span class="hljs-params">(<span class="hljs-type">const</span> svLogic i_value, svLogic* result)</span>;<br>svLogic <span class="hljs-title function_">get_reg</span><span class="hljs-params">(<span class="hljs-type">const</span> svLogic i_value)</span>;<br></code></pre></td></tr></table></figure><ul><li>SV logic[n:0] -&gt; C svLogicVecVal</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_logic_vector(input logic[`LOGIC_ARRAY_SIZE - 1 : 0] i_val, output logic[`LOGIC_ARRAY_SIZE - 1 : 0] result, input int asize);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br>svLogicVecVal*  <span class="hljs-title function_">get_logic_vector</span><span class="hljs-params">(<span class="hljs-type">const</span> svLogicVecVal* i_value, <span class="hljs-type">int</span> asize)</span>;<br></code></pre></td></tr></table></figure><ul><li>SV reg[n:0] -&gt; C svLogicVecVal</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_reg_vector(input reg[\`REG_ARRAY_SIZE - 1 : 0] i_val, output reg[\`REG_ARRAY_SIZE - 1 : 0] result, input int asize);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_reg_vector</span><span class="hljs-params">(<span class="hljs-type">const</span> svLogicVecVal* i_value, svLogicVecVal* result, <span class="hljs-type">int</span> asize)</span>;<br></code></pre></td></tr></table></figure><ul><li>SV int[] -&gt; C svOpenArrayHandle</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>import &quot;DPI-C&quot; function void compute_unsized_int_array(input int i_value[], output int result[]);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_unsized_int_array</span><span class="hljs-params">(<span class="hljs-type">const</span> svOpenArrayHandle i_value, svOpenArrayHandle result)</span>;<br></code></pre></td></tr></table></figure><ul><li>SV struct -&gt; C struct</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">// SV<br>`define BIT_ARRAY_SIZE 16<br>typedef struct &#123;<br>byte aByte;<br>int anInt;<br>bit aBit;<br>longint aLongInt;<br>bit[`BIT_ARRAY_SIZE-1:0] aBitVector;<br>&#125; dpi_c_ex_s;<br>import &quot;DPI-C&quot; function void compute_struct(input dpi_c_ex_s i_value, output dpi_c_ex_s result);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dpi_c_ex_s</span> &#123;</span><br><span class="hljs-type">char</span> aChar;<br><span class="hljs-type">int</span> anInt;<br>svBit aBit;<br><span class="hljs-type">long</span> <span class="hljs-type">int</span> aLongInt;<br>svBitVecVal aBitVector;<br>&#125; dpi_c_ex_s;<br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_struct</span><span class="hljs-params">(<span class="hljs-type">const</span> dpi_c_ex_s* i_value, dpi_c_ex_s* output)</span>;<br></code></pre></td></tr></table></figure><h2 id="五dpi进阶">五、DPI进阶</h2><h4 id="压缩数组packed-arrays">5.1压缩数组（Packed arrays）</h4><p>压缩数组被视为数组和单个值，既可以访问整个值，也可以将其分成更小的元素。与非压缩的数组不同，它存储为一组连续的没有未使用空间的位。可以方便地将其作为数组元素进行访问。</p><p><strong>压缩数组：在数据类型标识符名称之前声明的维度</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">bit [7:0] p; // packed array of scalar bit types<br>bit [3:0][7:0] bytes // 4 bytes packed into 32-bits<br></code></pre></td></tr></table></figure><p>具有预定义宽度的整数类型不能声明为带维度的压缩数组。这些类型是byte，shortint，int，longint，integer和time。虽然是具有预定义宽度n的整数类型，它不是一个打包数组，但其自身是可以分解为子字段的，可以理解为一个具有单个[n-1:0]维度的压缩数组类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">byte c2; // same as bit signed [7:0] c2;`<br>integer i1; // same as logic signed [31:0] i1;<br></code></pre></td></tr></table></figure><h4 id="非压缩数组unpacked-arrays">5.2非压缩数组（Unpacked arrays）</h4><p>非压缩数组可以由任何数据类型组成。每个固定大小的维度应由地址范围[0:size-1]或单个正数[size]表示，以指定固定大小的非压缩数组的大小。</p><p><strong>非压缩数组：在数据类型标识符名称后声明的维度</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">bit u [7:0];<br>int Array[0:7][0:31]; // array declaration using ranges<br>int Array[8][32]; // array declaration using sizes<br></code></pre></td></tr></table></figure><p>SV 索引 [min：max] -&gt; C端数组索引从0开始</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">SV: a[1:7] -&gt; C: a[7]<br>SV: a[1] -&gt; C: a[0], SV a[7] -&gt; C: a[6]<br></code></pre></td></tr></table></figure><p>SV压缩数组被当做一维数组对待</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">//SV: a[l][m][n] -&gt; C: a[n+m*k+l*j*k]<br>bit[5:2]a; a[5]=1 a[4]=0 a[3]=1 a[2]=0; -&gt; C: a=10<br></code></pre></td></tr></table></figure><p><strong>所有数据类型最终都等同于最多32位的压缩数组</strong> SV byte-&gt; C int，只使用低8位 <strong>C char数组无法映射到SVbyte类型的非压缩数组</strong></p><h4 id="混合压缩和非压缩的数组">5.3混合压缩和非压缩的数组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">bit [3:0] Bytes [0:2] [0:5]<br></code></pre></td></tr></table></figure><figure><img src="DPI.assets/bfa1d0786bdd9d9435609c5734afe49a.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4id="sv_packed_data_nelemswidth">5.4SV_PACKED_DATA_NELEMS（width）</h4><p>该宏将位转换为元素数，在bit和word之间转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">include <span class="hljs-string">&quot;svdpi.h&quot;</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">packet_C</span><span class="hljs-params">(<span class="hljs-type">const</span> svLogicVecVal* packet)</span> &#123;<br>   <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span>  elements=SV_PACKED_DATA_NELEMS(<span class="hljs-number">128</span>);<br>   svLogicVecVal mem[elements];<br><br>   <span class="hljs-built_in">memcpy</span>(mem,packet,<span class="hljs-keyword">sizeof</span>(mem));<br>   io_printf(“C: data from SV side\n<span class="hljs-string">&quot;);</span><br><span class="hljs-string">   for (unsigned i=0;i&lt; elements;i++)&#123;</span><br><span class="hljs-string">      io_printf(&quot;</span>mem[%<span class="hljs-number">2</span>d]=&#123;%<span class="hljs-number">4</span>x,%<span class="hljs-number">4</span>x&#125;\n<span class="hljs-string">&quot;,i,mem[i].aval,mem[i].bval);</span><br><span class="hljs-string">   &#125;    </span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">module test;<br>import &quot;DPI-C&quot; function void packet_C( input logic [127:0]);<br><br>   logic [127:0] packet;<br>   initial　begin<br>      packet=128&#x27;h1234_5678_aaaa_bbbb_cccc_dddd_eeee_ffff;<br>      $display(“SV: data sent to C side: %x&quot;,packet);<br>      packet_C(packet);<br>   end<br><br>endmodule<br></code></pre></td></tr></table></figure><h4 id="bit和logic标量和矢量的使用">5.5bit和logic标量和矢量的使用</h4><p>在svdpi.h的头文件中，有如下自定义类型声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint8_t</span> svScalar;<br><span class="hljs-keyword">typedef</span> svScalar svBit; <span class="hljs-comment">/* scalar */</span><br><span class="hljs-keyword">typedef</span> svScalar svLogic; <span class="hljs-comment">/* scalar */</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> svBitVecVal;<br><br>Typedef <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>     <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> aval;<br>     <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bval;<br>&#125; svLogicVecVal;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;svdpi.h&gt;</span> </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(svLogic a)</span>&#123; <br><span class="hljs-keyword">if</span>(a == <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; a is 0 \n&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a == <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; a is 1 \n&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a == <span class="hljs-number">2</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; a is x \n&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a == <span class="hljs-number">3</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; a is z \n&quot;</span>);<br>&#125; <br><span class="hljs-type">void</span>  <span class="hljs-title function_">displaylogicvec</span><span class="hljs-params">(svLogicVecVal *n)</span> &#123;<br>       <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot; data = %d control = %d\n&quot;</span>, n-&gt;aval, n-&gt;bval) ; <br>&#125;<br><br><span class="hljs-type">void</span>  <span class="hljs-title function_">displaybitvec</span><span class="hljs-params">(<span class="hljs-type">const</span> svBitVecVal *k)</span> &#123; <br>       <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot; data = %d\n &quot;</span>, k) ; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="在dpi中使用压缩数组packed-arrays">5.6在DPI中使用压缩数组（PackedArrays）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;svdpi.h&quot;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_nums</span> <span class="hljs-params">(svLogicVecVal nums[<span class="hljs-number">10</span>])</span>&#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;<br>    nums[i] = i ;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">program main; <br>import &quot;DPI-C&quot; function void get_nums(output logic [15:0] nums[10]); <br>logic [15:0] nums[10]; <br><br>initial begin <br>get_nums(nums); <br>foreach (nums[i]) <br>$display(i,nums[i]); <br>end <br>  <br>endprogram <br></code></pre></td></tr></table></figure><h4 id="dpi中使用开放数组open-arrays">5.7DPI中使用开放数组（Openarrays）</h4><p>压缩数组维度，非压缩维度或两个维度的大小可以保持未指定，这种情况称为开放数组（或未定义大小的数组）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">include &lt;stdio.h&gt;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;svdpi.h&gt;</span> </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">pass_array</span><span class="hljs-params">(<span class="hljs-type">const</span> svOpenArrayHandle dy_ar )</span> &#123; <br>  <span class="hljs-type">int</span> i; <br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Array Pointer is %x \n&quot;</span>, svGetArrayPtr(dyn_arr) ); <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Lower index %d \n&quot;</span>, svLow(dyn_arr,<span class="hljs-number">1</span>)); <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Higher index %d \n&quot;</span>, svHigh(dyn_arr, <span class="hljs-number">1</span>) ); <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Left index %d \n&quot;</span>, svLeft(dyn_arr,<span class="hljs-number">1</span>)); <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Right index %d \n&quot;</span>, svRight(dyn_arr, <span class="hljs-number">1</span>) ); <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Length of array %d \n&quot;</span>, svLength(dyn_arr,<span class="hljs-number">1</span>) ); <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Incremental %d \n&quot;</span>,svIncrement(dyn_arr,<span class="hljs-number">1</span>)); <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Dimentions of Array %d \n&quot;</span>, svDimensions(dyn_arr )); <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Size of Array in bytes %d \n&quot;</span>, svSizeOfArray(dyn_arr) ); <br>  <span class="hljs-keyword">for</span> (i= svRight(dy_ar,<span class="hljs-number">1</span>); i &lt;= svLeft(dy_ar,<span class="hljs-number">1</span>); i++) &#123; <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;C: %d %d \n&quot;</span>, i, *(<span class="hljs-type">int</span>*)svGetArrElemPtr1(dy_ar, i) ); <br>  &#125; <br>&#125; <br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">program main; <br>int fxd_arr_1[8:3]; <br>int fxd_arr_2[12:1]; <br>import &quot;DPI-C&quot; context function void pass_array(input int dyn_arr[] ); <br><br>initial begin <br>for (int i = 3; i&lt;=8 ; i++) begin <br>fxd_arr_1[i] = $random(); <br>$display(&quot;SV:fxd_arr_1 %0d %d &quot;,i, fxd_arr_1[i] ); <br>end <br>pass_array( fxd_arr_1 ); <br><br>for (int i = 1; i&lt;=12 ; i++) begin <br>fxd_arr_2[i] = $random() ; <br>$display(&quot;SV: fxd_arr_2 %0d %d &quot;,i, fxd_arr_2[i] ); <br>end <br>pass_array( fxd_arr_2 ); <br><br>end <br>endprogram<br></code></pre></td></tr></table></figure><ul><li>Passing fxd_arr_1 to C Array Pointer is 80fdc58 Lower index 3 Higherindex 8 Left index 8 Right index 3 Length of array 6 Incremental 1Dimentions of Array 1 Size of Array in bytes 24</li><li>Passing fxd_arr_2 to C Array Pointer is 80fdc70 Lower index 1 Higherindex 13 Left index 1 Right index 13 Length of array 13 Incremental -1Dimentions of Array 1 Size of Array in bytes 52</li></ul><p><strong>开放数组提供了一系列查询和访问数组的方法</strong></p><table><colgroup><col style="width: 54%" /><col style="width: 45%" /></colgroup><thead><tr class="header"><th>function</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>int svLeft(const svOpenArrayHandle h, int d);</td><td>Left bound for dimension d</td></tr><tr class="even"><td>int svRight(h, d)</td><td>Right bound for dimension d</td></tr><tr class="odd"><td>int svLow(h, d)</td><td>Low bound for dimension d</td></tr><tr class="even"><td>int svHigh(h, d)</td><td>High bound for dimension d</td></tr><tr class="odd"><td>int svIncrement(h, d)</td><td>If left &gt;= right 1 else -1</td></tr><tr class="even"><td>int svSize(h, d)</td><td>Number of elements in dimension d: svHigh−svLow+1</td></tr><tr class="odd"><td>int svDimensions(h)</td><td>Number of dimensions in open array</td></tr><tr class="even"><td>int svSizeOfArray(h)</td><td>Total size of array in bytes</td></tr><tr class="odd"><td>void *svGetArrayPtr(const svOpenArrayHandle h)</td><td>storage for the entire array</td></tr><tr class="even"><td>void svGetArrElemPtr(const svOpenArrayHandle h, int i1, …)</td><td>an element in the array</td></tr><tr class="odd"><td>void *svGetArrElemPtr1(h, i1)</td><td>an element in a 1-D array</td></tr><tr class="even"><td>void *svGetArrElemPtr2(h, i1, i2)</td><td>an element in a 2-D array</td></tr><tr class="odd"><td>void *svGetArrElemPtr3(h, i1, i2, i3)</td><td>an element in a 3-D array</td></tr></tbody></table><h4 id="在dpi中使用结构体">5.8在DPI中使用结构体</h4><p>在传递<code>struct</code>数据类型时，数据被打包到数组中并从SV传递到C，然后数组被解码回到C中的<code>struct</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;svdpi.h&quot;</span> </span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123; <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span> <br>  <span class="hljs-type">int</span> a; <br>  <span class="hljs-type">int</span> b; <br>  <span class="hljs-type">char</span> c; <br>&#125; C_struct; <br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">export_func</span><span class="hljs-params">(svBitVecVal x[<span class="hljs-number">3</span>])</span>; <br><span class="hljs-type">void</span> <span class="hljs-title function_">import_func</span><span class="hljs-params">()</span> &#123; <br>  C_struct s_data; <br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>]; <br><br>  s_data.a = <span class="hljs-number">51</span>; <br>  s_data.b = <span class="hljs-number">242</span>; <br>  s_data.c = <span class="hljs-number">35</span>; <br>  <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;C : s_data.a = %d\n&quot;</span>, s_data.a ); <br>  <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;C : s_data.b = %d\n&quot;</span>, s_data.b ); <br>  <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;C : s_data.c = %d\n&quot;</span>, s_data.c ); <br><br>  arr[<span class="hljs-number">0</span>] = s_data.a ; <br>  arr[<span class="hljs-number">1</span>] = s_data.b ; <br>  arr[<span class="hljs-number">2</span>] = s_data.c ; <br>  export_func(arr); <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">program main; <br><br>export &quot;DPI-C&quot; function export_func; <br>import &quot;DPI-C&quot; function void import_func(); <br><br>typedef struct packed&#123; <br>  int a; <br>  int b; <br>  byte c; <br>&#125; SV_struct; <br><br>function void export_func(input int arr[3]); <br>SV_struct s_data; <br><br>  s_data.a = arr[0]; <br>  s_data.b = arr[1]; <br>  s_data.c = arr[2]; <br>  $display(&quot; SV: s_data.a = %0d&quot;, s_data.a ); <br>  $display(&quot; SV: s_data.b = %0d&quot;, s_data.b ); <br>  $display(&quot; SV: s_data.c = %0d \n&quot;, s_data.c ); <br>endfunction <br><br>initial begin <br>import_func(); <br>end <br><br>endprogram<br></code></pre></td></tr></table></figure><p>在SV和C/C++代码使用定义的未压缩的结构体数据类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;svdpi.h&quot;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> b;<br>&#125;mystruct;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">mydisplay</span><span class="hljs-params">(mystruct *s1)</span>&#123;<br><span class="hljs-type">int</span> s2;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;C: gets values from SV, s1.a=%d, s1.b=%d\\\\\\\\\\\\\\\\n&quot;</span>,s1-&gt;a,s1-&gt;b);<br>s1-&gt;a = <span class="hljs-number">100</span>;<br>s1-&gt;b = <span class="hljs-number">200</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;C: set values,  s1.a=%d, s1.b=%d\\\\\\\\\\\\\\\\n&quot;</span>,s1-&gt;a,s1-&gt;b);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">program p1;<br>typedef struct &#123;<br>int a;<br>int b;<br>&#125; mystruct;<br><br>import &quot;DPI-C&quot; function void mydisplay(inout mystruct s1);<br>mystruct s1;<br>initial begin<br>s1.a =10;<br>s1.b =20;<br>$display(&quot;SV: s1.a=%0d,s1.b=%0d&quot;,s1.a,s1.b);<br><br>mydisplay(s1);<br>$display(&quot;SV after DPI call: s1.a=%0d,s1.b=%0d&quot;,s1.a,s1.b);<br>end <br><br>endprogram<br></code></pre></td></tr></table></figure><p>试着将上面例子中sv端结构体，改为packed类型，试试看C端打印信息会是什么样的？</p><p>压缩的结构体是包含packed保留字的结构体。 在结构内，保证了位连续性。因此，成员也必须是矢量类型。 （不要混合real /shortreal。）如果混合使用2值或者4值逻辑，它们将在内存布局方面生成4个值，因此不要混用它们。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;svdpi.h&quot;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(svBitVecVal*)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">struct_operation</span><span class="hljs-params">()</span>&#123;<br>   svBitVecVal rgb;<br>   svPutPartselBit(&amp;rgb,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>);<span class="hljs-comment">//b</span><br>   svPutPartselBit(&amp;rgb,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>);<span class="hljs-comment">//g</span><br>   svPutPartselBit(&amp;rgb,<span class="hljs-number">3</span>,<span class="hljs-number">16</span>,<span class="hljs-number">8</span>);<span class="hljs-comment">//r</span><br>   func(&amp;rgb);<br>   svBitVecVal blue=<span class="hljs-number">0</span>;<br>   svBitVecVal red=<span class="hljs-number">0</span>;<br>   svBitVecVal green=<span class="hljs-number">0</span>;<br>   svGetPartselBit(&amp;blue,&amp;rgb,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>);<br>   svGetPartselBit(&amp;green,&amp;rgb,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>);<br>   svGetPartselBit(&amp;red,&amp;rgb,<span class="hljs-number">16</span>,<span class="hljs-number">8</span>);<br><br>   io_printf(<span class="hljs-string">&quot;C: data from SV side. red %3d green %3d blue %3d.\\\\\\\\\\\\\\\\n&quot;</span>,red,green,blue);<br><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs systemverilog">module root_scope;<br>    export &quot;DPI-C&quot; function func;<br>    import &quot;DPI-C&quot; context task struct_operation();<br><br>   typedef struct packed &#123;<br>      byte red;//MSB<br>      byte green;<br>      byte blue;//LSB ↑<br>   &#125; RGB_TYPE;<br><br>   function void func(inout RGB_TYPE A);<br>      $display(&quot;SV: data from C side. red=%3d blue=%3d green=%3d.&quot;,A.red,A.green,A.blue);<br>      A.blue=101;<br>      A.green=102;<br>      A.red=103;<br>      $display(&quot;SV: data change for C side read.&quot;);<br>          <br>   endfunction<br><br>   initial begin<br>      struct_operation();<br>   end<br><br>endmodule<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;dpi学习笔记&quot;&gt;DPI学习笔记&lt;/h1&gt;
&lt;h2 id=&quot;一dpi前世-pli&quot;&gt;一、DPI前世-PLI&lt;/h2&gt;
&lt;p&gt;首先思考几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;用户如何获得Verilog描述的电路的内部&lt;strong&gt;数据结构信息&lt;/strong&gt;?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;EDA仿真器在仿真verilog的tb时，FSDB波形是如何生成的？&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;$display，$stop，$finish等系统函数,如何被不同EDA仿真器识别?&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了底层描述硬件的能力，Verilog同样应该具有与上层交互的能力，基于此&lt;strong&gt;Verilog
PLI&lt;/strong&gt;(Programming Language
Interface)应运而生，它是一种从Verilog代码调用C/C++函数的机制。可以说PLI的出现是Verilog语言在硬件设计方面如此成功的原因之一。
使用PLI，第三方公司和最终用户可以扩展商业Verilog仿真器的功能。在Verilog代码中调用的函数称为&lt;strong&gt;系统调用&lt;/strong&gt;。内置系统函数的一个示例是$display，$stop，$finish等。
PLI允许用户创建自定义系统调用，这是Verilog语法不允许我们做的事情。基于PLI其实我们可以做的更多：&lt;/p&gt;</summary>
    
    
    
    <category term="基础课程" scheme="https://zmailee.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="SystemVerilog" scheme="https://zmailee.github.io/tags/SystemVerilog/"/>
    
    <category term="DPI-C" scheme="https://zmailee.github.io/tags/DPI-C/"/>
    
  </entry>
  
  <entry>
    <title>智能计算系统</title>
    <link href="https://zmailee.github.io/2022/10/19/%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E7%B3%BB%E7%BB%9F/"/>
    <id>https://zmailee.github.io/2022/10/19/%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-10-19T12:40:32.173Z</published>
    <updated>2022-11-04T05:25:24.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章概述">第一章：概述</h1><p><strong>智能计算系统是智能的物质载体</strong></p><p>学习目标：学习人工智能系统的设计与研究，掌握对智能计算的完整软硬件技术栈。</p><h2 id="人工智能三个流派">人工智能三个流派</h2><p><strong>行为主义</strong>：基于控制论，构建感知-动作型控制系统<strong>符号主义</strong>：基于符号逻辑的方法，用逻辑表示知识和求解问题<strong>连接主义</strong>：基于大脑中神经元细胞连接的计算模型，用<strong>人工神经网络</strong>来<strong>拟合</strong>智能行为</p><span id="more"></span><h2 id="深度学习的局限性">深度学习的局限性</h2><p>深度学习是一把梯子，而不是火箭</p><ul><li>泛化能力有限</li><li>缺乏推理能力</li><li>缺乏可解释性</li><li>鲁棒性欠佳</li></ul><h2 id="异构智能计算系统">异构智能计算系统</h2><p>满足智能计算的算力增长需求，降低能耗比</p><h1 id="第二章神经网络基础">第二章：神经网络基础</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;第一章概述&quot;&gt;第一章：概述&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;智能计算系统是智能的物质载体&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;学习目标：学习人工智能系统的设计与研究，掌握对智能计算的完整软硬件技术栈。&lt;/p&gt;
&lt;h2 id=&quot;人工智能三个流派&quot;&gt;人工智能三个流派&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;行为主义&lt;/strong&gt;：基于控制论，构建感知-动作型控制系统
&lt;strong&gt;符号主义&lt;/strong&gt;：基于符号逻辑的方法，用逻辑表示知识和求解问题
&lt;strong&gt;连接主义&lt;/strong&gt;：基于大脑中神经元细胞连接的计算模型，用&lt;strong&gt;人工神经网络&lt;/strong&gt;来&lt;strong&gt;拟合&lt;/strong&gt;智能行为&lt;/p&gt;</summary>
    
    
    
    <category term="基础课程" scheme="https://zmailee.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="人工智能" scheme="https://zmailee.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="计算机体系结构" scheme="https://zmailee.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="https://zmailee.github.io/2022/10/19/Git/"/>
    <id>https://zmailee.github.io/2022/10/19/Git/</id>
    <published>2022-10-19T12:40:32.168Z</published>
    <updated>2022-10-31T02:31:51.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git">Git</h1><p>用git执行下面语句时报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push -u origin master<br>error: failed to push some refs to ‘xxxxx’<br>hint: Updates were rejected because the tip of your current branch is behind<br>hint: its remote counterpart. Integrate the remote changes (e.g.<br>hint: ‘git pull …’) before pushing again.<br>hint: See the ‘Note about fast-forwards’ <span class="hljs-keyword">in</span> ‘git push --<span class="hljs-built_in">help</span>’ <span class="hljs-keyword">for</span> details.<br></code></pre></td></tr></table></figure><p>原因：<strong>Github端已经产生了commit没有同步到本地端</strong></p><span id="more"></span><p>1.使用强制push的方法，这样会使远程修改丢失</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push -u origin master -f<br></code></pre></td></tr></table></figure><p>2.先将远程repository修改pull下来再push</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull origin master<br>git push -u origin master<br></code></pre></td></tr></table></figure><p>结果又报refusing to merge unrelated histories</p><p>解决方案</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull origin master --allow-unrelated-histories<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;git&quot;&gt;Git&lt;/h1&gt;
&lt;p&gt;用git执行下面语句时报错&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;git push -u origin master&lt;br&gt;error: failed to push some refs to ‘xxxxx’&lt;br&gt;hint: Updates were rejected because the tip of your current branch is behind&lt;br&gt;hint: its remote counterpart. Integrate the remote changes (e.g.&lt;br&gt;hint: ‘git pull …’) before pushing again.&lt;br&gt;hint: See the ‘Note about fast-forwards’ &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; ‘git push --&lt;span class=&quot;hljs-built_in&quot;&gt;help&lt;/span&gt;’ &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; details.&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;原因：&lt;strong&gt;Github端已经产生了commit没有同步到本地端&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="https://zmailee.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
</feed>
